import { rgb } from 'd3-color';

function accessor(x, fallback) {
  return x == null ? fallback
    : typeof x === 'function' ? x
    : d => d[x];
}

function bin1d(data, x, weight, lo, hi, n) {
  const grid = new Float64Array(n);
  const delta = (n - 1) / (hi - lo);

  for (let i = 0; i < data.length; ++i) {
    const d = data[i];
    const xi = x(d, i, data);
    const wi = weight(d, i, data);

    // skip NaN and Infinite values
    if (!(Number.isFinite(xi) && Number.isFinite(wi))) {
      continue;
    }

    const p = (xi - lo) * delta;
    const u = Math.floor(p);
    const v = u + 1;

    if (0 <= u && v < n) {
      grid[u] += (v - p) * wi;
      grid[v] += (p - u) * wi;
    } else if (u === -1) {
      grid[v] += (p - u) * wi;
    } else if (v === n) {
      grid[u] += (v - p) * wi;
    }
  }

  return grid;
}

// Deriche's approximation of Gaussian smoothing
// Adapted from Getreuer's C implementation (BSD license)
// https://www.ipol.im/pub/art/2013/87/gaussian_20131215.tgz
// http://dev.ipol.im/~getreuer/code/doc/gaussian_20131215_doc/gaussian__conv__deriche_8c.html

function dericheConfig(sigma, negative = false) {
  // compute causal filter coefficients
  const a = new Float64Array(5);
  const bc = new Float64Array(4);
  dericheCausalCoeff(a, bc, sigma);

  // numerator coefficients of the anticausal filter
  const ba = Float64Array.of(
    0,
    bc[1] - a[1] * bc[0],
    bc[2] - a[2] * bc[0],
    bc[3] - a[3] * bc[0],
    -a[4] * bc[0]
  );

  // impulse response sums
  const accum_denom = 1.0 + a[1] + a[2] + a[3] + a[4];
  const sum_causal = (bc[0] + bc[1] + bc[2] + bc[3]) / accum_denom;
  const sum_anticausal = (ba[1] + ba[2] + ba[3] + ba[4]) / accum_denom;

  // coefficients object
  return {
    sigma,
    negative,
    a,
    b_causal: bc,
    b_anticausal: ba,
    sum_causal,
    sum_anticausal
  };
}

function dericheCausalCoeff(a_out, b_out, sigma) {
  const K = 4;

  const alpha = Float64Array.of(
    0.84, 1.8675,
    0.84, -1.8675,
    -0.34015, -0.1299,
    -0.34015, 0.1299
  );

  const x1 = Math.exp(-1.783 / sigma);
  const x2 = Math.exp(-1.723 / sigma);
  const y1 = 0.6318 / sigma;
  const y2 = 1.997 / sigma;
  const beta = Float64Array.of(
    -x1 * Math.cos( y1), x1 * Math.sin( y1),
    -x1 * Math.cos(-y1), x1 * Math.sin(-y1),
    -x2 * Math.cos( y2), x2 * Math.sin( y2),
    -x2 * Math.cos(-y2), x2 * Math.sin(-y2)
  );

  const denom = sigma * 2.5066282746310007;

  // initialize b/a = alpha[0] / (1 + beta[0] z^-1)
  const b = Float64Array.of(alpha[0], alpha[1], 0, 0, 0, 0, 0, 0);
  const a = Float64Array.of(1, 0, beta[0], beta[1], 0, 0, 0, 0, 0, 0);

  let j, k;

  for (k = 2; k < 8; k += 2) {
    // add kth term, b/a += alpha[k] / (1 + beta[k] z^-1)
    b[k]     = beta[k] * b[k - 2] - beta[k + 1] * b[k - 1];
    b[k + 1] = beta[k] * b[k - 1] + beta[k + 1] * b[k - 2];
    for (j = k - 2; j > 0; j -= 2) {
      b[j]     += beta[k] * b[j - 2] - beta[k + 1] * b[j - 1];
      b[j + 1] += beta[k] * b[j - 1] + beta[k + 1] * b[j - 2];
    }
    for (j = 0; j <= k; j += 2) {
      b[j]     += alpha[k] * a[j]     - alpha[k + 1] * a[j + 1];
      b[j + 1] += alpha[k] * a[j + 1] + alpha[k + 1] * a[j];
    }

    a[k + 2] = beta[k] * a[k]     - beta[k + 1] * a[k + 1];
    a[k + 3] = beta[k] * a[k + 1] + beta[k + 1] * a[k];
    for (j = k; j > 0; j -= 2) {
      a[j]     += beta[k] * a[j - 2] - beta[k + 1] * a[j - 1];
      a[j + 1] += beta[k] * a[j - 1] + beta[k + 1] * a[j - 2];
    }
  }

  for (k = 0; k < K; ++k) {
    j = k << 1;
    b_out[k] = b[j] / denom;
    a_out[k + 1] = a[j + 2];
  }
}

function dericheConv2d(cx, cy, grid, [nx, ny]) {
  // allocate buffers
  const yc = new Float64Array(Math.max(nx, ny)); // causal
  const ya = new Float64Array(Math.max(nx, ny)); // anticausal
  const h = new Float64Array(5);
  const d = new Float64Array(grid.length);

  // convolve rows
  for (let row = 0, r0 = 0; row < ny; ++row, r0 += nx) {
    const dx = d.subarray(r0);
    dericheConv1d(cx, grid.subarray(r0), nx, 1, yc, ya, h, dx);
  }

  // convolve columns
  for (let c0 = 0; c0 < nx; ++c0) {
    const dy = d.subarray(c0);
    dericheConv1d(cy, dy, ny, nx, yc, ya, h, dy);
  }

  return d;
}

function dericheConv1d(
  c, src, N,
  stride = 1,
  y_causal = new Float64Array(N),
  y_anticausal = new Float64Array(N),
  h = new Float64Array(5),
  d = y_causal,
  init = dericheInitZeroPad
) {
  const stride_2 = stride * 2;
  const stride_3 = stride * 3;
  const stride_4 = stride * 4;
  const stride_N = stride * N;
  let i, n;

  // initialize causal filter on the left boundary
  init(
    y_causal, src, N, stride,
    c.b_causal, 3, c.a, 4, c.sum_causal, h, c.sigma
  );

  // filter the interior samples using a 4th order filter. Implements:
  // for n = K, ..., N - 1,
  //   y^+(n) = \sum_{k=0}^{K-1} b^+_k src(n - k)
  //          - \sum_{k=1}^K a_k y^+(n - k)
  // variable i tracks the offset to the nth sample of src, it is
  // updated together with n such that i = stride * n.
  for (n = 4, i = stride_4; n < N; ++n, i += stride) {
    y_causal[n] = c.b_causal[0] * src[i]
      + c.b_causal[1] * src[i - stride]
      + c.b_causal[2] * src[i - stride_2]
      + c.b_causal[3] * src[i - stride_3]
      - c.a[1] * y_causal[n - 1]
      - c.a[2] * y_causal[n - 2]
      - c.a[3] * y_causal[n - 3]
      - c.a[4] * y_causal[n - 4];
  }

  // initialize the anticausal filter on the right boundary
  init(
    y_anticausal, src, N, -stride,
    c.b_anticausal, 4, c.a, 4, c.sum_anticausal, h, c.sigma
  );

  // similar to the causal filter above, the following implements:
  // for n = K, ..., N - 1,
  //   y^-(n) = \sum_{k=1}^K b^-_k src(N - n - 1 - k)
  //          - \sum_{k=1}^K a_k y^-(n - k)
  // variable i is updated such that i = stride * (N - n - 1).
  for (n = 4, i = stride_N - stride * 5; n < N; ++n, i -= stride) {
    y_anticausal[n] = c.b_anticausal[1] * src[i + stride]
      + c.b_anticausal[2] * src[i + stride_2]
      + c.b_anticausal[3] * src[i + stride_3]
      + c.b_anticausal[4] * src[i + stride_4]
      - c.a[1] * y_anticausal[n - 1]
      - c.a[2] * y_anticausal[n - 2]
      - c.a[3] * y_anticausal[n - 3]
      - c.a[4] * y_anticausal[n - 4];
  }

  // sum the causal and anticausal responses to obtain the final result
  if (c.negative) {
    // do not threshold if the input grid includes negatively weighted values
    for (n = 0, i = 0; n < N; ++n, i += stride) {
      d[i] = y_causal[n] + y_anticausal[N - n - 1];
    }
  } else {
    // threshold to prevent small negative values due to floating point error
    for (n = 0, i = 0; n < N; ++n, i += stride) {
      d[i] = Math.max(0, y_causal[n] + y_anticausal[N - n - 1]);
    }
  }

  return d;
}

function dericheInitZeroPad(
  dest, src, N, stride, b, p, a, q,
  sum, h, sigma, tol = 0.5
) {
  const stride_N = Math.abs(stride) * N;
  const off = stride < 0 ? stride_N + stride : 0;
  let i, n, m;

  // compute the first q taps of the impulse response, h_0, ..., h_{q-1}
  for (n = 0; n < q; ++n) {
    h[n] = (n <= p) ? b[n] : 0;
    for (m = 1; m <= q && m <= n; ++m) {
      h[n] -= a[m] * h[n - m];
    }
  }

  // compute dest_m = sum_{n=1}^m h_{m-n} src_n, m = 0, ..., q-1
  // note: q == 4
  for (m = 0; m < q; ++m) {
    for (dest[m] = 0, n = 1; n <= m; ++n) {
      i = off + stride * n;
      if (i >= 0 && i < stride_N) {
        dest[m] += h[m - n] * src[i];
      }
    }
  }

  const cur = src[off];
  const max_iter = Math.ceil(sigma * 10);
  for (n = 0; n < max_iter; ++n) {
    /* dest_m = dest_m + h_{n+m} src_{-n} */
    for (m = 0; m < q; ++m) {
      dest[m] += h[m] * cur;
    }

    sum -= Math.abs(h[0]);
    if (sum <= tol) break;

    /* Compute the next impulse response tap, h_{n+q} */
    h[q] = (n + q <= p) ? b[n + q] : 0;
    for (m = 1; m <= q; ++m) {
      h[q] -= a[m] * h[q - m];
    }

    /* Shift the h array for the next iteration */
    for (m = 0; m < q; ++m) {
      h[m] = h[m + 1];
    }
  }

  return;
}

function extent(data, x, pad = 0) {
  const n = data.length;
  let lo;
  let hi;
  for (let i = 0; i < n; ++i) {
    const v = x(data[i], i, data);
    if (v != null) {
      if (lo === undefined) {
        if (v >= v) lo = hi = v;
      } else {
        if (v < lo) lo = v;
        if (v > hi) hi = v;
      }
    }
  }
  return [lo - pad, hi + pad];
}

// Scott, D. W. (1992) Multivariate Density Estimation:
// Theory, Practice, and Visualization. Wiley.
function nrd(data, x) {
  const values = data.map(x).filter(v => v != null && v >= v);
  values.sort((a, b) => a - b);
  const sd = stdev(values);
  const q1 = quantile(values, 0.25);
  const q3 = quantile(values, 0.75);

  const n = values.length,
        h = (q3 - q1) / 1.34,
        v = Math.min(sd, h) || sd || Math.abs(q1) || 1;

  return 1.06 * v * Math.pow(n, -0.2);
}

function stdev(values) {
  const n = values.length;
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  for (let i = 0; i < n; ++i) {
    const value = values[i];
    delta = value - mean;
    mean += delta / ++count;
    sum += delta * (value - mean);
  }
  return count > 1 ? Math.sqrt(sum / (count - 1)) : NaN;
}

function quantile(values, p) {
  const n = values.length;

  if (!n) return NaN;
  if ((p = +p) <= 0 || n < 2) return values[0];
  if (p >= 1) return values[n - 1];

  const i = (n - 1) * p;
  const i0 = Math.floor(i);
  const v0 = values[i0];
  return v0 + (values[i0 + 1] - v0) * (i - i0);
}

function density1d(data, options = {}) {
  const { adjust = 1, pad = 3, bins = 512 } = options;
  const x = accessor(options.x, x => x);
  const w = accessor(options.weight, () => 1 / data.length);

  let bandwidth = options.bandwidth ?? adjust * nrd(data, x);

  const [lo, hi] = options.extent ?? extent(data, x, pad * bandwidth);
  const grid = bin1d(data, x, w, lo, hi, bins);
  const delta = (hi - lo) / (bins - 1);
  const neg = grid.some(v => v < 0);

  let config = dericheConfig(bandwidth / delta, neg);
  let result;

  function* points(x = 'x', y = 'y') {
    const result = estimator.grid();
    const scale = 1 / delta;
    for (let i = 0; i < bins; ++i) {
      yield {
        [x]: lo + i * delta,
        [y]: result[i] * scale
      };
    }
  }

  const estimator = {
    [Symbol.iterator]: points,
    points,
    grid: () => result || (result = dericheConv1d(config, grid, bins)),
    extent: () => [lo, hi],
    bandwidth(_) {
      if (arguments.length) {
        if (_ !== bandwidth) {
          bandwidth = _;
          result = null;
          config = dericheConfig(bandwidth / delta, neg);
        }
        return estimator;
      } else {
        return bandwidth;
      }
    }
  };

  return estimator;
}

function bin2d(data, x, y, w, x0, x1, xn, y0, y1, yn) {
  const grid = new Float64Array(xn * yn);
  const xdelta = (xn - 1) / (x1 - x0);
  const ydelta = (yn - 1) / (y1 - y0);

  for (let i = 0; i < data.length; ++i) {
    const d = data[i];
    const xi = x(d, i, data);
    const yi = y(d, i, data);
    const wi = w(d, i, data);

    // skip NaN and Infinite values
    if (!(Number.isFinite(xi) && Number.isFinite(yi) && Number.isFinite(wi))) {
      continue;
    }

    const xp = (xi - x0) * xdelta;
    const xu = Math.floor(xp);
    const xv = xu + 1;
    const yp = (yi - y0) * ydelta;
    const yu = Math.floor(yp);
    const yv = yu + 1;

    if (0 <= xu && xv < xn) {
      if (0 <= yu && yv < yn) {
        grid[xu + yu * xn] += (xv - xp) * (yv - yp) * wi;
        grid[xu + yv * xn] += (xv - xp) * (yp - yu) * wi;
        grid[xv + yu * xn] += (xp - xu) * (yv - yp) * wi;
        grid[xv + yv * xn] += (xp - xu) * (yp - yu) * wi;
      } else if (yu === -1) {
        grid[xu + yv * xn] += (xv - xp) * (yp - yu) * wi;
        grid[xv + yv * xn] += (xp - xu) * (yp - yu) * wi;
      } else if (yv === yn) {
        grid[xv + yu * xn] += (xp - xu) * (yv - yp) * wi;
        grid[xu + yu * xn] += (xv - xp) * (yv - yp) * wi;
      }
    } else if (xu === -1) {
      if (0 <= yu && yv < yn) {
        grid[xv + yu * xn] += (xp - xu) * (yv - yp) * wi;
        grid[xv + yv * xn] += (xp - xu) * (yp - yu) * wi;
      } else if (yu === -1) {
        grid[xv + yv * xn] += (xp - xu) * (yp - yu) * wi;
      } else if (yv === yn) {
        grid[xv + yu * xn] += (xp - xu) * (yv - yp) * wi;
      }
    } else if (xv === xn) {
      if (0 <= yu && yv < yn) {
        grid[xu + yu * xn] += (xv - xp) * (yv - yp) * wi;
        grid[xu + yv * xn] += (xv - xp) * (yp - yu) * wi;
      } else if (yu === -1) {
        grid[xu + yv * xn] += (xv - xp) * (yp - yu) * wi;
      } else if (yv === yn) {
        grid[xu + yu * xn] += (xv - xp) * (yv - yp) * wi;
      }
    }
  }

  return grid;
}

function heatmap(
  grid,
  w,
  h,
  color = opacityMap(0, 0, 0),
  [lo, hi] = [min(grid, 0), max(grid, 0)],
  canvas = createCanvas(w, h),
  paletteSize = 256
) {
  const norm = 1 / (hi - lo);
  const ctx = canvas.getContext('2d');
  const img = ctx.getImageData(0, 0, w, h);
  const pix = img.data;
  const size = paletteSize - 1;
  const palette = buildPalette(size, color);

  for (let j = 0, k = 0; j < h; ++j) {
    for (let i = 0, row = (h - j - 1) * w; i < w; ++i, k += 4) {
      const v = Math.min(1, Math.max(grid[i + row] - lo, 0) * norm);
      const c = (size * v) << 2;
      pix[k + 0] = palette[c + 0];
      pix[k + 1] = palette[c + 1];
      pix[k + 2] = palette[c + 2];
      pix[k + 3] = palette[c + 3];
    }
  }

  ctx.putImageData(img, 0, 0);
  return canvas;
}

function buildPalette(size, interp) {
  const p = new Uint8ClampedArray(4 * (size + 1));
  for (let i = 0; i <= size; ++i) {
    const v = interp(i / size);
    const {r, g, b, opacity = 1} = typeof v === 'string' ? rgb(v) : v;
    const k = i << 2;
    p[k + 0] = r;
    p[k + 1] = g;
    p[k + 2] = b;
    p[k + 3] = (255 * opacity) | 0;
  }
  return p;
}

function createCanvas(w, h) {
  if (typeof document !== 'undefined') {
    // eslint-disable-next-line no-undef
    const c = document.createElement('canvas');
    c.setAttribute('width', w);
    c.setAttribute('height', h);
    return c;
  }
  throw 'Can not create a canvas instance, provide a canvas as a parameter.';
}

function max(array, v) {
  const n = array.length;
  for (let i = 0; i < n; ++i) {
    if (array[i] > v) v = array[i];
  }
  return v;
}

function min(array, v) {
  const n = array.length;
  for (let i = 0; i < n; ++i) {
    if (array[i] < v) v = array[i];
  }
  return v;
}

function opacityMap(r, g, b) {
  return opacity => ({ r, g, b, opacity });
}

function density2d(data, options = {}) {
  const { adjust = 1, pad = 3, bins = [256, 256] } = options;
  const x = accessor(options.x, d => d[0]);
  const y = accessor(options.y, d => d[1]);
  const w = accessor(options.weight, () => 1 / data.length);

  let [
    bwX = adjust * nrd(data, x),
    bwY = adjust * nrd(data, y)
  ] = number2(options.bandwidth);

  const [
    [x0, x1] = extent(data, x, pad * bwX),
    [y0, y1] = extent(data, y, pad * bwY)
  ] = number2_2(options.extent);

  const [binsX, binsY] = number2(bins);

  const grid = bin2d(data, x, y, w, x0, x1, binsX, y0, y1, binsY);
  const deltaX = (x1 - x0) / (binsX - 1);
  const deltaY = (y1 - y0) / (binsY - 1);
  const neg = grid.some(v => v < 0);

  let configX = dericheConfig(bwX / deltaX, neg);
  let configY = dericheConfig(bwY / deltaY, neg);
  let result;

  function* points(x = 'x', y = 'y', z = 'z') {
    const result = estimator.grid();
    const scale = 1 / (deltaX * deltaY);
    for (let k = 0, j = 0; j < binsY; ++j) {
      for (let i = 0; i < binsX; ++i, ++k) {
        yield {
          [x]: x0 + i * deltaX,
          [y]: y0 + j * deltaY,
          [z]: result[k] * scale
        };
      }
    }
  }

  const estimator = {
    [Symbol.iterator]: points,
    points,
    grid: () => result || (result = dericheConv2d(configX, configY, grid, [binsX, binsY])),
    extent: () => [ [x0, x1], [y0, y1] ],
    heatmap: ({ color, clamp, canvas, maxColors } = {}) =>
      heatmap(estimator.grid(), binsX, binsY, color, clamp, canvas, maxColors),
    bandwidth(_) {
      if (arguments.length) {
        const [_0, _1] = number2(_);
        if (_0 !== bwX) {
          result = null;
          configX = dericheConfig((bwX = _0) / deltaX, neg);
        }
        if (_1 !== bwY) {
          result = null;
          configY = dericheConfig((bwY = _1) / deltaY, neg);
        }
        return estimator;
      } else {
        return [bwX, bwY];
      }
    }
  };

  return estimator;
}

function number2(_) {
  return _ == null ? [undefined, undefined]
    : typeof _ === 'number' ? [_, _]
    : _;
}

function number2_2(_) {
  return _ == null ? [undefined, undefined]
    : typeof _[0] === 'number' ? [_, _]
    : _;
}

export { density1d, density2d, nrd, opacityMap };
