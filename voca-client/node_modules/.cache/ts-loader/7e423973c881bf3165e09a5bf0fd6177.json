{"remainingRequest":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/babel-loader/lib/index.js!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/ts-loader/index.js??ref--15-2!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/eslint-loader/index.js??ref--14-0!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/src/model/level-data-manager.ts","dependencies":[{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/src/model/level-data-manager.ts","mtime":1732546288000},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/babel.config.js","mtime":1732546288000},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/cache-loader/dist/cjs.js","mtime":1732627998206},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/babel-loader/lib/index.js","mtime":1732627998426},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/ts-loader/index.js","mtime":1732627997224},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/eslint-loader/index.js","mtime":1732627997140}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZXJyb3IuY2F1c2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5wdXNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmZvci1lYWNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5yZWR1Y2UuanMiOwppbXBvcnQgTGV2ZWxJbmRleE9iaiBmcm9tICIuL2xldmVsLWluZGV4LW9iaiI7CmltcG9ydCBheGlvcyBmcm9tICJheGlvcyI7CmltcG9ydCBUcmVuZFRyZWUgZnJvbSAiQC9oZWxwZXIvdGVuZC1xdWVyeS10cmVlIjsKaW1wb3J0IHN0b3JlLCB7IHB1c2hUaW1lQXJyYXkgfSBmcm9tICJAL3N0b3JlIjsKaW1wb3J0IHsgY2FuQ3V0LCBjb21wdXRlTG9zZWREYXRhUmFuZ2UsIGNvbXB1dGVMb3NlZERhdGFSYW5nZVYxLCBjb21wdXRlVGltZVNFIH0gZnJvbSAiQC9oZWxwZXIvdXRpbCI7CmltcG9ydCB7IFVuaWZvcm1HYXBPYmogfSBmcm9tICIuL3VuaWZvcm0tZ2FwLW9iaiI7Ci8vIGltcG9ydCB7IGxvYWREYXRhRm9yUmFuZ2VMZXZlbCwgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWxSYXdNaW5NYXgsIGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsLCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDEsIGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMk1pbk1heE1pc3MsIGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMU1pbk1heE1pc3MsIGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMVdTLCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbEZvck1pbk1heE1pc3MgfSBmcm9tICIuLi9hcGkvYnVpbGRfdHJlZSIKaW1wb3J0IHsgbG9hZERhdGFGb3JSYW5nZUxldmVsLCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbFJhd01pbk1heCwgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwsIGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMSwgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwyTWluTWF4TWlzcywgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxTWluTWF4TWlzcywgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxV1MgfSBmcm9tICIuLi9hcGkvYnVpbGRfdHJlZSI7CmltcG9ydCBDYWNoZSBmcm9tICJscnUtY2FjaGUiOwppbXBvcnQgeyBnZXRGbGFnIH0gZnJvbSAiQC9nbG9iYWxfc3RhdGUvc3RhdGUiOwphc3luYyBmdW5jdGlvbiBnZXQodXJsKSB7CiAgdXJsID0gJ3Bvc3RncmVzJyArIHVybDsKICAvL2NvbnN0IGxvYWRpbmcgPSBvcGVuTG9hZGluZygpOwogIGNvbnN0IHsKICAgIGRhdGEKICB9ID0gYXdhaXQgYXhpb3MuZ2V0KHVybCk7CiAgLy9sb2FkaW5nLmNsb3NlKCk7CiAgcmV0dXJuIGRhdGE7Cn0KbGV0IGFsbFRpbWVzID0gW107CmxldCBhbGxTdW1UaW1lcyA9IFtdOwpleHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbERhdGFNYW5hZ2VyIHsKICBjb25zdHJ1Y3RvcihsZXZlbEluZGV4T2JqcywgZGF0YU5hbWUsIG1heExldmVsKSB7CiAgICB0aGlzLmxldmVsSW5kZXhPYmpzID0gbGV2ZWxJbmRleE9ianM7CiAgICB0aGlzLm1heExldmVsID0gbWF4TGV2ZWwgPyBtYXhMZXZlbCA6IHN0b3JlLnN0YXRlLmNvbnRyb2xQYXJhbXMudGFibGVNYXhMZXZlbDsKICAgIHRoaXMucmVhbERhdGFSb3dOdW0gPSAyICoqIChtYXhMZXZlbCA/IG1heExldmVsIDogc3RvcmUuc3RhdGUuY29udHJvbFBhcmFtcy50YWJsZU1heExldmVsKTsKICAgIHRoaXMuZGF0YU5hbWUgPSBkYXRhTmFtZTsKICAgIHRoaXMuaXNTaG93ID0gdHJ1ZTsKICAgIHRoaXMuY29sdW1uSW5mb3MgPSBudWxsOwogICAgdGhpcy5jdXJOb2RlTnVtID0gMDsKICAgIHRoaXMuZGF0YUNhY2hlID0gbmV3IEFycmF5KCk7CiAgICB0aGlzLmNhY2hlTWFwID0gbmV3IE1hcCgpOwogICAgdGhpcy5jYWNoZUhlYWQgPSBudWxsOwogICAgdGhpcy5jYWNoZVRhaWwgPSBudWxsOwogICAgdGhpcy5tYXhDYWNoZU5vZGVOdW0gPSAxMDAwMDA7CiAgICB0aGlzLmxydUNhY2hlID0gbnVsbDsKICAgIHRoaXMuaW5pdENhY2hlKCk7CiAgICB0aGlzLmRlbGV0ZVF1ZXVlID0gW107CiAgICB0aGlzLmlzSW50ZXJpbmcgPSBmYWxzZTsKICAgIHRoaXMuaXNFdmljdGluZyA9IGZhbHNlOwogIH0KICBhc3luYyBnZXREYXRhTW9ja1NlcnZlcihpbmZvKSB7CiAgICBjb25zdCBpbnRlcm5hbExldmVsID0gdGhpcy5tYXhMZXZlbCAtIGluZm8ubGV2ZWw7CiAgICBjb25zdCBvdXR0ZXJMZXZlbCA9IGluZm8ubGV2ZWw7CiAgICBjb25zdCBuZXh0TGV2ZWwgPSBpbnRlcm5hbExldmVsOwogICAgaWYgKG5leHRMZXZlbCA8IDEpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJsZXZlbCBvdXQgb2YgcmFuZ2UiKTsKICAgIH0KICAgIGNvbnN0IHdpZHRoID0gMiAqKiBNYXRoLmNlaWwoTWF0aC5sb2cyKGluZm8ud2lkdGgpKTsKICAgIGxldCBvZmZzZXQgPSBpbmZvLm9mZnNldDsKICAgIGxldCBlbmQgPSBpbmZvLmVuZDsKICAgIGxldCBzdGFydCA9IGluZm8uc3RhcnQ7CiAgICBsZXQgZm9jdXNQb2ludCA9IHN0YXJ0ICsgb2Zmc2V0OwogICAgbGV0IG5leHRTdGFydCA9IGZvY3VzUG9pbnQgLSB3aWR0aCAvIDQ7CiAgICBsZXQgbmV4dEVuZCA9IGZvY3VzUG9pbnQgKyB3aWR0aCAvIDQ7CiAgICBpZiAobmV4dFN0YXJ0IDw9IHN0YXJ0KSB7CiAgICAgIG5leHRTdGFydCA9IHN0YXJ0OwogICAgICBuZXh0RW5kID0gc3RhcnQgKyB3aWR0aCAvIDIgLSAxOwogICAgfQogICAgaWYgKG5leHRFbmQgPj0gZW5kKSB7CiAgICAgIG5leHRFbmQgPSBlbmQ7CiAgICAgIG5leHRTdGFydCA9IGVuZCAtIHdpZHRoIC8gMiArIDE7CiAgICB9CiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5nZXREYXRhKG91dHRlckxldmVsICsgMSwgbmV4dFN0YXJ0ICogMiwgbmV4dFN0YXJ0ICogMiArIHdpZHRoIC0gMSk7CiAgICByZXR1cm4gW1tvZmZzZXQsIDIgKiBuZXh0U3RhcnRdLCBkYXRhXTsKICB9CiAgYXN5bmMgZ2V0RGF0YShsZXZlbCwgc3RhcnQsIGVuZCwgbm9SZXQpIHsKICAgIGlmIChsZXZlbCA+IHRoaXMubWF4TGV2ZWwpIHsKICAgICAgcmV0dXJuIFtdOwogICAgfQogICAgbGV0IGxhc3RGdWxsTGV2ZWwgPSAyOwogICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0OwogICAgbGV0IG5leHRFbmQgPSBlbmQ7CiAgICBmb3IgKGxldCBpID0gbGV2ZWwgLSAxOyBpID4gMTsgaS0tKSB7CiAgICAgIG5leHRTdGFydCA9IE1hdGguZmxvb3IobmV4dFN0YXJ0IC8gMik7CiAgICAgIG5leHRFbmQgPSBNYXRoLmZsb29yKG5leHRFbmQgLyAyKTsKICAgICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbaV0gJiYgdGhpcy5sZXZlbEluZGV4T2Jqc1tpXS5pc0Z1bGwpIHsKICAgICAgICBsYXN0RnVsbExldmVsID0gaTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgZm9yIChsZXQgaSA9IGxhc3RGdWxsTGV2ZWwgKyAxOyBpIDw9IGxldmVsOyBpKyspIHsKICAgICAgbmV4dFN0YXJ0ID0gbmV4dFN0YXJ0ICogMjsKICAgICAgbmV4dEVuZCA9IG5leHRFbmQgKiAyICsgMTsKICAgICAgY29uc3QgbG9zZWREYXRhSW5mbyA9IHRoaXMuY2hlY2tMb2FkZWREYXRhSW5TaW5nYWxMZXZlbChbW2ksIG5leHRTdGFydCwgbmV4dEVuZF1dKTsKICAgICAgLy9kZWJ1Z2dlcgogICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbChsb3NlZERhdGFJbmZvLCB0aGlzKTsKICAgIH0KICAgIGlmICh0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXSkgewogICAgICAvL+abtOaWsOe8k+WtmAogICAgICAvLyB0aGlzLnVwZGF0ZURhdGFDYWNoZUZvclJhbmdlKGxldmVsLCBzdGFydCwgZW5kKQogICAgICBpZiAobm9SZXQpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgZGF0YTogW10sCiAgICAgICAgICBzdGFydDogMCwKICAgICAgICAgIGVuZDogMCwKICAgICAgICAgIGw6IDAKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIGlmICh0aGlzLmRhdGFOYW1lID09PSAnc2Vuc29yOCcpIHsKICAgICAgICAgIGNvbnN0IGV4dHJhRGF0YUxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nMigyICoqIHRoaXMubWF4TGV2ZWwgLSB0aGlzLnJlYWxEYXRhUm93TnVtKSk7CiAgICAgICAgICBpZiAobGV2ZWwgPj0gdGhpcy5tYXhMZXZlbCAtIGV4dHJhRGF0YUxldmVsKSB7CiAgICAgICAgICAgIGNvbnN0IGN1ckV4dHJhTGV2ZWwgPSBsZXZlbCAtICh0aGlzLm1heExldmVsIC0gZXh0cmFEYXRhTGV2ZWwpOwogICAgICAgICAgICBjb25zdCBmYWtlUm93TnVtID0gMiAqKiBjdXJFeHRyYUxldmVsOwogICAgICAgICAgICBpZiAoZW5kID49IDIgKiogbGV2ZWwgLSBmYWtlUm93TnVtKSB7CiAgICAgICAgICAgICAgZW5kID0gMiAqKiBsZXZlbCAtIGZha2VSb3dOdW0gLSAxOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gdGhpcy5yZWFsRGF0YVJvd051bSAtIDE7CiAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5tYXhMZXZlbDsgaSA+PSBsZXZlbDsgaS0tKSB7CiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGguZmxvb3IobGFzdEluZGV4IC8gMik7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZW5kIDwgc3RhcnQpIHsKICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdLmdldERhdGFCeUluZGV4KHN0YXJ0LCBlbmQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbEluZGV4T2Jqc1tsZXZlbF0uZ2V0RGF0YUJ5SW5kZXgoc3RhcnQsIGVuZCk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gewogICAgICAgIGRhdGE6IFtdLAogICAgICAgIHN0YXJ0OiAwLAogICAgICAgIGVuZDogMCwKICAgICAgICBsOiAwCiAgICAgIH07CiAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZ2V0IGRhdGEgZnJvbSBkYXRhIG1hbmFnZXIiKTsKICAgIH0KICB9CiAgYXN5bmMgZ2V0RGF0YU1pbk1heE1pc3MobGV2ZWwsIHN0YXJ0LCBlbmQsIG5vUmV0KSB7CiAgICBpZiAobGV2ZWwgPiB0aGlzLm1heExldmVsKSB7CiAgICAgIHJldHVybiBbXTsKICAgIH0KICAgIGxldCBsYXN0RnVsbExldmVsID0gMjsKICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydDsKICAgIGxldCBuZXh0RW5kID0gZW5kOwogICAgZm9yIChsZXQgaSA9IGxldmVsIC0gMTsgaSA+IDE7IGktLSkgewogICAgICBuZXh0U3RhcnQgPSBNYXRoLmZsb29yKG5leHRTdGFydCAvIDIpOwogICAgICBuZXh0RW5kID0gTWF0aC5mbG9vcihuZXh0RW5kIC8gMik7CiAgICAgIGlmICh0aGlzLmxldmVsSW5kZXhPYmpzW2ldICYmIHRoaXMubGV2ZWxJbmRleE9ianNbaV0uaXNGdWxsKSB7CiAgICAgICAgbGFzdEZ1bGxMZXZlbCA9IGk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIGZvciAobGV0IGkgPSBsYXN0RnVsbExldmVsICsgMTsgaSA8PSBsZXZlbDsgaSsrKSB7CiAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCAqIDI7CiAgICAgIG5leHRFbmQgPSBuZXh0RW5kICogMiArIDE7CiAgICAgIGNvbnN0IGxvc2VkRGF0YUluZm8gPSB0aGlzLmNoZWNrTG9hZGVkRGF0YUluU2luZ2FsTGV2ZWwoW1tpLCBuZXh0U3RhcnQsIG5leHRFbmRdXSk7CiAgICAgIGNvbnN0IHByb2Nlc3NMb3NlZERhdGFJbmZvID0gW107CiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9zZWREYXRhSW5mby5sZW5ndGg7IGorKykgewogICAgICAgIGNvbnN0IHRlbXBJbmZvID0gbG9zZWREYXRhSW5mb1tqXTsKICAgICAgICBwcm9jZXNzTG9zZWREYXRhSW5mby5wdXNoKFt0ZW1wSW5mb1swXSAtIDEsIE1hdGguZmxvb3IodGVtcEluZm9bMV0gLyAyKSwgTWF0aC5mbG9vcih0ZW1wSW5mb1syXSAvIDIpXSk7CiAgICAgIH0KICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwyTWluTWF4TWlzcyhwcm9jZXNzTG9zZWREYXRhSW5mbywgdGhpcyk7CiAgICB9CiAgICBpZiAodGhpcy5sZXZlbEluZGV4T2Jqc1tsZXZlbF0pIHsKICAgICAgLy/mm7TmlrDnvJPlrZgKICAgICAgLy8gdGhpcy51cGRhdGVEYXRhQ2FjaGVGb3JSYW5nZShsZXZlbCwgc3RhcnQsIGVuZCkKICAgICAgaWYgKG5vUmV0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRhdGE6IFtdLAogICAgICAgICAgc3RhcnQ6IDAsCiAgICAgICAgICBlbmQ6IDAsCiAgICAgICAgICBsOiAwCiAgICAgICAgfTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5kYXRhTmFtZSA9PT0gJ3NlbnNvcjgnKSB7CiAgICAgICAgICBjb25zdCBleHRyYURhdGFMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIoMiAqKiB0aGlzLm1heExldmVsIC0gdGhpcy5yZWFsRGF0YVJvd051bSkpOwogICAgICAgICAgaWYgKGxldmVsID49IHRoaXMubWF4TGV2ZWwgLSBleHRyYURhdGFMZXZlbCkgewogICAgICAgICAgICBjb25zdCBjdXJFeHRyYUxldmVsID0gbGV2ZWwgLSAodGhpcy5tYXhMZXZlbCAtIGV4dHJhRGF0YUxldmVsKTsKICAgICAgICAgICAgY29uc3QgZmFrZVJvd051bSA9IDIgKiogY3VyRXh0cmFMZXZlbDsKICAgICAgICAgICAgaWYgKGVuZCA+PSAyICoqIGxldmVsIC0gZmFrZVJvd051bSkgewogICAgICAgICAgICAgIGVuZCA9IDIgKiogbGV2ZWwgLSBmYWtlUm93TnVtIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbGV0IGxhc3RJbmRleCA9IHRoaXMucmVhbERhdGFSb3dOdW0gLSAxOwogICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubWF4TGV2ZWw7IGkgPj0gbGV2ZWw7IGktLSkgewogICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLmZsb29yKGxhc3RJbmRleCAvIDIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5nZXREYXRhQnlJbmRleChzdGFydCwgZW5kKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdLmdldERhdGFCeUluZGV4KHN0YXJ0LCBlbmQpOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBkYXRhOiBbXSwKICAgICAgICBzdGFydDogMCwKICAgICAgICBlbmQ6IDAsCiAgICAgICAgbDogMAogICAgICB9OwogICAgICAvL3Rocm93IG5ldyBFcnJvcigiY2Fubm90IGdldCBkYXRhIGZyb20gZGF0YSBtYW5hZ2VyIik7CiAgICB9CiAgfQogIGFzeW5jIGdldERhdGFSYXdNaW5NYXgobGV2ZWwsIHN0YXJ0LCBlbmQsIG5vUmV0KSB7CiAgICBpZiAobGV2ZWwgPiB0aGlzLm1heExldmVsKSB7CiAgICAgIHJldHVybiBbXTsKICAgIH0KICAgIGxldCBsYXN0RnVsbExldmVsID0gMjsKICAgIGxldCBuZXh0U3RhcnQgPSBzdGFydDsKICAgIGxldCBuZXh0RW5kID0gZW5kOwogICAgLy9kZWJ1Z2dlcgogICAgZm9yIChsZXQgaSA9IGxldmVsIC0gMTsgaSA+IDE7IGktLSkgewogICAgICBuZXh0U3RhcnQgPSBNYXRoLmZsb29yKG5leHRTdGFydCAvIDIpOwogICAgICBuZXh0RW5kID0gTWF0aC5mbG9vcihuZXh0RW5kIC8gMik7CiAgICAgIGlmICh0aGlzLmxldmVsSW5kZXhPYmpzW2ldICYmIHRoaXMubGV2ZWxJbmRleE9ianNbaV0uaXNGdWxsKSB7CiAgICAgICAgbGFzdEZ1bGxMZXZlbCA9IGk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIGZvciAobGV0IGkgPSBsYXN0RnVsbExldmVsICsgMTsgaSA8PSBsZXZlbDsgaSsrKSB7CiAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCAqIDI7CiAgICAgIG5leHRFbmQgPSBuZXh0RW5kICogMiArIDE7CiAgICAgIGNvbnN0IGxvc2VkRGF0YUluZm8gPSB0aGlzLmNoZWNrTG9hZGVkRGF0YUluU2luZ2FsTGV2ZWwoW1tpLCBuZXh0U3RhcnQsIG5leHRFbmRdXSk7CiAgICAgIC8vZGVidWdnZXIKICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWxSYXdNaW5NYXgobG9zZWREYXRhSW5mbywgdGhpcyk7CiAgICB9CiAgICBpZiAodGhpcy5sZXZlbEluZGV4T2Jqc1tsZXZlbF0pIHsKICAgICAgLy/mm7TmlrDnvJPlrZgKICAgICAgLy8gdGhpcy51cGRhdGVEYXRhQ2FjaGVGb3JSYW5nZShsZXZlbCwgc3RhcnQsIGVuZCkKICAgICAgaWYgKG5vUmV0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRhdGE6IFtdLAogICAgICAgICAgc3RhcnQ6IDAsCiAgICAgICAgICBlbmQ6IDAsCiAgICAgICAgICBsOiAwCiAgICAgICAgfTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5kYXRhTmFtZSA9PT0gJ3NlbnNvcjgnKSB7CiAgICAgICAgICBjb25zdCBleHRyYURhdGFMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIoMiAqKiB0aGlzLm1heExldmVsIC0gdGhpcy5yZWFsRGF0YVJvd051bSkpOwogICAgICAgICAgaWYgKGxldmVsID49IHRoaXMubWF4TGV2ZWwgLSBleHRyYURhdGFMZXZlbCkgewogICAgICAgICAgICBjb25zdCBjdXJFeHRyYUxldmVsID0gbGV2ZWwgLSAodGhpcy5tYXhMZXZlbCAtIGV4dHJhRGF0YUxldmVsKTsKICAgICAgICAgICAgY29uc3QgZmFrZVJvd051bSA9IDIgKiogY3VyRXh0cmFMZXZlbDsKICAgICAgICAgICAgaWYgKGVuZCA+PSAyICoqIGxldmVsIC0gZmFrZVJvd051bSkgewogICAgICAgICAgICAgIGVuZCA9IDIgKiogbGV2ZWwgLSBmYWtlUm93TnVtIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbGV0IGxhc3RJbmRleCA9IHRoaXMucmVhbERhdGFSb3dOdW0gLSAxOwogICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubWF4TGV2ZWw7IGkgPj0gbGV2ZWw7IGktLSkgewogICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLmZsb29yKGxhc3RJbmRleCAvIDIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5nZXREYXRhQnlJbmRleChzdGFydCwgZW5kKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdLmdldERhdGFCeUluZGV4KHN0YXJ0LCBlbmQpOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBkYXRhOiBbXSwKICAgICAgICBzdGFydDogMCwKICAgICAgICBlbmQ6IDAsCiAgICAgICAgbDogMAogICAgICB9OwogICAgICAvL3Rocm93IG5ldyBFcnJvcigiY2Fubm90IGdldCBkYXRhIGZyb20gZGF0YSBtYW5hZ2VyIik7CiAgICB9CiAgfQogIGFzeW5jIGdldERhdGFWMShsZXZlbCwgc3RhcnQsIGVuZCwgbm9SZXQpIHsKICAgIGlmIChsZXZlbCA+IHRoaXMubWF4TGV2ZWwpIHsKICAgICAgcmV0dXJuIFtdOwogICAgfQogICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdKSB7CiAgICAgIGNvbnN0IGhhc0RhdGEgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5oYXNEYXRhRm9yUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICAgIGlmIChoYXNEYXRhLmhhcykgewogICAgICAgIHJldHVybiB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5nZXREYXRhQnlJbmRleChzdGFydCwgZW5kKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBsb3NlZFJhbmdlID0gaGFzRGF0YS5yYW5nZTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvc2VkUmFuZ2UubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGxldCBsID0gbGV2ZWwgLSAxOwogICAgICAgICAgY29uc3QgbG9zZWREYXRhT3RoZXJMZXZlbCA9IFtdOwogICAgICAgICAgZm9yICg7IGwgPj0gMDsgbC0tKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmxldmVsSW5kZXhPYmpzW2xdLmlzRnVsbCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGxldmVsSGFzRGF0YSA9IHRoaXMubGV2ZWxJbmRleE9ianNbbF0uaGFzRGF0YUZvclJhbmdlKE1hdGguZmxvb3IobG9zZWRSYW5nZVtpXVswXSAvIDIgKiogKGxldmVsIC0gbCkpLCBNYXRoLmZsb29yKGxvc2VkUmFuZ2VbaV1bMV0gLyAyICoqIChsZXZlbCAtIGwpKSk7CiAgICAgICAgICAgIGlmIChsZXZlbEhhc0RhdGEuaGFzKSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbG9zZWREYXRhT3RoZXJMZXZlbC5wdXNoKFtsLCBNYXRoLmZsb29yKGxvc2VkUmFuZ2VbaV1bMF0gLyAyICoqIChsZXZlbCAtIGwpKSwgTWF0aC5mbG9vcihsb3NlZFJhbmdlW2ldWzFdIC8gMiAqKiAobGV2ZWwgLSBsKSldKTsKICAgICAgICAgIH0KICAgICAgICAgIGF3YWl0IGxvYWREYXRhRm9yUmFuZ2VMZXZlbChsb3NlZERhdGFPdGhlckxldmVsLCB0aGlzKTsKICAgICAgICB9CiAgICAgICAgbG9zZWRSYW5nZS5mb3JFYWNoKHJhbmdlID0+IHsKICAgICAgICAgIHJhbmdlLnVuc2hpZnQobGV2ZWwpOwogICAgICAgIH0pOwogICAgICAgIGF3YWl0IGxvYWREYXRhRm9yUmFuZ2VMZXZlbChsb3NlZFJhbmdlLCB0aGlzKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgbGV0IGwgPSBsZXZlbCAtIDE7CiAgICAgIGNvbnN0IGxvc2VkRGF0YU90aGVyTGV2ZWwgPSBbXTsKICAgICAgZm9yICg7IGwgPj0gMDsgbC0tKSB7CiAgICAgICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbF0gJiYgdGhpcy5sZXZlbEluZGV4T2Jqc1tsXS5pc0Z1bGwpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5sZXZlbEluZGV4T2Jqc1tsXSkgewogICAgICAgICAgY29uc3QgbGV2ZWxIYXNEYXRhID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tsXS5oYXNEYXRhRm9yUmFuZ2UoTWF0aC5mbG9vcihzdGFydCAvIDIgKiogKGxldmVsIC0gbCkpLCBNYXRoLmZsb29yKGVuZCAvIDIgKiogKGxldmVsIC0gbCkpKTsKICAgICAgICAgIGlmIChsZXZlbEhhc0RhdGEuaGFzKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBsb3NlZERhdGFPdGhlckxldmVsLnB1c2goW2wsIE1hdGguZmxvb3Ioc3RhcnQgLyAyICoqIChsZXZlbCAtIGwpKSwgTWF0aC5mbG9vcihlbmQgLyAyICoqIChsZXZlbCAtIGwpKV0pOwogICAgICB9CiAgICAgIGxvc2VkRGF0YU90aGVyTGV2ZWwudW5zaGlmdChbbGV2ZWwsIHN0YXJ0LCBlbmRdKTsKICAgICAgYXdhaXQgbG9hZERhdGFGb3JSYW5nZUxldmVsKGxvc2VkRGF0YU90aGVyTGV2ZWwsIHRoaXMpOwogICAgfQogICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdKSB7CiAgICAgIGlmIChub1JldCkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5kYXRhTmFtZSA9PT0gJ3NlbnNvcjgnKSB7CiAgICAgICAgICBjb25zdCBleHRyYURhdGFMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIoMiAqKiB0aGlzLm1heExldmVsIC0gdGhpcy5yZWFsRGF0YVJvd051bSkpOwogICAgICAgICAgaWYgKGxldmVsID49IHRoaXMubWF4TGV2ZWwgLSBleHRyYURhdGFMZXZlbCkgewogICAgICAgICAgICBjb25zdCBjdXJFeHRyYUxldmVsID0gbGV2ZWwgLSAodGhpcy5tYXhMZXZlbCAtIGV4dHJhRGF0YUxldmVsKTsKICAgICAgICAgICAgY29uc3QgZmFrZVJvd051bSA9IDIgKiogY3VyRXh0cmFMZXZlbDsKICAgICAgICAgICAgaWYgKGVuZCA+PSAyICoqIGxldmVsIC0gZmFrZVJvd051bSkgewogICAgICAgICAgICAgIGVuZCA9IDIgKiogbGV2ZWwgLSBmYWtlUm93TnVtIC0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbGV0IGxhc3RJbmRleCA9IHRoaXMucmVhbERhdGFSb3dOdW0gLSAxOwogICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubWF4TGV2ZWw7IGkgPj0gbGV2ZWw7IGktLSkgewogICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLmZsb29yKGxhc3RJbmRleCAvIDIpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5nZXREYXRhQnlJbmRleChzdGFydCwgZW5kKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdLmdldERhdGFCeUluZGV4KHN0YXJ0LCBlbmQpOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZ2V0IGRhdGEgZnJvbSBkYXRhIG1hbmFnZXIiKTsKICAgIH0KICB9CiAgZ2V0TG9hZGVkRGF0YShsZXZlbCwgc3RhcnQsIGVuZCkgewogICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdKSB7CiAgICAgIGlmICh0aGlzLmRhdGFOYW1lID09PSAnc2Vuc29yOCcpIHsKICAgICAgICBjb25zdCBleHRyYURhdGFMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIoMiAqKiB0aGlzLm1heExldmVsIC0gdGhpcy5yZWFsRGF0YVJvd051bSkpOwogICAgICAgIGlmIChsZXZlbCA+PSB0aGlzLm1heExldmVsIC0gZXh0cmFEYXRhTGV2ZWwpIHsKICAgICAgICAgIGNvbnN0IGN1ckV4dHJhTGV2ZWwgPSBsZXZlbCAtICh0aGlzLm1heExldmVsIC0gZXh0cmFEYXRhTGV2ZWwpOwogICAgICAgICAgY29uc3QgZmFrZVJvd051bSA9IDIgKiogY3VyRXh0cmFMZXZlbDsKICAgICAgICAgIGlmIChlbmQgPj0gMiAqKiBsZXZlbCAtIGZha2VSb3dOdW0pIHsKICAgICAgICAgICAgZW5kID0gMiAqKiBsZXZlbCAtIGZha2VSb3dOdW0gLSAxOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoZW5kIDwgc3RhcnQpIHsKICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdLmdldERhdGFCeUluZGV4KHN0YXJ0LCBlbmQpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5nZXREYXRhQnlJbmRleChzdGFydCwgZW5kKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZ2V0IGRhdGEgZnJvbSBkYXRhIG1hbmFnZXIiKTsKICAgIH0KICB9CiAgY2hlY2tNb25vdG9uaWNpdHkobm9uVW5pZm9ybUNvbE9ianMsIHByZUluZGV4QXJyYXksIG5lZWRMb2FkRGlmTm9kZXMpIHsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZExvYWREaWZOb2Rlcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBmaXJzdCA9IG5lZWRMb2FkRGlmTm9kZXNbaV0ueUFycmF5WzBdOwogICAgICBjb25zdCBtaW5WID0gbmVlZExvYWREaWZOb2Rlc1tpXS55QXJyYXlbMV07CiAgICAgIGNvbnN0IG1heFYgPSBuZWVkTG9hZERpZk5vZGVzW2ldLnlBcnJheVsyXTsKICAgICAgY29uc3QgbGFzdCA9IG5lZWRMb2FkRGlmTm9kZXNbaV0ueUFycmF5WzNdOwogICAgICBjb25zdCBwTCA9IG5lZWRMb2FkRGlmTm9kZXNbaV0ubGV2ZWw7CiAgICAgIGNvbnN0IHBUUmFuZ2UgPSAyICoqIHRoaXMubWF4TGV2ZWwgLyAyICoqIHBMOwogICAgICBjb25zdCBwVGltZVMgPSBuZWVkTG9hZERpZk5vZGVzW2ldLmluZGV4ICogcFRSYW5nZTsKICAgICAgY29uc3QgcFRpbWVFID0gcFRSYW5nZSArIHBUaW1lUyAtIDE7CiAgICAgIGlmIChmaXJzdCA9PT0gbWluViAmJiBsYXN0ID09PSBtYXhWIHx8IGZpcnN0ID09PSBtYXhWICYmIGxhc3QgPT09IG1pblYpIHsKICAgICAgICBjb25zdCBrID0gKGxhc3QgLSBmaXJzdCkgLyAocFRpbWVFIC0gcFRpbWVTKTsKICAgICAgICBjb25zdCBiID0gZmlyc3QgLSBrICogcFRpbWVTOwogICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUluZGV4QXJyYXlbaV1dLm1lcmdlTGFzdChrLCBiKTsKICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVJbmRleEFycmF5W2ldICsgMV0ubWVyZ2VGaXJzdChrLCBiKTsKICAgICAgICBwcmVJbmRleEFycmF5LnNwbGljZShpLCAxKTsKICAgICAgICBuZWVkTG9hZERpZk5vZGVzLnNwbGljZShpLCAxKTsKICAgICAgfQogICAgfQogIH0KICBjb25zdHJ1Y3RUcmVlRm9yQmF0Y2hMb2FkMShsb3NlZFJhbmdlLCBkaWZWYWxzKSB7CiAgICBsZXQgY291bnQgPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb3NlZFJhbmdlLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IGxldmVsUmFuZ2UgPSBsb3NlZFJhbmdlW2ldOwogICAgICBjb25zdCBzdGFydE5vZGUgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2xvc2VkUmFuZ2VbaV1bMF1dLmdldFRyZWVOb2RlU3RhcnRJbmRleChsb3NlZFJhbmdlW2ldWzFdKTsKICAgICAgbGV0IHAgPSBzdGFydE5vZGU7CiAgICAgIGNvbnN0IG5ld1RyZWVOb2RlID0gW107CiAgICAgIGZvciAobGV0IGogPSBsb3NlZFJhbmdlW2ldWzFdOyBqIDw9IGxvc2VkUmFuZ2VbaV1bMl07IGorKykgewogICAgICAgIHZhciBfcDsKICAgICAgICBpZiAoKChfcCA9IHApID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC5pbmRleCkgPT09IGogJiYgaiA9PT0gZGlmVmFsc1tjb3VudF0uaSAmJiBwLmxldmVsID09PSBkaWZWYWxzW2NvdW50XS5sKSB7CiAgICAgICAgICAvL0B0cy1pZ25vcmUKICAgICAgICAgIHAuZGlmZmVyZW5jZSA9IGRpZlZhbHNbY291bnRdLmRpZjsKICAgICAgICAgIC8vIGNvbnN0IHlBcnJheTE6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIDBdCiAgICAgICAgICAvLyBjb25zdCB5QXJyYXkyOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCAwXQogICAgICAgICAgLy8geUFycmF5MVswXSA9IHAueUFycmF5WzBdOwogICAgICAgICAgLy8geUFycmF5MlswXSA9IHAueUFycmF5WzBdIC0gcC5kaWZmZXJlbmNlIVswXTsKICAgICAgICAgIC8vIHlBcnJheTFbM10gPSBwLnlBcnJheVszXSArIHAuZGlmZmVyZW5jZSFbM107CiAgICAgICAgICAvLyB5QXJyYXkyWzNdID0gcC55QXJyYXlbM107CiAgICAgICAgICAvLyBpZiAocC5kaWZmZXJlbmNlIVsxXSA8IDApIHsKICAgICAgICAgIC8vICAgICB5QXJyYXkxWzFdID0gcC55QXJyYXlbMV07CiAgICAgICAgICAvLyAgICAgeUFycmF5MlsxXSA9IHAueUFycmF5WzFdIC0gcC5kaWZmZXJlbmNlIVsxXTsKICAgICAgICAgIC8vIH0gZWxzZSB7CiAgICAgICAgICAvLyAgICAgeUFycmF5MVsxXSA9IHAueUFycmF5WzFdICsgcC5kaWZmZXJlbmNlIVsxXTsKICAgICAgICAgIC8vICAgICB5QXJyYXkyWzFdID0gcC55QXJyYXlbMV0KICAgICAgICAgIC8vIH0KICAgICAgICAgIC8vIGlmIChwLmRpZmZlcmVuY2UhWzJdIDwgMCkgewogICAgICAgICAgLy8gICAgIHlBcnJheTFbMl0gPSBwLnlBcnJheVsyXSArIHAuZGlmZmVyZW5jZSFbMl07CiAgICAgICAgICAvLyAgICAgeUFycmF5MlsyXSA9IHAueUFycmF5WzJdOwogICAgICAgICAgLy8gfSBlbHNlIHsKICAgICAgICAgIC8vICAgICB5QXJyYXkxWzJdID0gcC55QXJyYXlbMl07CiAgICAgICAgICAvLyAgICAgeUFycmF5MlsyXSA9IHAueUFycmF5WzJdIC0gcC5kaWZmZXJlbmNlIVsyXTsKICAgICAgICAgIC8vIH0KICAgICAgICAgIGNvbnN0IHlBcnJheTEgPSBbMCwgMCwgMCwgMCwgMF07CiAgICAgICAgICBjb25zdCB5QXJyYXkyID0gWzAsIDAsIDAsIDAsIDBdOwogICAgICAgICAgeUFycmF5MVswXSA9IHAueUFycmF5WzBdOwogICAgICAgICAgeUFycmF5MlswXSA9IHAueUFycmF5WzBdIC0gcC5kaWZmZXJlbmNlWzBdOwogICAgICAgICAgLy8geUFycmF5MVszXSA9IHAueUFycmF5WzNdICsgcC5kaWZmZXJlbmNlIVszXTsKICAgICAgICAgIC8vIHlBcnJheTJbM10gPSBwLnlBcnJheVszXTsKICAgICAgICAgIHlBcnJheTFbNF0gPSBwLnlBcnJheVs0XSArIHAuZGlmZmVyZW5jZVs0XTsKICAgICAgICAgIHlBcnJheTJbNF0gPSBwLnlBcnJheVs0XTsKICAgICAgICAgIGlmIChwLmRpZmZlcmVuY2VbMV0gPCAwKSB7CiAgICAgICAgICAgIHlBcnJheTFbMV0gPSBwLnlBcnJheVsxXTsKICAgICAgICAgICAgeUFycmF5MlsxXSA9IHAueUFycmF5WzFdIC0gcC5kaWZmZXJlbmNlWzFdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgeUFycmF5MVsxXSA9IHAueUFycmF5WzFdICsgcC5kaWZmZXJlbmNlWzFdOwogICAgICAgICAgICB5QXJyYXkyWzFdID0gcC55QXJyYXlbMV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocC5kaWZmZXJlbmNlWzJdIDwgMCkgewogICAgICAgICAgICB5QXJyYXkxWzJdID0gcC55QXJyYXlbMl0gKyBwLmRpZmZlcmVuY2VbMl07CiAgICAgICAgICAgIHlBcnJheTJbMl0gPSBwLnlBcnJheVsyXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHlBcnJheTFbMl0gPSBwLnlBcnJheVsyXTsKICAgICAgICAgICAgeUFycmF5MlsyXSA9IHAueUFycmF5WzJdIC0gcC5kaWZmZXJlbmNlWzJdOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHAuZGlmZmVyZW5jZVszXSA8PSAwIHx8IHAuZGlmZmVyZW5jZVszXSA+PSAwKSB7CiAgICAgICAgICAgIHlBcnJheTFbM10gPSAocC55QXJyYXlbM10gKiAyICsgcC5kaWZmZXJlbmNlWzNdKSAvIDI7CiAgICAgICAgICAgIHlBcnJheTJbM10gPSAocC55QXJyYXlbM10gKiAyIC0gcC5kaWZmZXJlbmNlWzNdKSAvIDI7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBuZXcgVHJlbmRUcmVlKHAsIHRydWUsIHAuaW5kZXgsIHlBcnJheTEsIG51bGwpOwogICAgICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUocCwgZmFsc2UsIHAuaW5kZXgsIHlBcnJheTIsIG51bGwpOwogICAgICAgICAgbmV3VHJlZU5vZGUucHVzaChmaXJzdE5vZGUpOwogICAgICAgICAgbmV3VHJlZU5vZGUucHVzaChzZWNvbmROb2RlKTsKICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgY291bnQrKzsKICAgICAgICAgIGlmIChwID09PSBudWxsIHx8IGNvdW50ID49IGRpZlZhbHMubGVuZ3RoKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgX3AyOwogICAgICAgICAgY29uc29sZS5sb2cobG9zZWRSYW5nZVtpXVswXSwgbG9zZWRSYW5nZVtpXVsxXSk7CiAgICAgICAgICBjb25zb2xlLmxvZygibG9zZSByYW5nZToiLCBsb3NlZFJhbmdlLCBwLCAoX3AyID0gcCkgPT09IG51bGwgfHwgX3AyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcDIuaW5kZXgsIGopOwogICAgICAgICAgY29uc29sZS5sb2codGhpcy5sZXZlbEluZGV4T2Jqcyk7CiAgICAgICAgICBkZWJ1Z2dlcjsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiZGlmIG5vdCBtYXRjaCBub2RlIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3VHJlZU5vZGUubGVuZ3RoIC0gMTsgaisrKSB7CiAgICAgICAgbmV3VHJlZU5vZGVbal0ubmV4dFNpYmxpbmcgPSBuZXdUcmVlTm9kZVtqICsgMV07CiAgICAgICAgbmV3VHJlZU5vZGVbaiArIDFdLnByZXZpb3VzU2libGluZyA9IG5ld1RyZWVOb2RlW2pdOwogICAgICAgIGlmIChuZXdUcmVlTm9kZVtqXS5pbmRleCAhPSBuZXdUcmVlTm9kZVtqICsgMV0uaW5kZXggLSAxKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInNpYmxpbmcgaW5kZXggZXJyb3IiKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbG9zZWRSYW5nZVtpXVswXSArIDFdKSB7CiAgICAgICAgdGhpcy5sZXZlbEluZGV4T2Jqc1tsb3NlZFJhbmdlW2ldWzBdICsgMV0uYWRkTG9hZGVkRGF0YVJhbmdlKG5ld1RyZWVOb2RlWzBdLCBbbmV3VHJlZU5vZGVbMF0uaW5kZXgsIG5ld1RyZWVOb2RlW25ld1RyZWVOb2RlLmxlbmd0aCAtIDFdLmluZGV4XSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5sZXZlbEluZGV4T2Jqc1tsb3NlZFJhbmdlW2ldWzBdICsgMV0gPSBuZXcgTGV2ZWxJbmRleE9iaihsb3NlZFJhbmdlW2ldWzBdICsgMSwgZmFsc2UpOwogICAgICAgIHRoaXMubGV2ZWxJbmRleE9ianNbbG9zZWRSYW5nZVtpXVswXSArIDFdLmFkZExvYWRlZERhdGFSYW5nZShuZXdUcmVlTm9kZVswXSwgW25ld1RyZWVOb2RlWzBdLmluZGV4LCBuZXdUcmVlTm9kZVtuZXdUcmVlTm9kZS5sZW5ndGggLSAxXS5pbmRleF0pOwogICAgICB9CiAgICB9CiAgfQogIGNvbnN0cnVjdFRyZWVGb3JCYXRjaExvYWQobG9zZWRSYW5nZSwgZGlmVmFscykgewogICAgbGV0IGNvdW50ID0gMDsKICAgIGxldCBub2RlTnVtID0gMDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9zZWRSYW5nZS5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBsZXZlbFJhbmdlID0gbG9zZWRSYW5nZVtpXTsKICAgICAgY29uc3Qgc3RhcnROb2RlID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tsb3NlZFJhbmdlW2ldWzBdIC0gMV0uZ2V0VHJlZU5vZGVTdGFydEluZGV4KE1hdGguZmxvb3IobG9zZWRSYW5nZVtpXVsxXSAvIDIpKTsKICAgICAgbGV0IHAgPSBzdGFydE5vZGU7CiAgICAgIGNvbnN0IG5ld1RyZWVOb2RlID0gW107CiAgICAgIGZvciAobGV0IGogPSBNYXRoLmZsb29yKGxvc2VkUmFuZ2VbaV1bMV0gLyAyKTsgaiA8PSBNYXRoLmZsb29yKGxvc2VkUmFuZ2VbaV1bMl0gLyAyKTsgaisrKSB7CiAgICAgICAgdmFyIF9wMzsKICAgICAgICBpZiAoKChfcDMgPSBwKSA9PT0gbnVsbCB8fCBfcDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wMy5pbmRleCkgPT09IGogJiYgaiA9PT0gZGlmVmFsc1tjb3VudF0uaSAmJiBwLmxldmVsID09PSBkaWZWYWxzW2NvdW50XS5sKSB7CiAgICAgICAgICAvL0B0cy1pZ25vcmUKICAgICAgICAgIHAuZGlmZmVyZW5jZSA9IGRpZlZhbHNbY291bnRdLmRpZjsKICAgICAgICAgIC8vIGNvbnN0IHlBcnJheTE6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIDBdCiAgICAgICAgICAvLyBjb25zdCB5QXJyYXkyOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCAwXQogICAgICAgICAgLy8geUFycmF5MVswXSA9IHAueUFycmF5WzBdOwogICAgICAgICAgLy8geUFycmF5MlswXSA9IHAueUFycmF5WzBdIC0gcC5kaWZmZXJlbmNlIVswXTsKICAgICAgICAgIC8vIHlBcnJheTFbM10gPSBwLnlBcnJheVszXSArIHAuZGlmZmVyZW5jZSFbM107CiAgICAgICAgICAvLyB5QXJyYXkyWzNdID0gcC55QXJyYXlbM107CiAgICAgICAgICAvLyBpZiAocC5kaWZmZXJlbmNlIVsxXSA8IDApIHsKICAgICAgICAgIC8vICAgICB5QXJyYXkxWzFdID0gcC55QXJyYXlbMV07CiAgICAgICAgICAvLyAgICAgeUFycmF5MlsxXSA9IHAueUFycmF5WzFdIC0gcC5kaWZmZXJlbmNlIVsxXTsKICAgICAgICAgIC8vIH0gZWxzZSB7CiAgICAgICAgICAvLyAgICAgeUFycmF5MVsxXSA9IHAueUFycmF5WzFdICsgcC5kaWZmZXJlbmNlIVsxXTsKICAgICAgICAgIC8vICAgICB5QXJyYXkyWzFdID0gcC55QXJyYXlbMV0KICAgICAgICAgIC8vIH0KICAgICAgICAgIC8vIGlmIChwLmRpZmZlcmVuY2UhWzJdIDwgMCkgewogICAgICAgICAgLy8gICAgIHlBcnJheTFbMl0gPSBwLnlBcnJheVsyXSArIHAuZGlmZmVyZW5jZSFbMl07CiAgICAgICAgICAvLyAgICAgeUFycmF5MlsyXSA9IHAueUFycmF5WzJdOwogICAgICAgICAgLy8gfSBlbHNlIHsKICAgICAgICAgIC8vICAgICB5QXJyYXkxWzJdID0gcC55QXJyYXlbMl07CiAgICAgICAgICAvLyAgICAgeUFycmF5MlsyXSA9IHAueUFycmF5WzJdIC0gcC5kaWZmZXJlbmNlIVsyXTsKICAgICAgICAgIC8vIH0KICAgICAgICAgIGNvbnN0IHlBcnJheTEgPSBbMCwgMCwgMCwgMCwgMF07CiAgICAgICAgICBjb25zdCB5QXJyYXkyID0gWzAsIDAsIDAsIDAsIDBdOwogICAgICAgICAgeUFycmF5MVswXSA9IHAueUFycmF5WzBdOwogICAgICAgICAgeUFycmF5MlswXSA9IHAueUFycmF5WzBdIC0gcC5kaWZmZXJlbmNlWzBdOwogICAgICAgICAgLy8geUFycmF5MVszXSA9IHAueUFycmF5WzNdICsgcC5kaWZmZXJlbmNlIVszXTsKICAgICAgICAgIC8vIHlBcnJheTJbM10gPSBwLnlBcnJheVszXTsKICAgICAgICAgIHlBcnJheTFbNF0gPSBwLnlBcnJheVs0XSArIHAuZGlmZmVyZW5jZVs0XTsKICAgICAgICAgIHlBcnJheTJbNF0gPSBwLnlBcnJheVs0XTsKICAgICAgICAgIGlmIChwLmRpZmZlcmVuY2VbMV0gPCAwKSB7CiAgICAgICAgICAgIHlBcnJheTFbMV0gPSBwLnlBcnJheVsxXTsKICAgICAgICAgICAgeUFycmF5MlsxXSA9IHAueUFycmF5WzFdIC0gcC5kaWZmZXJlbmNlWzFdOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgeUFycmF5MVsxXSA9IHAueUFycmF5WzFdICsgcC5kaWZmZXJlbmNlWzFdOwogICAgICAgICAgICB5QXJyYXkyWzFdID0gcC55QXJyYXlbMV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocC5kaWZmZXJlbmNlWzJdIDwgMCkgewogICAgICAgICAgICB5QXJyYXkxWzJdID0gcC55QXJyYXlbMl0gKyBwLmRpZmZlcmVuY2VbMl07CiAgICAgICAgICAgIHlBcnJheTJbMl0gPSBwLnlBcnJheVsyXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHlBcnJheTFbMl0gPSBwLnlBcnJheVsyXTsKICAgICAgICAgICAgeUFycmF5MlsyXSA9IHAueUFycmF5WzJdIC0gcC5kaWZmZXJlbmNlWzJdOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHAuZGlmZmVyZW5jZVszXSA8PSAwIHx8IHAuZGlmZmVyZW5jZVszXSA+PSAwKSB7CiAgICAgICAgICAgIHlBcnJheTFbM10gPSAocC55QXJyYXlbM10gKiAyICsgcC5kaWZmZXJlbmNlWzNdKSAvIDI7CiAgICAgICAgICAgIHlBcnJheTJbM10gPSAocC55QXJyYXlbM10gKiAyIC0gcC5kaWZmZXJlbmNlWzNdKSAvIDI7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBuZXcgVHJlbmRUcmVlKHAsIHRydWUsIHAuaW5kZXgsIHlBcnJheTEsIG51bGwpOwogICAgICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUocCwgZmFsc2UsIHAuaW5kZXgsIHlBcnJheTIsIG51bGwpOwogICAgICAgICAgdGhpcy5jYWNoZU1hcC5zZXQoZmlyc3ROb2RlLmluZGV4LCBmaXJzdE5vZGUpOwogICAgICAgICAgdGhpcy5jYWNoZU1hcC5zZXQoc2Vjb25kTm9kZS5pbmRleCwgc2Vjb25kTm9kZSk7CiAgICAgICAgICBub2RlTnVtICs9IDI7CiAgICAgICAgICBuZXdUcmVlTm9kZS5wdXNoKGZpcnN0Tm9kZSk7CiAgICAgICAgICBuZXdUcmVlTm9kZS5wdXNoKHNlY29uZE5vZGUpOwogICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICBjb3VudCsrOwogICAgICAgICAgaWYgKHAgPT09IG51bGwgfHwgY291bnQgPj0gZGlmVmFscy5sZW5ndGgpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBfcDQ7CiAgICAgICAgICBjb25zb2xlLmxvZyhsb3NlZFJhbmdlW2ldWzBdIC0gMSwgTWF0aC5mbG9vcihsb3NlZFJhbmdlW2ldWzFdIC8gMikpOwogICAgICAgICAgY29uc29sZS5sb2coImxvc2UgcmFuZ2U6IiwgbG9zZWRSYW5nZSwgcCwgKF9wNCA9IHApID09PSBudWxsIHx8IF9wNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3A0LmluZGV4LCBqKTsKICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMubGV2ZWxJbmRleE9ianMpOwogICAgICAgICAgZGVidWdnZXI7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImRpZiBub3QgbWF0Y2ggbm9kZSIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5ld1RyZWVOb2RlLmxlbmd0aCAtIDE7IGorKykgewogICAgICAgIG5ld1RyZWVOb2RlW2pdLm5leHRTaWJsaW5nID0gbmV3VHJlZU5vZGVbaiArIDFdOwogICAgICAgIG5ld1RyZWVOb2RlW2ogKyAxXS5wcmV2aW91c1NpYmxpbmcgPSBuZXdUcmVlTm9kZVtqXTsKICAgICAgICBpZiAobmV3VHJlZU5vZGVbal0uaW5kZXggIT0gbmV3VHJlZU5vZGVbaiArIDFdLmluZGV4IC0gMSkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJzaWJsaW5nIGluZGV4IGVycm9yIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmICh0aGlzLmxldmVsSW5kZXhPYmpzW2xvc2VkUmFuZ2VbaV1bMF1dKSB7CiAgICAgICAgdGhpcy5sZXZlbEluZGV4T2Jqc1tsb3NlZFJhbmdlW2ldWzBdXS5hZGRMb2FkZWREYXRhUmFuZ2UobmV3VHJlZU5vZGVbMF0sIFtuZXdUcmVlTm9kZVswXS5pbmRleCwgbmV3VHJlZU5vZGVbbmV3VHJlZU5vZGUubGVuZ3RoIC0gMV0uaW5kZXhdKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmxldmVsSW5kZXhPYmpzW2xvc2VkUmFuZ2VbaV1bMF1dID0gbmV3IExldmVsSW5kZXhPYmoobG9zZWRSYW5nZVtpXVswXSwgZmFsc2UpOwogICAgICAgIHRoaXMubGV2ZWxJbmRleE9ianNbbG9zZWRSYW5nZVtpXVswXV0uYWRkTG9hZGVkRGF0YVJhbmdlKG5ld1RyZWVOb2RlWzBdLCBbbmV3VHJlZU5vZGVbMF0uaW5kZXgsIG5ld1RyZWVOb2RlW25ld1RyZWVOb2RlLmxlbmd0aCAtIDFdLmluZGV4XSk7CiAgICAgIH0KICAgIH0KICB9CiAgYXN5bmMgdmlld0NoYW5nZUludGVyYWN0aW9uKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgeVNjYWxlKSB7CiAgICAvLyBjb25zb2xlLnRpbWUoInZfYyIpCiAgICBjb25zdCBub25Vbmlmb3JtQ29sT2JqcyA9IGNvbXB1dGVUaW1lU0UoY3VycmVudExldmVsLCB3aWR0aCwgdGltZVJhbmdlLCB0aGlzLnJlYWxEYXRhUm93TnVtLCB0aGlzLm1heExldmVsLCB0aGlzLmRhdGFOYW1lKTsKICAgIC8vZHJhd1ZpZXdDaGFuZ2VMaW5lQ2hhcnQoeyBkYXRhTWFuYWdlcjp0aGlzLGRhdGE6IHttYXh2OjAsbWludjowLHBvd1JlbmRlckRhdGE6W10sbm9Qb3dSZW5kZXJEYXRhOltdfSwgc3RhcnRUaW1lOiAwLCBlbmRUaW1lOiB0aW1lUmFuZ2VbMV0sIGFsZ29yaXRobTogInRyZW5kdHJlZSIsIHdpZHRoOndpZHRoLCBoZWlnaHQ6IDYwMCB9KQogICAgLy9jb250ZXh0IS5jb21taXQoImFkZFZpZXdDaGFuZ2VRdWVyeU5vUG93TGluZUNoYXJ0T2JqIiwgeyBkYXRhTWFuYWdlcjp0aGlzLGRhdGE6IG5vblVuaWZvcm1Db2xPYmpzLCBzdGFydFRpbWU6IDAsIGVuZFRpbWU6IHRpbWVSYW5nZVsxXSwgYWxnb3JpdGhtOiAidHJlbmR0cmVlIiwgd2lkdGg6d2lkdGgsIGhlaWdodDogNjAwIH0pOwogICAgbGV0IG5lZWRMb2FkRGlmTm9kZSA9IFtdOwogICAgbGV0IGNvbEluZGV4ID0gMDsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZXZlbEluZGV4T2Jqc1tjdXJyZW50TGV2ZWxdLmZpcnN0Tm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgZmlydEluZGV4VGltZVJhbmdlID0gdGhpcy5nZXRJbmRleFRpbWUoY3VycmVudExldmVsLCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0ubG9hZGVkRGF0YVJhbmdlW2ldWzBdLCB0aGlzLm1heExldmVsKTsKICAgICAgY29uc3QgbGFzdEluZGV4VGltZVJhbmdlID0gdGhpcy5nZXRJbmRleFRpbWUoY3VycmVudExldmVsLCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0ubG9hZGVkRGF0YVJhbmdlW2ldWzFdLCB0aGlzLm1heExldmVsKTsKICAgICAgbGV0IHAgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlc1tpXTsKICAgICAgaWYgKGZpcnRJbmRleFRpbWVSYW5nZS5zdGFydFQgPD0gdGltZVJhbmdlWzBdICYmIGxhc3RJbmRleFRpbWVSYW5nZS5lbmRUID49IHRpbWVSYW5nZVsxXSkgewogICAgICAgIHdoaWxlIChwICE9IG51bGwpIHsKICAgICAgICAgIGlmIChjb2xJbmRleCA+PSBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJjb2wgaW5kZXggb3V0IHJhbmdlIik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCB0eXBlID0gbm9uVW5pZm9ybUNvbE9ianNbY29sSW5kZXhdLmlzQ29udGFpbihwKTsKICAgICAgICAgIGlmICh0eXBlID09PSAxKSB7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAyKSB7CiAgICAgICAgICAgIG5lZWRMb2FkRGlmTm9kZS5wdXNoKHApOwogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgICBjb2xJbmRleCsrOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7CiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJlcnJvciBpbiB2aWV3Y2hhbmdlIikKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoIm5vZGUgdGltZSBpcyBsaXR0bGUgdGhhbiBjb2wiKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8vY29uc3QgZHJhdz1kcmF3Vmlld0NoYW5nZUxpbmVDaGFydCh7d2lkdGg6NjAwLGhlaWdodDo2MDAsbWludjowLG1heHY6MTAwMCx4OjEwLHk6MTB9KQogICAgLy9kcmF3KG5vblVuaWZvcm1Db2xPYmpzKQogICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPT09IDApIHsKICAgICAgLy9kZWJ1Z2dlcgogICAgICByZXR1cm4gbm9uVW5pZm9ybUNvbE9ianM7CiAgICB9CiAgICBsZXQgbG9zZWREYXRhSW5mbyA9IGNvbXB1dGVMb3NlZERhdGFSYW5nZShuZWVkTG9hZERpZk5vZGUpOwogICAgaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBub25Vbmlmb3JtQ29sT2JqczsKICAgIH0KICAgIGNvbnN0IGN1cnJlbnRMZXZlbExvc2VkUmFuZ2UgPSBbXTsKICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9zZWREYXRhSW5mby5sZW5ndGg7IGorKykgewogICAgICBjb25zdCBsZXZlbCA9IGxvc2VkRGF0YUluZm9bal1bMF07CiAgICAgIGNvbnN0IHN0YXJ0ID0gbG9zZWREYXRhSW5mb1tqXVsxXTsKICAgICAgY29uc3QgZW5kID0gbG9zZWREYXRhSW5mb1tqXVsyXTsKICAgICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdKSB7CiAgICAgICAgY29uc3QgaGFzRGF0YSA9IHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdLmhhc0RhdGFGb3JSYW5nZShzdGFydCwgZW5kKTsKICAgICAgICBpZiAoIWhhc0RhdGEuaGFzKSB7CiAgICAgICAgICBjb25zdCBsb3NlZFJhbmdlID0gaGFzRGF0YS5yYW5nZTsKICAgICAgICAgIGxvc2VkUmFuZ2UuZm9yRWFjaChyYW5nZSA9PiB7CiAgICAgICAgICAgIHJhbmdlLnVuc2hpZnQobGV2ZWwpOwogICAgICAgICAgICBjdXJyZW50TGV2ZWxMb3NlZFJhbmdlLnB1c2gocmFuZ2UpOwogICAgICAgICAgfSk7CiAgICAgICAgICAvL2RlYnVnZ2VyCiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGN1cnJlbnRMZXZlbExvc2VkUmFuZ2UucHVzaChbbGV2ZWwsIHN0YXJ0LCBlbmRdKTsKICAgICAgfQogICAgfQogICAgaWYgKGN1cnJlbnRMZXZlbExvc2VkUmFuZ2UubGVuZ3RoID4gMCkgewogICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbChjdXJyZW50TGV2ZWxMb3NlZFJhbmdlLCB0aGlzKTsKICAgIH0KICAgIGxldCBjb3VudE51bSA9IDE7CiAgICB3aGlsZSAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA+IDApIHsKICAgICAgY29sSW5kZXggPSAwOwogICAgICBjb25zdCB0ZW1wTmVlZExvYWREaWZOb2RlcyA9IFtdOwogICAgICBjb25zdCB0ZW1wUXVlID0gW107CiAgICAgIG5lZWRMb2FkRGlmTm9kZS5mb3JFYWNoKHYgPT4gewogICAgICAgIGlmICh2Ll9sZWZ0Q2hpbGQgPT09IG51bGwgfHwgdi5fcmlnaHRDaGlsZCA9PT0gbnVsbCkgewogICAgICAgICAgZGVidWdnZXI7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBmaW5kIG5leHQgbGV2ZWwgbm9kZSIpOwogICAgICAgIH0KICAgICAgICB0ZW1wUXVlLnB1c2godi5fbGVmdENoaWxkKTsKICAgICAgICB0ZW1wUXVlLnB1c2godi5fcmlnaHRDaGlsZCk7CiAgICAgIH0pOwogICAgICBjb25zdCBwcmVDb2xJbmRleCA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBRdWUubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAoY29sSW5kZXggPj0gbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAvL2JyZWFrOwogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjb2wgaW5kZXggb3V0IHJhbmdlIik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNDb250YWluKHRlbXBRdWVbaV0pOwogICAgICAgIGlmICh0eXBlID09PSAxKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHsKICAgICAgICAgIHRlbXBOZWVkTG9hZERpZk5vZGVzLnB1c2godGVtcFF1ZVtpXSk7CiAgICAgICAgICBwcmVDb2xJbmRleC5wdXNoKGNvbEluZGV4KTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHsKICAgICAgICAgIGNvbEluZGV4Kys7CiAgICAgICAgICBpLS07CiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoIm5vZGUgdGltZSBpcyBsaXR0bGUgdGhhbiBjb2wiKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHByZUNvbEluZGV4Lmxlbmd0aCAhPSB0ZW1wTmVlZExvYWREaWZOb2Rlcy5sZW5ndGgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBtZW1vcnkgaW5kZXgiKTsKICAgICAgfQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgY29uMSA9IGNhbkN1dCh0ZW1wTmVlZExvYWREaWZOb2Rlc1tpXSwgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLCBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLCB5U2NhbGUpOwogICAgICAgIGlmIChjb24xKSB7CiAgICAgICAgICB0ZW1wTmVlZExvYWREaWZOb2Rlcy5zcGxpY2UoaSwgMSk7CiAgICAgICAgICBwcmVDb2xJbmRleC5zcGxpY2UoaSwgMSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIC8vdGhpcy5jaGVja01vbm90b25pY2l0eShub25Vbmlmb3JtQ29sT2JqcyxwcmVDb2xJbmRleCx0ZW1wTmVlZExvYWREaWZOb2Rlcyk7CiAgICAgIG5lZWRMb2FkRGlmTm9kZSA9IHRlbXBOZWVkTG9hZERpZk5vZGVzOwogICAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA+IDAgJiYgbmVlZExvYWREaWZOb2RlWzBdLmxldmVsID09PSB0aGlzLm1heExldmVsIC0gMSkgewogICAgICAgIC8vY29uc29sZS5sb2coImxhc3QgbGV2ZWw6IixuZWVkTG9hZERpZk5vZGUubGVuZ3RoKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRMb2FkRGlmTm9kZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVswXSk7CiAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzBdKTsKICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uYWRkRmlyc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVszXSk7CiAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVszXSk7CiAgICAgICAgfQogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgbGV0IGxvc2VkRGF0YUluZm8gPSBjb21wdXRlTG9zZWREYXRhUmFuZ2UobmVlZExvYWREaWZOb2RlKTsKICAgICAgY29uc3QgY3VycmVudExldmVsTG9zZWRSYW5nZSA9IFtdOwogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvc2VkRGF0YUluZm8ubGVuZ3RoOyBqKyspIHsKICAgICAgICBjb25zdCBsZXZlbCA9IGxvc2VkRGF0YUluZm9bal1bMF07CiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb3NlZERhdGFJbmZvW2pdWzFdOwogICAgICAgIGNvbnN0IGVuZCA9IGxvc2VkRGF0YUluZm9bal1bMl07CiAgICAgICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbGV2ZWxdKSB7CiAgICAgICAgICBjb25zdCBoYXNEYXRhID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tsZXZlbF0uaGFzRGF0YUZvclJhbmdlKHN0YXJ0LCBlbmQpOwogICAgICAgICAgaWYgKCFoYXNEYXRhLmhhcykgewogICAgICAgICAgICBjb25zdCBsb3NlZFJhbmdlID0gaGFzRGF0YS5yYW5nZTsKICAgICAgICAgICAgbG9zZWRSYW5nZS5mb3JFYWNoKHJhbmdlID0+IHsKICAgICAgICAgICAgICByYW5nZS51bnNoaWZ0KGxldmVsKTsKICAgICAgICAgICAgICBjdXJyZW50TGV2ZWxMb3NlZFJhbmdlLnB1c2gocmFuZ2UpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY3VycmVudExldmVsTG9zZWRSYW5nZS5wdXNoKFtsZXZlbCwgc3RhcnQsIGVuZF0pOwogICAgICAgIH0KICAgICAgfQogICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbChjdXJyZW50TGV2ZWxMb3NlZFJhbmdlLCB0aGlzKTsKICAgIH0KICAgIC8vY29uc29sZS50aW1lRW5kKCJ2X2MiKQogICAgLy9kcmF3KG5vblVuaWZvcm1Db2xPYmpzKQogICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogIH0KICBhc3luYyB2aWV3Q2hhbmdlSW50ZXJhY3Rpb24xKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgeVNjYWxlKSB7CiAgICBhbGxUaW1lcyA9IFtdOwogICAgLy8gY29uc29sZS50aW1lKCJ2X2MiKQogICAgY29uc3Qgbm9uVW5pZm9ybUNvbE9ianMgPSBjb21wdXRlVGltZVNFKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgdGhpcy5yZWFsRGF0YVJvd051bSwgdGhpcy5tYXhMZXZlbCk7CiAgICBsZXQgbmVlZExvYWREaWZOb2RlID0gW107CiAgICBsZXQgY29sSW5kZXggPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBmaXJ0SW5kZXhUaW1lUmFuZ2UgPSB0aGlzLmdldEluZGV4VGltZShjdXJyZW50TGV2ZWwsIHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5sb2FkZWREYXRhUmFuZ2VbaV1bMF0sIHRoaXMubWF4TGV2ZWwpOwogICAgICBjb25zdCBsYXN0SW5kZXhUaW1lUmFuZ2UgPSB0aGlzLmdldEluZGV4VGltZShjdXJyZW50TGV2ZWwsIHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5sb2FkZWREYXRhUmFuZ2VbaV1bMV0sIHRoaXMubWF4TGV2ZWwpOwogICAgICBsZXQgcCA9IHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5maXJzdE5vZGVzW2ldOwogICAgICBpZiAoZmlydEluZGV4VGltZVJhbmdlLnN0YXJ0VCA8PSB0aW1lUmFuZ2VbMF0gJiYgbGFzdEluZGV4VGltZVJhbmdlLmVuZFQgPj0gdGltZVJhbmdlWzFdKSB7CiAgICAgICAgd2hpbGUgKHAgIT0gbnVsbCkgewogICAgICAgICAgaWYgKGNvbEluZGV4ID49IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoImNvbCBpbmRleCBvdXQgcmFuZ2UiKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNDb250YWluKHApOwogICAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHsKICAgICAgICAgICAgbmVlZExvYWREaWZOb2RlLnB1c2gocCk7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAzKSB7CiAgICAgICAgICAgIGNvbEluZGV4Kys7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDUpIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCJlcnJvciBpbiB2aWV3Y2hhbmdlIikKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoIm5vZGUgdGltZSBpcyBsaXR0bGUgdGhhbiBjb2wiKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgIGNvbnN0IHN1bVRpbWUgPSBhbGxUaW1lcy5yZWR1Y2UoKHByZSwgY3VyKSA9PiBwcmUgKyBjdXIsIDApOwogICAgICBhbGxTdW1UaW1lcy5wdXNoKHN1bVRpbWUpOwogICAgICBhbGxUaW1lcyA9IFtdOwogICAgICBpZiAoYWxsU3VtVGltZXMubGVuZ3RoID49IDUwKSB7CiAgICAgICAgY29uc29sZS5sb2coYWxsU3VtVGltZXMpOwogICAgICB9CiAgICAgIC8vZGVidWdnZXIKICAgICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogICAgfQogICAgbGV0IGxvc2VkRGF0YUluZm8gPSBjb21wdXRlTG9zZWREYXRhUmFuZ2VWMShuZWVkTG9hZERpZk5vZGUpOwogICAgLy9jb25zb2xlLmxvZyhsb3NlZERhdGFJbmZvKQogICAgLy8gaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID09PSAwKSB7CiAgICAvLyAgICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogICAgLy8gfQogICAgaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID4gMCkgewogICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxKGxvc2VkRGF0YUluZm8sIHRoaXMpOwogICAgICBhbGxUaW1lcy5wdXNoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKTsKICAgIH0KICAgIHdoaWxlIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID4gMCkgewogICAgICBjb2xJbmRleCA9IDA7CiAgICAgIGNvbnN0IHRlbXBOZWVkTG9hZERpZk5vZGVzID0gW107CiAgICAgIGNvbnN0IHRlbXBRdWUgPSBbXTsKICAgICAgbmVlZExvYWREaWZOb2RlLmZvckVhY2godiA9PiB7CiAgICAgICAgaWYgKHYuX2xlZnRDaGlsZCA9PT0gbnVsbCB8fCB2Ll9yaWdodENoaWxkID09PSBudWxsKSB7CiAgICAgICAgICBjb25zb2xlLmxvZyh2KTsKICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMpOwogICAgICAgICAgZGVidWdnZXI7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBmaW5kIG5leHQgbGV2ZWwgbm9kZSIpOwogICAgICAgIH0KICAgICAgICB0ZW1wUXVlLnB1c2godi5fbGVmdENoaWxkKTsKICAgICAgICB0ZW1wUXVlLnB1c2godi5fcmlnaHRDaGlsZCk7CiAgICAgIH0pOwogICAgICBjb25zdCBwcmVDb2xJbmRleCA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBRdWUubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAoY29sSW5kZXggPj0gbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJjb2wgaW5kZXggb3V0IHJhbmdlIik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNDb250YWluKHRlbXBRdWVbaV0pOwogICAgICAgIGlmICh0eXBlID09PSAxKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHsKICAgICAgICAgIHRlbXBOZWVkTG9hZERpZk5vZGVzLnB1c2godGVtcFF1ZVtpXSk7CiAgICAgICAgICBwcmVDb2xJbmRleC5wdXNoKGNvbEluZGV4KTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHsKICAgICAgICAgIGNvbEluZGV4Kys7CiAgICAgICAgICBpLS07CiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoIm5vZGUgdGltZSBpcyBsaXR0bGUgdGhhbiBjb2wiKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHByZUNvbEluZGV4Lmxlbmd0aCAhPSB0ZW1wTmVlZExvYWREaWZOb2Rlcy5sZW5ndGgpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBtZW1vcnkgaW5kZXgiKTsKICAgICAgfQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgaWYgKHByZUNvbEluZGV4W2ldICsgMSA8IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgY29uc3QgY29uMSA9IGNhbkN1dCh0ZW1wTmVlZExvYWREaWZOb2Rlc1tpXSwgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLCBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLCB5U2NhbGUpOwogICAgICAgICAgaWYgKGNvbjEpIHsKICAgICAgICAgICAgdGVtcE5lZWRMb2FkRGlmTm9kZXMuc3BsaWNlKGksIDEpOwogICAgICAgICAgICBwcmVDb2xJbmRleC5zcGxpY2UoaSwgMSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIC8vdGhpcy5jaGVja01vbm90b25pY2l0eShub25Vbmlmb3JtQ29sT2JqcyxwcmVDb2xJbmRleCx0ZW1wTmVlZExvYWREaWZOb2Rlcyk7CiAgICAgIG5lZWRMb2FkRGlmTm9kZSA9IHRlbXBOZWVkTG9hZERpZk5vZGVzOwogICAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA+IDAgJiYgbmVlZExvYWREaWZOb2RlWzBdLmxldmVsID09PSB0aGlzLm1heExldmVsIC0gMSkgewogICAgICAgIC8vY29uc29sZS5sb2coImxhc3QgbGV2ZWw6IixuZWVkTG9hZERpZk5vZGUubGVuZ3RoKTsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRMb2FkRGlmTm9kZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVswXSk7CiAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzBdKTsKICAgICAgICAgIGlmIChwcmVDb2xJbmRleFtpXSArIDEgPCBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5hZGRGaXJzdFZhbChuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzNdKTsKICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5mb3JjZU1lcmdlKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbM10pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA9PT0gMCkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGxldCBsb3NlZERhdGFJbmZvID0gY29tcHV0ZUxvc2VkRGF0YVJhbmdlVjEobmVlZExvYWREaWZOb2RlKTsKICAgICAgaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID4gMCkgewogICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOwogICAgICAgIGF3YWl0IGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMShsb3NlZERhdGFJbmZvLCB0aGlzKTsKICAgICAgICBhbGxUaW1lcy5wdXNoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKTsKICAgICAgfQogICAgfQogICAgY29uc3Qgc3VtVGltZSA9IGFsbFRpbWVzLnJlZHVjZSgocHJlLCBjdXIpID0+IHByZSArIGN1ciwgMCk7CiAgICAvLyBjb25zb2xlLmxvZyhzdW1UaW1lKQogICAgLy9hbGxTdW1UaW1lcy5wdXNoKHN1bVRpbWUpCiAgICAvL2FsbFRpbWVzID0gW107CiAgICAvL2lmKGFsbFN1bVRpbWVzLmxlbmd0aD49NTApewogICAgLy8gICAgY29uc29sZS5sb2coYWxsU3VtVGltZXMpCiAgICAvLyB9CiAgICAvL2NvbnNvbGUudGltZUVuZCgidl9jIikKICAgIHJldHVybiBub25Vbmlmb3JtQ29sT2JqczsKICB9CiAgY2hlY2tMb2FkZWREYXRhSW5TaW5nYWxMZXZlbChsb3NlZERhdGFJbmZvKSB7CiAgICBjb25zdCBjdXJyZW50TGV2ZWxMb3NlZFJhbmdlID0gW107CiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvc2VkRGF0YUluZm8ubGVuZ3RoOyBqKyspIHsKICAgICAgY29uc3QgbGV2ZWwgPSBsb3NlZERhdGFJbmZvW2pdWzBdOwogICAgICBjb25zdCBzdGFydCA9IGxvc2VkRGF0YUluZm9bal1bMV07CiAgICAgIGNvbnN0IGVuZCA9IGxvc2VkRGF0YUluZm9bal1bMl07CiAgICAgIGlmICh0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXSkgewogICAgICAgIGNvbnN0IGhhc0RhdGEgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2xldmVsXS5oYXNEYXRhRm9yUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgaWYgKCFoYXNEYXRhLmhhcykgewogICAgICAgICAgY29uc3QgbG9zZWRSYW5nZSA9IGhhc0RhdGEucmFuZ2U7CiAgICAgICAgICBsb3NlZFJhbmdlLmZvckVhY2gocmFuZ2UgPT4gewogICAgICAgICAgICByYW5nZS51bnNoaWZ0KGxldmVsKTsKICAgICAgICAgICAgY3VycmVudExldmVsTG9zZWRSYW5nZS5wdXNoKHJhbmdlKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBjdXJyZW50TGV2ZWxMb3NlZFJhbmdlLnB1c2goW2xldmVsLCBzdGFydCwgZW5kXSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBjdXJyZW50TGV2ZWxMb3NlZFJhbmdlOwogIH0KICBjaGVja0xvYWRlZERhdGFJblNpbmdhbExldmVsVjEobG9zZWREYXRhSW5mbykgewogICAgY29uc3QgY3VycmVudExldmVsTG9zZWRSYW5nZSA9IFtdOwogICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb3NlZERhdGFJbmZvLmxlbmd0aDsgaisrKSB7CiAgICAgIGNvbnN0IGxldmVsID0gbG9zZWREYXRhSW5mb1tqXVswXTsKICAgICAgY29uc3Qgc3RhcnQgPSBsb3NlZERhdGFJbmZvW2pdWzFdOwogICAgICBjb25zdCBlbmQgPSBsb3NlZERhdGFJbmZvW2pdWzJdOwogICAgICBpZiAodGhpcy5sZXZlbEluZGV4T2Jqc1tsZXZlbF0pIHsKICAgICAgICBjb25zdCBoYXNEYXRhID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tsZXZlbF0uaGFzRGF0YUZvclJhbmdlKHN0YXJ0LCBlbmQpOwogICAgICAgIGlmICghaGFzRGF0YS5oYXMpIHsKICAgICAgICAgIGNvbnN0IGxvc2VkUmFuZ2UgPSBoYXNEYXRhLnJhbmdlOwogICAgICAgICAgbG9zZWRSYW5nZS5mb3JFYWNoKHJhbmdlID0+IHsKICAgICAgICAgICAgcmFuZ2UudW5zaGlmdChsZXZlbCk7CiAgICAgICAgICAgIGN1cnJlbnRMZXZlbExvc2VkUmFuZ2UucHVzaChyYW5nZSk7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY3VycmVudExldmVsTG9zZWRSYW5nZS5wdXNoKFtsZXZlbCwgc3RhcnQsIGVuZF0pOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gY3VycmVudExldmVsTG9zZWRSYW5nZTsKICB9CiAgZ2V0SW5kZXhUaW1lKGwsIGluZGV4LCBtYXhMZXZlbCkgewogICAgY29uc3QgZ2FwID0gMiAqKiBtYXhMZXZlbCAvIDIgKiogbDsKICAgIGNvbnN0IHN0YXJ0VGltZSA9IGluZGV4ICogZ2FwOwogICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGdhcCAtIDE7CiAgICByZXR1cm4gewogICAgICBzdGFydFQ6IHN0YXJ0VGltZSwKICAgICAgZW5kVDogZW5kVGltZQogICAgfTsKICB9CiAgaW5pdENhY2hlKCkgewogICAgY29uc3Qgb3B0aW9ucyA9IHsKICAgICAgbWF4OiAxMDAwMDAwLAogICAgICBtYXhTaXplOiAxMDAwMDAwLAogICAgICBzaXplQ2FsY3VsYXRpb246ICh2YWx1ZSwga2V5KSA9PiB7CiAgICAgICAgcmV0dXJuIDE7CiAgICAgIH0sCiAgICAgIGRpc3Bvc2U6ICh2YWx1ZSwga2V5LCByZWFzb24pID0+IHsKICAgICAgICBpZiAocmVhc29uID09PSAiZXZpY3QiKSB7CiAgICAgICAgICBjb25zb2xlLmxvZyhrZXkpOwogICAgICAgICAgdGhpcy5kZWxldGVRdWV1ZS5wdXNoKHZhbHVlKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGRpc3Bvc2VBZnRlcjogKHZhbHVlLCBrZXksIHJlYXNvbikgPT4gewogICAgICAgIC8vY29uc29sZS5sb2coImRpc3Bvc2UgYWZ0ZXItLS0tLS0tLS0tLS0tLS0tLS0tLS0tIixrZXkscmVhc29uKQogICAgICB9LAogICAgICB0dGw6IDEwMDAgKiA2MCAqIDYwLAogICAgICBhbGxvd1N0YWxlOiBmYWxzZSwKICAgICAgdXBkYXRlQWdlT25HZXQ6IHRydWUsCiAgICAgIHVwZGF0ZUFnZU9uSGFzOiB0cnVlCiAgICB9OwogICAgdGhpcy5scnVDYWNoZSA9IG5ldyBDYWNoZShvcHRpb25zKTsKICAgIHRoaXMuZXZpY3RUcmVlTm9kZSgpOwogICAgcmV0dXJuOwogIH0KICBldmljdFRyZWVOb2RlKCkgewogICAgc2V0SW50ZXJ2YWwoKCkgPT4gewogICAgICBpZiAodGhpcy5pc0ludGVyaW5nKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIHRoaXMuaXNFdmljdGluZyA9IHRydWU7CiAgICAgIHRoaXMuZGVsZXRlUXVldWUuZm9yRWFjaChjdXJOb2RlID0+IHsKICAgICAgICBjb25zdCBsID0gY3VyTm9kZS5sZXZlbDsKICAgICAgICBjb25zdCBpID0gY3VyTm9kZS5pbmRleDsKICAgICAgICB0aGlzLmxydUNhY2hlLmRlbGV0ZShsICsgIl8iICsgaSk7CiAgICAgICAgaWYgKHRoaXMubGV2ZWxJbmRleE9ianNbbF0uaGFzRGF0YUZvclJhbmdlKGksIGkpLmhhcykgewogICAgICAgICAgdGhpcy5kZWxldGVOb2RlV2hpdGhDaGlsZChsLCBpKTsKICAgICAgICAgIGNvbnNvbGUubG9nKCJldmljdCBsOiIgKyBsICsgIiBpOiIgKyBpICsgIiBmaW5pc2ghIik7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdGhpcy5pc0V2aWN0aW5nID0gZmFsc2U7CiAgICB9LCAxMDAwKTsKICB9CiAgZGVsZXRlTm9kZVdoaXRoQ2hpbGQobGV2ZWwsIGluZGV4KSB7CiAgICBsZXQgY3VyTFMgPSBpbmRleDsKICAgIGxldCBjdXJSUyA9IGluZGV4OwogICAgZm9yIChsZXQgaiA9IGxldmVsOyBqIDwgdGhpcy5tYXhMZXZlbCAtIDE7IGorKykgewogICAgICBpZiAoaiA9PSBsZXZlbCkgewogICAgICAgIGN1ckxTID0gaW5kZXg7CiAgICAgICAgY3VyUlMgPSBpbmRleDsKICAgICAgfSBlbHNlIHsKICAgICAgICBjdXJMUyA9IDIgKiogKGogLSBsZXZlbCkgKiBjdXJMUzsKICAgICAgICBjdXJSUyA9IDIgKiogKGogLSBsZXZlbCkgKiBjdXJSUyArIDE7CiAgICAgIH0KICAgICAgY29uc3QgY3VyTExvYWRlZFJhbmdlID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tqXS5sb2FkZWREYXRhUmFuZ2U7CiAgICAgIGNvbnN0IGN1ckZpcnN0Tm9kZXMgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2pdLmZpcnN0Tm9kZXM7CiAgICAgIGlmICghY3VyTExvYWRlZFJhbmdlIHx8ICFjdXJGaXJzdE5vZGVzKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgY29uc3QgbmV3Rmlyc3ROb2RlcyA9IFtdOwogICAgICBjb25zdCBuZXdMb2FkRGF0YVJhbmdlcyA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckxMb2FkZWRSYW5nZS5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGN1clJhbmdlMCA9IGN1ckxMb2FkZWRSYW5nZVtpXTsKICAgICAgICBpZiAoY3VyUmFuZ2UwWzFdIDwgY3VyUlMpIHsKICAgICAgICAgIG5ld0ZpcnN0Tm9kZXMucHVzaChjdXJGaXJzdE5vZGVzW2ldKTsKICAgICAgICAgIG5ld0xvYWREYXRhUmFuZ2VzLnB1c2goW2N1clJhbmdlMFswXSwgY3VyUmFuZ2UwWzFdXSk7CiAgICAgICAgfSBlbHNlIGlmIChjdXJSYW5nZTBbMF0gPCBjdXJMUyAmJiBjdXJSYW5nZTBbMV0gPT09IGN1ckxTKSB7CiAgICAgICAgICBpZiAoY3VyRmlyc3ROb2Rlc1tpXS5uZXh0U2libGluZykgewogICAgICAgICAgICBuZXdMb2FkRGF0YVJhbmdlcy5wdXNoKFtjdXJSYW5nZTBbMF0sIGN1clJhbmdlMFsxXSAtIDFdKTsKICAgICAgICAgICAgbmV3Rmlyc3ROb2Rlcy5wdXNoKGN1ckZpcnN0Tm9kZXNbaV0pOwogICAgICAgICAgfQogICAgICAgICAgbGV0IGN1clAgPSBjdXJGaXJzdE5vZGVzW2ldOwogICAgICAgICAgd2hpbGUgKGN1clApIHsKICAgICAgICAgICAgaWYgKGN1clAuaW5kZXggPT09IGN1ckxTKSB7CiAgICAgICAgICAgICAgaWYgKGN1clAucHJldmlvdXNTaWJsaW5nKSB7CiAgICAgICAgICAgICAgICBjdXJQLnByZXZpb3VzU2libGluZy5uZXh0U2libGluZyA9IG51bGw7CiAgICAgICAgICAgICAgICBjdXJQLnByZXZpb3VzU2libGluZyA9IG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vQHRzLWlnbm9yZQogICAgICAgICAgICBjdXJQID0gY3VyUC5uZXh0U2libGluZzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjdXJQID09PSBudWxsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGZpbmQgcmFuZ2Ugbm9kZSIpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoY3VyUmFuZ2UwWzBdIDwgY3VyTFMgJiYgY3VyUmFuZ2UwWzFdID4gY3VyTFMgJiYgY3VyUmFuZ2UwWzFdIDwgY3VyUlMpIHsKICAgICAgICAgIG5ld0ZpcnN0Tm9kZXMucHVzaChjdXJGaXJzdE5vZGVzW2ldKTsKICAgICAgICAgIG5ld0xvYWREYXRhUmFuZ2VzLnB1c2goW2N1clJhbmdlMFswXSwgY3VyTFMgLSAxXSk7CiAgICAgICAgICBsZXQgY3VyUCA9IGN1ckZpcnN0Tm9kZXNbaV07CiAgICAgICAgICB3aGlsZSAoY3VyUCkgewogICAgICAgICAgICBpZiAoY3VyUC5pbmRleCA9PT0gY3VyTFMpIHsKICAgICAgICAgICAgICBpZiAoY3VyUC5wcmV2aW91c1NpYmxpbmcpIHsKICAgICAgICAgICAgICAgIGN1clAucHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICAgIGN1clAucHJldmlvdXNTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy9AdHMtaWdub3JlCiAgICAgICAgICAgIGN1clAgPSBjdXJQLm5leHRTaWJsaW5nOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGN1clAgPT09IG51bGwpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZmluZCByYW5nZSBub2RlIik7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChjdXJSYW5nZTBbMF0gPCBjdXJMUyAmJiBjdXJSYW5nZTBbMV0gPT09IGN1clJTKSB7CiAgICAgICAgICBuZXdGaXJzdE5vZGVzLnB1c2goY3VyRmlyc3ROb2Rlc1tpXSk7CiAgICAgICAgICBuZXdMb2FkRGF0YVJhbmdlcy5wdXNoKFtjdXJSYW5nZTBbMF0sIGN1ckxTIC0gMV0pOwogICAgICAgICAgbGV0IGN1clAgPSBjdXJGaXJzdE5vZGVzW2ldOwogICAgICAgICAgd2hpbGUgKGN1clApIHsKICAgICAgICAgICAgaWYgKGN1clAuaW5kZXggPT09IGN1ckxTKSB7CiAgICAgICAgICAgICAgaWYgKGN1clAucHJldmlvdXNTaWJsaW5nKSB7CiAgICAgICAgICAgICAgICBjdXJQLnByZXZpb3VzU2libGluZy5uZXh0U2libGluZyA9IG51bGw7CiAgICAgICAgICAgICAgICBjdXJQLnByZXZpb3VzU2libGluZyA9IG51bGw7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vQHRzLWlnbm9yZQogICAgICAgICAgICBjdXJQID0gY3VyUC5uZXh0U2libGluZzsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjdXJQID09PSBudWxsKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGZpbmQgcmFuZ2Ugbm9kZSIpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoY3VyUmFuZ2UwWzBdIDwgY3VyTFMgJiYgY3VyUmFuZ2UwWzFdID4gY3VyUlMpIHsKICAgICAgICAgIC8vZGVidWdnZXIKICAgICAgICAgIG5ld0ZpcnN0Tm9kZXMucHVzaChjdXJGaXJzdE5vZGVzW2ldKTsKICAgICAgICAgIG5ld0xvYWREYXRhUmFuZ2VzLnB1c2goW2N1clJhbmdlMFswXSwgY3VyTFMgLSAxXSk7CiAgICAgICAgICBsZXQgY3VyUCA9IGN1ckZpcnN0Tm9kZXNbaV07CiAgICAgICAgICB3aGlsZSAoY3VyUCkgewogICAgICAgICAgICBpZiAoY3VyUC5pbmRleCA9PT0gY3VyTFMpIHsKICAgICAgICAgICAgICBpZiAoY3VyUC5wcmV2aW91c1NpYmxpbmcpIHsKICAgICAgICAgICAgICAgIGN1clAucHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICAgIGN1clAucHJldmlvdXNTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGN1clAuaW5kZXggPT09IGN1clJTKSB7CiAgICAgICAgICAgICAgaWYgKGN1clAubmV4dFNpYmxpbmcpIHsKICAgICAgICAgICAgICAgIG5ld0ZpcnN0Tm9kZXMucHVzaChjdXJQLm5leHRTaWJsaW5nKTsKICAgICAgICAgICAgICAgIG5ld0xvYWREYXRhUmFuZ2VzLnB1c2goW2N1clJTICsgMSwgY3VyUmFuZ2UwWzFdXSk7CiAgICAgICAgICAgICAgICBjdXJQLm5leHRTaWJsaW5nLnByZXZpb3VzU2libGluZyA9IG51bGw7CiAgICAgICAgICAgICAgICBjdXJQLm5leHRTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy9AdHMtaWdub3JlCiAgICAgICAgICAgIGN1clAgPSBjdXJQLm5leHRTaWJsaW5nOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGN1clAgPT09IG51bGwpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZmluZCByYW5nZSBub2RlIik7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChjdXJSYW5nZTBbMF0gPT09IGN1ckxTICYmIGN1clJhbmdlMFsxXSA+IGN1clJTKSB7CiAgICAgICAgICBsZXQgY3VyUCA9IGN1ckZpcnN0Tm9kZXNbaV07CiAgICAgICAgICB3aGlsZSAoY3VyUCkgewogICAgICAgICAgICBpZiAoY3VyUC5pbmRleCA9PT0gY3VyUlMpIHsKICAgICAgICAgICAgICBpZiAoY3VyUC5uZXh0U2libGluZykgewogICAgICAgICAgICAgICAgbmV3Rmlyc3ROb2Rlcy5wdXNoKGN1clAubmV4dFNpYmxpbmcpOwogICAgICAgICAgICAgICAgbmV3TG9hZERhdGFSYW5nZXMucHVzaChbY3VyUlMgKyAxLCBjdXJSYW5nZTBbMV1dKTsKICAgICAgICAgICAgICAgIGN1clAubmV4dFNpYmxpbmcucHJldmlvdXNTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICAgIGN1clAubmV4dFNpYmxpbmcgPSBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL0B0cy1pZ25vcmUKICAgICAgICAgICAgY3VyUCA9IGN1clAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY3VyUCA9PT0gbnVsbCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBmaW5kIHJhbmdlIG5vZGUiKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKGN1clJhbmdlMFswXSA9PT0gY3VyTFMgJiYgY3VyUmFuZ2UwWzFdID09PSBjdXJSUykgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSBlbHNlIGlmIChjdXJSYW5nZTBbMF0gPT09IGN1ckxTICYmIGN1clJhbmdlMFsxXSA8IGN1clJTKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IGVsc2UgaWYgKGN1clJhbmdlMFswXSA+IGN1ckxTICYmIGN1clJhbmdlMFsxXSA+IGN1clJTICYmIGN1clJhbmdlMFswXSA8IGN1clJTKSB7CiAgICAgICAgICBsZXQgY3VyUCA9IGN1ckZpcnN0Tm9kZXNbaV07CiAgICAgICAgICB3aGlsZSAoY3VyUCkgewogICAgICAgICAgICBpZiAoY3VyUC5pbmRleCA9PT0gY3VyUlMpIHsKICAgICAgICAgICAgICBpZiAoY3VyUC5uZXh0U2libGluZykgewogICAgICAgICAgICAgICAgbmV3Rmlyc3ROb2Rlcy5wdXNoKGN1clAubmV4dFNpYmxpbmcpOwogICAgICAgICAgICAgICAgbmV3TG9hZERhdGFSYW5nZXMucHVzaChbY3VyUlMgKyAxLCBjdXJSYW5nZTBbMV1dKTsKICAgICAgICAgICAgICAgIGN1clAubmV4dFNpYmxpbmcucHJldmlvdXNTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgICAgIGN1clAubmV4dFNpYmxpbmcgPSBudWxsOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL0B0cy1pZ25vcmUKICAgICAgICAgICAgY3VyUCA9IGN1clAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoY3VyUCA9PT0gbnVsbCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBmaW5kIHJhbmdlIG5vZGUiKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKGN1clJhbmdlMFswXSA+IGN1ckxTICYmIGN1clJhbmdlMFswXSA9PT0gY3VyUlMpIHsKICAgICAgICAgIGlmIChjdXJGaXJzdE5vZGVzW2ldLm5leHRTaWJsaW5nKSB7CiAgICAgICAgICAgIG5ld0ZpcnN0Tm9kZXMucHVzaChjdXJGaXJzdE5vZGVzW2ldLm5leHRTaWJsaW5nKTsKICAgICAgICAgICAgbmV3TG9hZERhdGFSYW5nZXMucHVzaChbY3VyUmFuZ2UwWzBdICsgMSwgY3VyUmFuZ2UwWzFdXSk7CiAgICAgICAgICAgIGN1ckZpcnN0Tm9kZXNbaV0ubmV4dFNpYmxpbmcucHJldmlvdXNTaWJsaW5nID0gbnVsbDsKICAgICAgICAgICAgY3VyRmlyc3ROb2Rlc1tpXS5uZXh0U2libGluZyA9IG51bGw7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChjdXJSYW5nZTBbMF0gPiBjdXJSUykgewogICAgICAgICAgbmV3Rmlyc3ROb2Rlcy5wdXNoKGN1ckZpcnN0Tm9kZXNbaV0pOwogICAgICAgICAgbmV3TG9hZERhdGFSYW5nZXMucHVzaChbY3VyUmFuZ2UwWzBdLCBjdXJSYW5nZTBbMV1dKTsKICAgICAgICB9IGVsc2UgaWYgKGN1clJhbmdlMFswXSA+IGN1ckxTICYmIGN1clJhbmdlMFsxXSA9PT0gY3VyUlMpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zb2xlLmxvZyhjdXJSYW5nZTAsIGN1ckxTLCBjdXJSUyk7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInJhbmdlIGVycm9yIik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHRoaXMubGV2ZWxJbmRleE9ianNbal0ubG9hZGVkRGF0YVJhbmdlID0gbmV3TG9hZERhdGFSYW5nZXM7CiAgICAgIHRoaXMubGV2ZWxJbmRleE9ianNbal0uZmlyc3ROb2RlcyA9IG5ld0ZpcnN0Tm9kZXM7CiAgICB9CiAgfQogIHVwZGF0ZU1heENhY2hlU2l6ZShzaXplKSB7CiAgICB0aGlzLm1heENhY2hlTm9kZU51bSA9IHNpemU7CiAgfQogIGxydUNhY2hlRGVsZXRlKCkgewogICAgY29uc29sZS5sb2codGhpcy5jYWNoZU1hcC5zaXplKTsKICAgIGlmICh0aGlzLmNhY2hlTWFwLnNpemUgPD0gdGhpcy5tYXhDYWNoZU5vZGVOdW0pIHsKICAgICAgcmV0dXJuOwogICAgfQogICAgbGV0IG5lZWREZWxldGVOdW0gPSB0aGlzLmNhY2hlTWFwLnNpemUgLSB0aGlzLm1heENhY2hlTm9kZU51bTsKICAgIGlmIChuZWVkRGVsZXRlTnVtICUgMiAhPSAwKSB7CiAgICAgIG5lZWREZWxldGVOdW0rKzsKICAgIH0KICAgIGNvbnNvbGUubG9nKCJkZWxldGUgbnVtczoiLCBuZWVkRGVsZXRlTnVtKTsKICAgIGZvciAobGV0IGkgPSB0aGlzLmxldmVsSW5kZXhPYmpzLmxlbmd0aCAtIDI7IGkgPiAwOyBpLS0pIHsKICAgICAgaWYgKG5lZWREZWxldGVOdW0gPD0gMCkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGNvbnN0IGxldmVsT2JqID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tpXTsKICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZXZlbE9iai5maXJzdE5vZGVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgbGV0IGZpcnN0Tm9kZSA9IGxldmVsT2JqLmZpcnN0Tm9kZXNbal07CiAgICAgICAgdGhpcy5sZXZlbEluZGV4T2Jqc1tmaXJzdE5vZGUubGV2ZWwgKyAxXS5sb2FkZWREYXRhUmFuZ2UgPSBbXTsKICAgICAgICB0aGlzLmxldmVsSW5kZXhPYmpzW2ZpcnN0Tm9kZS5sZXZlbCArIDFdLmZpcnN0Tm9kZXMgPSBbXTsKICAgICAgICB0aGlzLmxldmVsSW5kZXhPYmpzW2ZpcnN0Tm9kZS5sZXZlbCArIDFdLmlzRnVsbCA9IGZhbHNlOwogICAgICAgIHdoaWxlIChmaXJzdE5vZGUpIHsKICAgICAgICAgIGlmIChmaXJzdE5vZGUuX2xlZnRDaGlsZCkgewogICAgICAgICAgICB0aGlzLmNhY2hlTWFwLmRlbGV0ZShmaXJzdE5vZGUuX2xlZnRDaGlsZC5pbmRleCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZmlyc3ROb2RlLl9yaWdodENoaWxkKSB7CiAgICAgICAgICAgIHRoaXMuY2FjaGVNYXAuZGVsZXRlKGZpcnN0Tm9kZS5fcmlnaHRDaGlsZC5pbmRleCk7CiAgICAgICAgICB9CiAgICAgICAgICAvL0B0cy1pZ25vcmUKICAgICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5uZXh0U2libGluZzsKICAgICAgICAgIG5lZWREZWxldGVOdW0gLT0gMjsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgYXN5bmMgY29tcHV0ZVBvd0NvbihjdXJyZW50TGV2ZWwsIHdpZHRoLCBnYXBOZWVkTm9kZXMsIG5vblVuaWZvcm1Db2xPYmpzKSB7CiAgICAvL2RlYnVnZ2VyCiAgICBjb25zb2xlLmxvZygicHdvOiIsIHdpZHRoKTsKICAgIGNvbnN0IHRpbWVzID0gW107CiAgICBsZXQgbmVlZExvYWREaWZOb2RlID0gW107CiAgICBpZiAoZ2FwTmVlZE5vZGVzLmxlbmd0aCAlIHdpZHRoICE9PSAwKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiZ2FwIG5vZGUgbm90IG1hdGNoIHdpZGh0Iik7CiAgICB9CiAgICBjb25zdCB0aW1lTnVtID0gZ2FwTmVlZE5vZGVzLmxlbmd0aCAvIHdpZHRoOwogICAgY29uc3QgZ3JvdXBzID0gbmV3IEFycmF5KHdpZHRoKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7CiAgICAgIGdyb3Vwc1tpXSA9IFtdOwogICAgfQogICAgaWYgKHRpbWVOdW0gPiAxKSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FwTmVlZE5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgZ3JvdXBJZHggPSBNYXRoLmZsb29yKGkgLyB0aW1lTnVtKTsKICAgICAgICBncm91cHNbZ3JvdXBJZHhdLnB1c2goZ2FwTmVlZE5vZGVzW2ldKTsKICAgICAgfQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGggLSAxOyBpKyspIHsKICAgICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTsKICAgICAgICBjb25zdCBzZWNHcm91cCA9IGdyb3Vwc1tpICsgMV07CiAgICAgICAgbmVlZExvYWREaWZOb2RlLnB1c2goZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV0pOwogICAgICAgIG5lZWRMb2FkRGlmTm9kZS5wdXNoKHNlY0dyb3VwWzBdKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgbmVlZExvYWREaWZOb2RlID0gZ2FwTmVlZE5vZGVzOwogICAgfQogICAgbGV0IGxvc2VkRGF0YUluZm8gPSBjb21wdXRlTG9zZWREYXRhUmFuZ2VWMShuZWVkTG9hZERpZk5vZGUpOwogICAgaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID4gMCkgewogICAgICBjb25zdCBsZXZlbFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxKGxvc2VkRGF0YUluZm8sIHRoaXMpOwogICAgICB0aW1lcy5wdXNoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGV2ZWxUaW1lKTsKICAgIH0gZWxzZSB7CiAgICAgIHRpbWVzLnB1c2goMSk7CiAgICB9CiAgICAvL2RlYnVnZ2VyCiAgICBsZXQgY29sdW1uR2FwQXJyYXkgPSBbXTsKICAgIGlmICh0aW1lTnVtID09IDEpIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkTG9hZERpZk5vZGUubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgICAgLy8gZGVidWdnZXIKICAgICAgICBpZiAobmVlZExvYWREaWZOb2RlW2ldLl9yaWdodENoaWxkICYmIG5lZWRMb2FkRGlmTm9kZVtpICsgMV0uX2xlZnRDaGlsZCkgewogICAgICAgICAgY29uc3QgY29sdW1uR2FwID0gbmV3IFVuaWZvcm1HYXBPYmoobmVlZExvYWREaWZOb2RlW2ldLCBuZWVkTG9hZERpZk5vZGVbaSArIDFdKTsKICAgICAgICAgIGNvbHVtbkdhcEFycmF5LnB1c2goY29sdW1uR2FwKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjaGlsZHJlbiBjYW5ub3QgZW1wdHkiKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZExvYWREaWZOb2RlLmxlbmd0aDsgaSArPSAyKSB7CiAgICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZVtpXS5fcmlnaHRDaGlsZCAmJiBuZWVkTG9hZERpZk5vZGVbaSArIDFdLl9sZWZ0Q2hpbGQpIHsKICAgICAgICAgIGNvbnN0IGNvbHVtbkdhcCA9IG5ldyBVbmlmb3JtR2FwT2JqKG5lZWRMb2FkRGlmTm9kZVtpXSwgbmVlZExvYWREaWZOb2RlW2kgKyAxXSk7CiAgICAgICAgICBjb2x1bW5HYXBBcnJheS5wdXNoKGNvbHVtbkdhcCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2hpbGRyZW4gY2Fubm90IGVtcHR5Iik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgIGNvbnN0IGdyb3VwMSA9IGdyb3Vwc1tpXTsKICAgICAgICBjb25zdCBncm91cDIgPSBncm91cHNbaSArIDFdOwogICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JvdXAxLmxlbmd0aCAtIDE7IGorKykgewogICAgICAgICAgY29sdW1uR2FwQXJyYXlbaV0udXBkYXRlTGVmdE1pbk1heChncm91cDFbal0pOwogICAgICAgIH0KICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGdyb3VwMi5sZW5ndGg7IGorKykgewogICAgICAgICAgY29sdW1uR2FwQXJyYXlbaV0udXBkYXRlUmlnaGV0TWluTWF4KGdyb3VwMltqXSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBsZXQgY29uID0gdHJ1ZTsKICAgIHdoaWxlIChjb24pIHsKICAgICAgLy9kZWJ1Z2dlcgogICAgICBsZXQgaXNGaW5pc2ggPSBmYWxzZTsKICAgICAgbmVlZExvYWREaWZOb2RlID0gW107CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uR2FwQXJyYXkubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBpc0N1dCA9IGNvbHVtbkdhcEFycmF5W2ldLmNhbkN1dCgpOwogICAgICAgIGlzRmluaXNoID0gaXNDdXQgJiYgaXNGaW5pc2g7CiAgICAgICAgaWYgKCFpc0N1dCkgewogICAgICAgICAgbmVlZExvYWREaWZOb2RlLnB1c2goY29sdW1uR2FwQXJyYXlbaV0uZmlyc3ROb2RlKTsKICAgICAgICAgIG5lZWRMb2FkRGlmTm9kZS5wdXNoKGNvbHVtbkdhcEFycmF5W2ldLnNlY29uZE5vZGUpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoaXNGaW5pc2gpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA9PSAwKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwICYmIG5lZWRMb2FkRGlmTm9kZVswXS5sZXZlbCA9PT0gdGhpcy5tYXhMZXZlbCAtIDEpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkdhcEFycmF5Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBjb2xHYXAgPSBjb2x1bW5HYXBBcnJheVtpXTsKICAgICAgICAgIGlmICghY29sR2FwLmlzT2spIHsKICAgICAgICAgICAgaWYgKGNvbEdhcC5maXJzdE5vZGUgJiYgY29sR2FwLnNlY29uZE5vZGUpIHsKICAgICAgICAgICAgICBjb2xHYXAubGFzdExldmVsVXBkYXRlTWluTWF4KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgbG9zZWREYXRhSW5mbyA9IGNvbXB1dGVMb3NlZERhdGFSYW5nZVYxKG5lZWRMb2FkRGlmTm9kZSk7CiAgICAgIGlmIChsb3NlZERhdGFJbmZvLmxlbmd0aCA+IDApIHsKICAgICAgICBjb25zdCBsZXZlbFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDEobG9zZWREYXRhSW5mbywgdGhpcyk7CiAgICAgICAgdGltZXMucHVzaChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGxldmVsVGltZSk7CiAgICAgIH0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5HYXBBcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGNvbEdhcCA9IGNvbHVtbkdhcEFycmF5W2ldOwogICAgICAgIGlmICghY29sR2FwLmlzT2spIHsKICAgICAgICAgIGlmIChjb2xHYXAuZmlyc3ROb2RlLl9yaWdodENoaWxkICYmIGNvbEdhcC5zZWNvbmROb2RlLl9sZWZ0Q2hpbGQpIHsKICAgICAgICAgICAgY29sR2FwLnVwZGF0ZVR3b05vZGUoY29sR2FwLmZpcnN0Tm9kZSwgY29sR2FwLnNlY29uZE5vZGUpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYgKG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCAhPT0gY29sdW1uR2FwQXJyYXkubGVuZ3RoICsgMSkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoImNvbHVtbiBub3QgbWF0Y2ggZ2FwIik7CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkdhcEFycmF5Lmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IGNvbEdhcCA9IGNvbHVtbkdhcEFycmF5W2ldOwogICAgICBpZiAoY29sR2FwLmNhblVzZVQpIHsKICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1tpXS5lbmRWID0gY29sR2FwLnRPbmU7CiAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbaV0uc3RhcnRWID0gY29sR2FwLnRPbmU7CiAgICAgIH0KICAgIH0KICAgIGlmICh0aW1lcy5sZW5ndGggPj0gMykgewogICAgICBhbGxUaW1lcy5wdXNoKHRpbWVzWzBdKTsKICAgICAgLy9hbGxUaW1lcy5wdXNoKHRpbWVzWzFdKQogICAgfQogICAgY29uc29sZS5sb2coYWxsVGltZXMpOwogICAgY29uc29sZS5sb2codGltZXMpOwogICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogIH0KICBiZnNTZWFyY2hUcmVlKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgbm9uVW5pZm9ybUNvbE9ianMpIHsKICAgIGxldCBuZWVkTG9hZERpZk5vZGUgPSBbXTsKICAgIGxldCBjb2xJbmRleCA9IDA7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5maXJzdE5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgIGNvbnN0IGZpcnRJbmRleFRpbWVSYW5nZSA9IHRoaXMuZ2V0SW5kZXhUaW1lKGN1cnJlbnRMZXZlbCwgdGhpcy5sZXZlbEluZGV4T2Jqc1tjdXJyZW50TGV2ZWxdLmxvYWRlZERhdGFSYW5nZVtpXVswXSwgdGhpcy5tYXhMZXZlbCk7CiAgICAgIGNvbnN0IGxhc3RJbmRleFRpbWVSYW5nZSA9IHRoaXMuZ2V0SW5kZXhUaW1lKGN1cnJlbnRMZXZlbCwgdGhpcy5sZXZlbEluZGV4T2Jqc1tjdXJyZW50TGV2ZWxdLmxvYWRlZERhdGFSYW5nZVtpXVsxXSwgdGhpcy5tYXhMZXZlbCk7CiAgICAgIGxldCBwID0gdGhpcy5sZXZlbEluZGV4T2Jqc1tjdXJyZW50TGV2ZWxdLmZpcnN0Tm9kZXNbaV07CiAgICAgIGlmIChmaXJ0SW5kZXhUaW1lUmFuZ2Uuc3RhcnRUIDw9IHRpbWVSYW5nZVswXSAmJiBsYXN0SW5kZXhUaW1lUmFuZ2UuZW5kVCA+PSB0aW1lUmFuZ2VbMV0pIHsKICAgICAgICB3aGlsZSAocCAhPSBudWxsKSB7CiAgICAgICAgICBpZiAoY29sSW5kZXggPj0gbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcigiY29sIGluZGV4IG91dCByYW5nZSIpOwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgdHlwZSA9IG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5pc0NvbnRhaW4ocCk7CiAgICAgICAgICBpZiAodHlwZSA9PT0gMSkgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikgewogICAgICAgICAgICBuZWVkTG9hZERpZk5vZGUucHVzaChwKTsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHsKICAgICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNSkgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNikgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImVycm9yIGluIHZpZXdjaGFuZ2UiKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoIm5vZGUgdGltZSBpcyBsaXR0bGUgdGhhbiBjb2wiKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgIC8vZGVidWdnZXIKICAgICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogICAgfQogICAgd2hpbGUgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwKSB7CiAgICAgIGNvbEluZGV4ID0gMDsKICAgICAgY29uc3QgdGVtcE5lZWRMb2FkRGlmTm9kZXMgPSBbXTsKICAgICAgY29uc3QgdGVtcFF1ZSA9IFtdOwogICAgICBuZWVkTG9hZERpZk5vZGUuZm9yRWFjaCh2ID0+IHsKICAgICAgICBpZiAodi5fbGVmdENoaWxkID09PSBudWxsIHx8IHYuX3JpZ2h0Q2hpbGQgPT09IG51bGwpIHsKICAgICAgICAgIGNvbnNvbGUubG9nKHYpOwogICAgICAgICAgY29uc29sZS5sb2codGhpcyk7CiAgICAgICAgICBkZWJ1Z2dlcjsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGZpbmQgbmV4dCBsZXZlbCBub2RlIik7CiAgICAgICAgfQogICAgICAgIHRlbXBRdWUucHVzaCh2Ll9sZWZ0Q2hpbGQpOwogICAgICAgIHRlbXBRdWUucHVzaCh2Ll9yaWdodENoaWxkKTsKICAgICAgfSk7CiAgICAgIGNvbnN0IHByZUNvbEluZGV4ID0gW107CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcFF1ZS5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChjb2xJbmRleCA+PSBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoImNvbCBpbmRleCBvdXQgcmFuZ2UiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdHlwZSA9IG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5pc0NvbnRhaW4odGVtcFF1ZVtpXSk7CiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikgewogICAgICAgICAgdGVtcE5lZWRMb2FkRGlmTm9kZXMucHVzaCh0ZW1wUXVlW2ldKTsKICAgICAgICAgIHByZUNvbEluZGV4LnB1c2goY29sSW5kZXgpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIGktLTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigibm9kZSB0aW1lIGlzIGxpdHRsZSB0aGFuIGNvbCIpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocHJlQ29sSW5kZXgubGVuZ3RoICE9IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IG1lbW9yeSBpbmRleCIpOwogICAgICB9CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcE5lZWRMb2FkRGlmTm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBjb24xID0gY2FuQ3V0KHRlbXBOZWVkTG9hZERpZk5vZGVzW2ldLCBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0sIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0sICcnKTsKICAgICAgICAgIGlmIChjb24xKSB7CiAgICAgICAgICAgIHRlbXBOZWVkTG9hZERpZk5vZGVzLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgcHJlQ29sSW5kZXguc3BsaWNlKGksIDEpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBuZWVkTG9hZERpZk5vZGUgPSB0ZW1wTmVlZExvYWREaWZOb2RlczsKICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwICYmIG5lZWRMb2FkRGlmTm9kZVswXS5sZXZlbCA9PT0gdGhpcy5tYXhMZXZlbCAtIDEpIHsKICAgICAgICAvL2NvbnNvbGUubG9nKCJsYXN0IGxldmVsOiIsbmVlZExvYWREaWZOb2RlLmxlbmd0aCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkTG9hZERpZk5vZGUubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5hZGRMYXN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMF0pOwogICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVswXSk7CiAgICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uYWRkRmlyc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVszXSk7CiAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzNdKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPT09IDApIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogIH0KICBhc3luYyB2aWV3Q2hhbmdlSW50ZXJhY3Rpb24xV1MoY3VycmVudExldmVsLCB3aWR0aCwgdGltZVJhbmdlLCB5U2NhbGUsIHByb3BzKSB7CiAgICAvLyB3aGlsZSh0aGlzLmlzRXZpY3Rpbmcpe2NvbnNvbGUubG9nKCl9OwogICAgdGhpcy5pc0ludGVyaW5nID0gdHJ1ZTsKICAgIGNvbnN0IHRhZ05hbWUgPSAiIiArIE1hdGgucmFuZG9tKCkgKyAiIiArIE1hdGgucmFuZG9tKCk7CiAgICBhbGxUaW1lcyA9IFtdOwogICAgLy8gY29uc29sZS50aW1lKCJ2X2MiKQogICAgY29uc3Qgbm9uVW5pZm9ybUNvbE9ianMgPSBjb21wdXRlVGltZVNFKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgdGhpcy5yZWFsRGF0YVJvd051bSwgdGhpcy5tYXhMZXZlbCk7CiAgICBsZXQgbmVlZExvYWREaWZOb2RlID0gW107CiAgICBsZXQgY29sSW5kZXggPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBmaXJ0SW5kZXhUaW1lUmFuZ2UgPSB0aGlzLmdldEluZGV4VGltZShjdXJyZW50TGV2ZWwsIHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5sb2FkZWREYXRhUmFuZ2VbaV1bMF0sIHRoaXMubWF4TGV2ZWwpOwogICAgICBjb25zdCBsYXN0SW5kZXhUaW1lUmFuZ2UgPSB0aGlzLmdldEluZGV4VGltZShjdXJyZW50TGV2ZWwsIHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5sb2FkZWREYXRhUmFuZ2VbaV1bMV0sIHRoaXMubWF4TGV2ZWwpOwogICAgICBsZXQgcCA9IHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5maXJzdE5vZGVzW2ldOwogICAgICBpZiAoZmlydEluZGV4VGltZVJhbmdlLnN0YXJ0VCA8PSB0aW1lUmFuZ2VbMF0gJiYgbGFzdEluZGV4VGltZVJhbmdlLmVuZFQgPj0gdGltZVJhbmdlWzFdKSB7CiAgICAgICAgd2hpbGUgKHAgIT0gbnVsbCkgewogICAgICAgICAgaWYgKGNvbEluZGV4ID49IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoImNvbCBpbmRleCBvdXQgcmFuZ2UiKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNDb250YWluKHApOwogICAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHsKICAgICAgICAgICAgbmVlZExvYWREaWZOb2RlLnB1c2gocCk7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAzKSB7CiAgICAgICAgICAgIGNvbEluZGV4Kys7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDUpIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJlcnJvciBpbiB2aWV3Y2hhbmdlIik7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJub2RlIHRpbWUgaXMgbGl0dGxlIHRoYW4gY29sIik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA9PT0gMCkgewogICAgICBjb25zdCBzdW1UaW1lID0gYWxsVGltZXMucmVkdWNlKChwcmUsIGN1cikgPT4gcHJlICsgY3VyLCAwKTsKICAgICAgYWxsU3VtVGltZXMucHVzaChzdW1UaW1lKTsKICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxV1MoW10sIHRoaXMsICJlbXB0eSIpOwogICAgICBhbGxUaW1lcyA9IFtdOwogICAgICBpZiAoYWxsU3VtVGltZXMubGVuZ3RoID49IDUwKSB7CiAgICAgICAgY29uc29sZS5sb2coYWxsU3VtVGltZXMpOwogICAgICB9CiAgICAgIC8vZGVidWdnZXIKICAgICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogICAgfQogICAgbGV0IGxvc2VkRGF0YUluZm8gPSBjb21wdXRlTG9zZWREYXRhUmFuZ2VWMShuZWVkTG9hZERpZk5vZGUpOwogICAgaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID4gMCkgewogICAgICBjb25zdCBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxV1MobG9zZWREYXRhSW5mbywgdGhpcywgdGFnTmFtZSk7CiAgICAgIGFsbFRpbWVzLnB1c2gobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUpOwogICAgfQogICAgd2hpbGUgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwKSB7CiAgICAgIGNvbEluZGV4ID0gMDsKICAgICAgY29uc3QgdGVtcE5lZWRMb2FkRGlmTm9kZXMgPSBbXTsKICAgICAgY29uc3QgdGVtcFF1ZSA9IFtdOwogICAgICBuZWVkTG9hZERpZk5vZGUuZm9yRWFjaCh2ID0+IHsKICAgICAgICBpZiAodi5fbGVmdENoaWxkID09PSBudWxsIHx8IHYuX3JpZ2h0Q2hpbGQgPT09IG51bGwpIHsKICAgICAgICAgIGRlYnVnZ2VyOwogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZmluZCBuZXh0IGxldmVsIG5vZGUiKTsKICAgICAgICB9CiAgICAgICAgdGVtcFF1ZS5wdXNoKHYuX2xlZnRDaGlsZCk7CiAgICAgICAgdGVtcFF1ZS5wdXNoKHYuX3JpZ2h0Q2hpbGQpOwogICAgICAgIGNvbnN0IGxlZnRIYXMgPSB0aGlzLmxydUNhY2hlLmhhcyh2Ll9sZWZ0Q2hpbGQubGV2ZWwgKyAiXyIgKyB2Ll9sZWZ0Q2hpbGQuaW5kZXgpOwogICAgICAgIGNvbnN0IHJpZ2h0SGFzID0gdGhpcy5scnVDYWNoZS5oYXModi5fcmlnaHRDaGlsZC5sZXZlbCArICJfIiArIHYuX3JpZ2h0Q2hpbGQuaW5kZXgpOwogICAgICAgIC8vIGlmKCFsZWZ0SGFzKXsKICAgICAgICAvLyAgICAgY29uc29sZS5sb2coImZkZGRkZCIsdi5fbGVmdENoaWxkLmxldmVsKQogICAgICAgIC8vIH0KICAgICAgfSk7CiAgICAgIGNvbnN0IHByZUNvbEluZGV4ID0gW107CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcFF1ZS5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChjb2xJbmRleCA+PSBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoImNvbCBpbmRleCBvdXQgcmFuZ2UiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdHlwZSA9IG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5pc0NvbnRhaW4odGVtcFF1ZVtpXSk7CiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikgewogICAgICAgICAgdGVtcE5lZWRMb2FkRGlmTm9kZXMucHVzaCh0ZW1wUXVlW2ldKTsKICAgICAgICAgIHByZUNvbEluZGV4LnB1c2goY29sSW5kZXgpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIGktLTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigibm9kZSB0aW1lIGlzIGxpdHRsZSB0aGFuIGNvbCIpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocHJlQ29sSW5kZXgubGVuZ3RoICE9IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IG1lbW9yeSBpbmRleCIpOwogICAgICB9CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcE5lZWRMb2FkRGlmTm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBjb24xID0gY2FuQ3V0KHRlbXBOZWVkTG9hZERpZk5vZGVzW2ldLCBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0sIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0sIHlTY2FsZSk7CiAgICAgICAgICBpZiAoY29uMSkgewogICAgICAgICAgICB0ZW1wTmVlZExvYWREaWZOb2Rlcy5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgIHByZUNvbEluZGV4LnNwbGljZShpLCAxKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgLy90aGlzLmNoZWNrTW9ub3RvbmljaXR5KG5vblVuaWZvcm1Db2xPYmpzLHByZUNvbEluZGV4LHRlbXBOZWVkTG9hZERpZk5vZGVzKTsKICAgICAgbmVlZExvYWREaWZOb2RlID0gdGVtcE5lZWRMb2FkRGlmTm9kZXM7CiAgICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID4gMCAmJiBuZWVkTG9hZERpZk5vZGVbMF0ubGV2ZWwgPT09IHRoaXMubWF4TGV2ZWwgLSAxKSB7CiAgICAgICAgLy9jb25zb2xlLmxvZygibGFzdCBsZXZlbDoiLG5lZWRMb2FkRGlmTm9kZS5sZW5ndGgpOwogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZExvYWREaWZOb2RlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uYWRkTGFzdFZhbChuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzBdKTsKICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5mb3JjZU1lcmdlKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMF0pOwogICAgICAgICAgaWYgKHByZUNvbEluZGV4W2ldICsgMSA8IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmFkZEZpcnN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbM10pOwogICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVszXSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgbGV0IGxvc2VkRGF0YUluZm8gPSBjb21wdXRlTG9zZWREYXRhUmFuZ2VWMShuZWVkTG9hZERpZk5vZGUpOwogICAgICBpZiAobG9zZWREYXRhSW5mby5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7CiAgICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxV1MobG9zZWREYXRhSW5mbywgdGhpcywgdGFnTmFtZSk7CiAgICAgICAgYWxsVGltZXMucHVzaChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSk7CiAgICAgIH0KICAgIH0KICAgIGlmIChwcm9wcyAmJiBwcm9wcy5yb290VCkgewogICAgICBjb25zb2xlLmxvZygicm9vdHQ6IiwgcHJvcHMucm9vdFQpOwogICAgICBhbGxUaW1lcy5wdXNoKHByb3BzLnJvb3RUKTsKICAgIH0KICAgIC8vY29uc29sZS5sb2coYWxsVGltZXMpCiAgICBjb25zdCBzdW1UaW1lID0gYWxsVGltZXMucmVkdWNlKChwcmUsIGN1cikgPT4gcHJlICsgY3VyLCAwKTsKICAgIGFsbFN1bVRpbWVzLnB1c2goc3VtVGltZSk7CiAgICBpZiAoYWxsU3VtVGltZXMubGVuZ3RoID09PSA2KSB7CiAgICAgIHB1c2hUaW1lQXJyYXkoYWxsU3VtVGltZXMpOwogICAgICBhbGxTdW1UaW1lcyA9IFtdOwogICAgfQogICAgY29uc29sZS5sb2coIkFsbExldmVsVGltZToiLCBhbGxTdW1UaW1lcyk7CiAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDFXUyhsb3NlZERhdGFJbmZvLCB0aGlzLCAiZW1wdHkiKTsKICAgIHRoaXMuaXNJbnRlcmluZyA9IGZhbHNlOwogICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogIH0KICBhc3luYyB2aWV3Q2hhbmdlSW50ZXJhY3Rpb25GaW5hbChjdXJyZW50TGV2ZWwsIHdpZHRoLCB0aW1lUmFuZ2UsIHlTY2FsZSkgewogICAgY29uc29sZS5sb2coY3VycmVudExldmVsLCB3aWR0aCwgdGltZVJhbmdlKTsKICAgIGNvbnN0IGRhdGFOYW1lID0gdGhpcy5kYXRhTmFtZS5pbmNsdWRlcygiLiIpID8gdGhpcy5kYXRhTmFtZS5zcGxpdCgiLiIpWzFdIDogdGhpcy5kYXRhTmFtZTsKICAgIGNvbnN0IGN1cnJlbnRGbGFnSW5mbyA9IHN0b3JlLnN0YXRlLmFsbEZsYWdzW3RoaXMuZGF0YU5hbWVdOwogICAgaWYgKGN1cnJlbnRGbGFnSW5mbyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmRhdGFOYW1lICsgImdldCBmbGFnIGZhaWxkIik7CiAgICB9IGVsc2UgewogICAgICBjb25zb2xlLmxvZygiZmxhZyBsZW5ndGg6IiwgY3VycmVudEZsYWdJbmZvLmxlbmd0aCk7CiAgICB9CiAgICBhbGxUaW1lcyA9IFtdOwogICAgLy8gY29uc29sZS50aW1lKCJ2X2MiKQogICAgY29uc3Qgbm9uVW5pZm9ybUNvbE9ianMgPSBjb21wdXRlVGltZVNFKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgdGhpcy5yZWFsRGF0YVJvd051bSwgdGhpcy5tYXhMZXZlbCk7CiAgICBsZXQgbmVlZExvYWREaWZOb2RlID0gW107CiAgICBsZXQgY29sSW5kZXggPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBmaXJ0SW5kZXhUaW1lUmFuZ2UgPSB0aGlzLmdldEluZGV4VGltZShjdXJyZW50TGV2ZWwsIHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5sb2FkZWREYXRhUmFuZ2VbaV1bMF0sIHRoaXMubWF4TGV2ZWwpOwogICAgICBjb25zdCBsYXN0SW5kZXhUaW1lUmFuZ2UgPSB0aGlzLmdldEluZGV4VGltZShjdXJyZW50TGV2ZWwsIHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5sb2FkZWREYXRhUmFuZ2VbaV1bMV0sIHRoaXMubWF4TGV2ZWwpOwogICAgICBsZXQgcCA9IHRoaXMubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5maXJzdE5vZGVzW2ldOwogICAgICBpZiAoZmlydEluZGV4VGltZVJhbmdlLnN0YXJ0VCA8PSB0aW1lUmFuZ2VbMF0gJiYgbGFzdEluZGV4VGltZVJhbmdlLmVuZFQgPj0gdGltZVJhbmdlWzFdKSB7CiAgICAgICAgd2hpbGUgKHAgIT0gbnVsbCkgewogICAgICAgICAgaWYgKGNvbEluZGV4ID49IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoImNvbCBpbmRleCBvdXQgcmFuZ2UiKTsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNNaXNzQ29udGFpbihwKTsKICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5jb250YWluQ29sdW1uUmFuZ2UocCwgdHlwZSk7CiAgICAgICAgICBpZiAodHlwZSA9PT0gMSkgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikgewogICAgICAgICAgICBuZWVkTG9hZERpZk5vZGUucHVzaChwKTsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHsKICAgICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNSkgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNikgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImVycm9yIGluIHZpZXdjaGFuZ2UiKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoIm5vZGUgdGltZSBpcyBsaXR0bGUgdGhhbiBjb2wiKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBub25Vbmlmb3JtQ29sT2JqczsKICAgIH0KICAgIGxldCBsb3NlZERhdGFJbmZvID0gY29tcHV0ZUxvc2VkRGF0YVJhbmdlVjEobmVlZExvYWREaWZOb2RlKTsKICAgIGlmIChsb3NlZERhdGFJbmZvLmxlbmd0aCA+IDApIHsKICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxTWluTWF4TWlzcyhsb3NlZERhdGFJbmZvLCB0aGlzKTsKICAgIH0KICAgIHdoaWxlIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID4gMCkgewogICAgICBjb2xJbmRleCA9IDA7CiAgICAgIGNvbnN0IHRlbXBOZWVkTG9hZERpZk5vZGVzID0gW107CiAgICAgIGNvbnN0IHRlbXBRdWUgPSBbXTsKICAgICAgbmVlZExvYWREaWZOb2RlLmZvckVhY2godiA9PiB7CiAgICAgICAgaWYgKHYuX2xlZnRDaGlsZCA9PT0gbnVsbCB8fCB2Ll9yaWdodENoaWxkID09PSBudWxsKSB7CiAgICAgICAgICBjb25zb2xlLmxvZyh2KTsKICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMpOwogICAgICAgICAgZGVidWdnZXI7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBmaW5kIG5leHQgbGV2ZWwgbm9kZSIpOwogICAgICAgIH0KICAgICAgICB0aGlzLmxydUNhY2hlLmhhcyh2Ll9sZWZ0Q2hpbGQubGV2ZWwgKyAiXyIgKyB2Ll9sZWZ0Q2hpbGQuaW5kZXgpOwogICAgICAgIHRoaXMubHJ1Q2FjaGUuaGFzKHYuX3JpZ2h0Q2hpbGQubGV2ZWwgKyAiXyIgKyB2Ll9yaWdodENoaWxkLmluZGV4KTsKICAgICAgICBpZiAodi5fbGVmdENoaWxkLm5vZGVUeXBlICE9PSAnTlVMTCcpIHsKICAgICAgICAgIHRlbXBRdWUucHVzaCh2Ll9sZWZ0Q2hpbGQpOwogICAgICAgIH0KICAgICAgICBpZiAodi5fcmlnaHRDaGlsZC5ub2RlVHlwZSAhPT0gJ05VTEwnKSB7CiAgICAgICAgICB0ZW1wUXVlLnB1c2godi5fcmlnaHRDaGlsZCk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgLy8gbG9hZGVkRGF0YVNpemUgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDUwMCAtIDAgKyAxKSkgKyA1MDA7CiAgICAgIGNvbnN0IHByZUNvbEluZGV4ID0gW107CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcFF1ZS5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChjb2xJbmRleCA+PSBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoImNvbCBpbmRleCBvdXQgcmFuZ2UiKTsKICAgICAgICB9CiAgICAgICAgY29uc3QgdHlwZSA9IG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5pc01pc3NDb250YWluKHRlbXBRdWVbaV0pOwogICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5jb250YWluQ29sdW1uUmFuZ2UodGVtcFF1ZVtpXSwgdHlwZSk7CiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikgewogICAgICAgICAgdGVtcE5lZWRMb2FkRGlmTm9kZXMucHVzaCh0ZW1wUXVlW2ldKTsKICAgICAgICAgIHByZUNvbEluZGV4LnB1c2goY29sSW5kZXgpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIGktLTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigibm9kZSB0aW1lIGlzIGxpdHRsZSB0aGFuIGNvbCIpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocHJlQ29sSW5kZXgubGVuZ3RoICE9IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IG1lbW9yeSBpbmRleCIpOwogICAgICB9CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcE5lZWRMb2FkRGlmTm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBjb24xID0gY2FuQ3V0KHRlbXBOZWVkTG9hZERpZk5vZGVzW2ldLCBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0sIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0sIHlTY2FsZSk7CiAgICAgICAgICBpZiAoY29uMSkgewogICAgICAgICAgICB0ZW1wTmVlZExvYWREaWZOb2Rlcy5zcGxpY2UoaSwgMSk7CiAgICAgICAgICAgIHByZUNvbEluZGV4LnNwbGljZShpLCAxKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgLy90aGlzLmNoZWNrTW9ub3RvbmljaXR5KG5vblVuaWZvcm1Db2xPYmpzLHByZUNvbEluZGV4LHRlbXBOZWVkTG9hZERpZk5vZGVzKTsKICAgICAgbmVlZExvYWREaWZOb2RlID0gdGVtcE5lZWRMb2FkRGlmTm9kZXM7CiAgICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID4gMCAmJiBuZWVkTG9hZERpZk5vZGVbMF0ubGV2ZWwgPT09IHRoaXMubWF4TGV2ZWwgLSAxKSB7CiAgICAgICAgY29uc29sZS5sb2coImxhc3QgbGV2ZWw6IiwgbmVlZExvYWREaWZOb2RlLmxlbmd0aCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkTG9hZERpZk5vZGUubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNvbnN0IG5vZGVGbGFnMSA9IGN1cnJlbnRGbGFnSW5mb1syICogbmVlZExvYWREaWZOb2RlW2ldLmluZGV4XTsKICAgICAgICAgIGlmIChub2RlRmxhZzEgPT09IDEpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJmbGFnIGVycm9yIik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBub2RlRmxhZzIgPSBjdXJyZW50RmxhZ0luZm9bMiAqIG5lZWRMb2FkRGlmTm9kZVtpXS5pbmRleCArIDFdOwogICAgICAgICAgaWYgKG5vZGVGbGFnMiA9PT0gMCkgewogICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uYWRkTGFzdFZhbChuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdKTsKICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXSk7CiAgICAgICAgICAgIGlmIChwcmVDb2xJbmRleFtpXSArIDEgPCBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmFkZEZpcnN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl0pOwogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzJdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXSk7CiAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5mb3JjZU1lcmdlKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl0pOwogICAgICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5hZGRGaXJzdFZhbChuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPT09IDApIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBsZXQgbG9zZWREYXRhSW5mbyA9IGNvbXB1dGVMb3NlZERhdGFSYW5nZVYxKG5lZWRMb2FkRGlmTm9kZSk7CiAgICAgIGlmIChsb3NlZERhdGFJbmZvLmxlbmd0aCA+IDApIHsKICAgICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDFNaW5NYXhNaXNzKGxvc2VkRGF0YUluZm8sIHRoaXMpOwogICAgICB9CiAgICB9CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aDsgaSsrKSB7CiAgICAgIG5vblVuaWZvcm1Db2xPYmpzW2ldLmNoZWNrSXNNaXMoKTsKICAgIH0KICAgIHJldHVybiBub25Vbmlmb3JtQ29sT2JqczsKICB9CiAgYXN5bmMgdmlld0NoYW5nZUludGVyYWN0aW9uRmluYWwxKGN1cnJlbnRMZXZlbCwgd2lkdGgsIHRpbWVSYW5nZSwgeVNjYWxlLCBkcmF3ZXIpIHsKICAgIGNvbnN0IGN1cnJlbnRGbGFnSW5mbyA9IGdldEZsYWcodGhpcy5kYXRhTmFtZSk7CiAgICAvLyBjb25zdCBjdXJyZW50RmxhZ0luZm8gPSBnZXRGbGFnKCJtb2NrX2d1YXNzaWFuX3Npbl84bV9vbTNfOG0iKTsKICAgIGlmIChjdXJyZW50RmxhZ0luZm8gPT09IHVuZGVmaW5lZCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5kYXRhTmFtZSArICIgZ2V0IGZsYWcgZmFpbGQiKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIGNvbnNvbGUubG9nKCJmbGFnIGxlbmd0aDoiLCBjdXJyZW50RmxhZ0luZm8ubGVuZ3RoKQogICAgfQogICAgYWxsVGltZXMgPSBbXTsKICAgIC8vIGNvbnNvbGUudGltZSgidl9jIikKICAgIGxldCBsb2FkZWREYXRhU2l6ZSA9IDA7CiAgICBsZXQgc2l6ZSA9IDE7CiAgICBjb25zdCBub25Vbmlmb3JtQ29sT2JqcyA9IGNvbXB1dGVUaW1lU0UoY3VycmVudExldmVsLCB3aWR0aCwgdGltZVJhbmdlLCB0aGlzLnJlYWxEYXRhUm93TnVtLCB0aGlzLm1heExldmVsKTsKICAgIGxldCBuZWVkTG9hZERpZk5vZGUgPSBbXTsKICAgIGxldCBjb2xJbmRleCA9IDA7CiAgICBsb2FkZWREYXRhU2l6ZSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoNTAwIC0gMCArIDEpKSArIDUwMDsKICAgIGxldCBzdGFydFQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZXZlbEluZGV4T2Jqc1tjdXJyZW50TGV2ZWxdLmZpcnN0Tm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgZmlydEluZGV4VGltZVJhbmdlID0gdGhpcy5nZXRJbmRleFRpbWUoY3VycmVudExldmVsLCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0ubG9hZGVkRGF0YVJhbmdlW2ldWzBdLCB0aGlzLm1heExldmVsKTsKICAgICAgY29uc3QgbGFzdEluZGV4VGltZVJhbmdlID0gdGhpcy5nZXRJbmRleFRpbWUoY3VycmVudExldmVsLCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0ubG9hZGVkRGF0YVJhbmdlW2ldWzFdLCB0aGlzLm1heExldmVsKTsKICAgICAgbGV0IHAgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlc1tpXTsKICAgICAgaWYgKGZpcnRJbmRleFRpbWVSYW5nZS5zdGFydFQgPD0gdGltZVJhbmdlWzBdICYmIGxhc3RJbmRleFRpbWVSYW5nZS5lbmRUID49IHRpbWVSYW5nZVsxXSkgewogICAgICAgIHdoaWxlIChwICE9IG51bGwpIHsKICAgICAgICAgIGlmIChjb2xJbmRleCA+PSBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJjb2wgaW5kZXggb3V0IHJhbmdlIik7CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCB0eXBlID0gbm9uVW5pZm9ybUNvbE9ianNbY29sSW5kZXhdLmlzTWlzc0NvbnRhaW4ocCk7CiAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uY29udGFpbkNvbHVtblJhbmdlKHAsIHR5cGUpOwogICAgICAgICAgaWYgKHR5cGUgPT09IDEpIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIgfHwgdHlwZSA9PT0gNyB8fCB0eXBlID09PSA4IHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTApIHsKICAgICAgICAgICAgaWYgKHR5cGUgPT09IDIpIHsKICAgICAgICAgICAgICBuZWVkTG9hZERpZk5vZGUucHVzaChwKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHlwZSA9PT0gNyB8fCB0eXBlID09PSA5KSB7CiAgICAgICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgICAgfQogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgICBjb2xJbmRleCsrOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJub2RlIHRpbWUgaXMgbGl0dGxlIHRoYW4gY29sIik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGRlYnVnZ2VyOwogICAgICB9CiAgICB9CiAgICAvLyBkZWJ1Z2dlcgogICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogICAgfQogICAgbG9hZGVkRGF0YVNpemUgKz0gbmVlZExvYWREaWZOb2RlLmxlbmd0aCAqIHNpemU7CiAgICBsZXQgbG9zZWREYXRhSW5mbyA9IGNvbXB1dGVMb3NlZERhdGFSYW5nZVYxKG5lZWRMb2FkRGlmTm9kZSk7CiAgICAvLyBkZWJ1Z2dlcgogICAgaWYgKGxvc2VkRGF0YUluZm8ubGVuZ3RoID4gMCkgewogICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDFNaW5NYXhNaXNzKGxvc2VkRGF0YUluZm8sIHRoaXMpOwogICAgfQogICAgd2hpbGUgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwICYmIG5lZWRMb2FkRGlmTm9kZVswXS5sZXZlbCA8IDE2KSB7CiAgICAgIGNvbEluZGV4ID0gMDsKICAgICAgY29uc3QgdGVtcE5lZWRMb2FkRGlmTm9kZXMgPSBbXTsKICAgICAgY29uc3QgdGVtcFF1ZSA9IFtdOwogICAgICBuZWVkTG9hZERpZk5vZGUuZm9yRWFjaCh2ID0+IHsKICAgICAgICBpZiAoKHYuX2xlZnRDaGlsZCA9PT0gbnVsbCB8fCB2Ll9yaWdodENoaWxkID09PSBudWxsKSAmJiB2Lm5vZGVUeXBlID09PSAnTycpIHsKICAgICAgICAgIC8vIGlmICgodi5fbGVmdENoaWxkICE9IG51bGwgJiYgdi5fcmlnaHRDaGlsZCAhPSBudWxsKSAmJiB2Lm5vZGVUeXBlID09PSAnTycpIHsKICAgICAgICAgIC8vIGRlYnVnZ2VyCiAgICAgICAgICBjb25zb2xlLmxvZyh2LmxldmVsKTsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IGZpbmQgbmV4dCBsZXZlbCBub2RlIik7CiAgICAgICAgfQogICAgICAgIGlmICh2Lm5vZGVUeXBlID09PSAnTlVMTCcpIHsKICAgICAgICAgIC8vCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMubHJ1Q2FjaGUuaGFzKHYuX2xlZnRDaGlsZC5sZXZlbCArICJfIiArIHYuX2xlZnRDaGlsZC5pbmRleCk7CiAgICAgICAgICB0aGlzLmxydUNhY2hlLmhhcyh2Ll9yaWdodENoaWxkLmxldmVsICsgIl8iICsgdi5fcmlnaHRDaGlsZC5pbmRleCk7CiAgICAgICAgICBpZiAodi5fbGVmdENoaWxkLm5vZGVUeXBlICE9PSAnTlVMTCcpIHsKICAgICAgICAgICAgdGVtcFF1ZS5wdXNoKHYuX2xlZnRDaGlsZCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodi5fcmlnaHRDaGlsZC5ub2RlVHlwZSAhPT0gJ05VTEwnKSB7CiAgICAgICAgICAgIHRlbXBRdWUucHVzaCh2Ll9yaWdodENoaWxkKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0pOwogICAgICBjb25zdCBwcmVDb2xJbmRleCA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBRdWUubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAoY29sSW5kZXggPj0gbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJjb2wgaW5kZXggb3V0IHJhbmdlIik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNNaXNzQ29udGFpbih0ZW1wUXVlW2ldKTsKICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uY29udGFpbkNvbHVtblJhbmdlKHRlbXBRdWVbaV0sIHR5cGUpOwogICAgICAgIGlmICh0eXBlID09PSAxKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIgfHwgdHlwZSA9PT0gNyB8fCB0eXBlID09PSA4IHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTApIHsKICAgICAgICAgIGlmICh0eXBlID09PSAyKSB7CiAgICAgICAgICAgIHRlbXBOZWVkTG9hZERpZk5vZGVzLnB1c2godGVtcFF1ZVtpXSk7CiAgICAgICAgICAgIHByZUNvbEluZGV4LnB1c2goY29sSW5kZXgpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIGktLTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigibm9kZSB0aW1lIGlzIGxpdHRsZSB0aGFuIGNvbCIpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocHJlQ29sSW5kZXgubGVuZ3RoICE9IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IG1lbW9yeSBpbmRleCIpOwogICAgICB9CiAgICAgIG5lZWRMb2FkRGlmTm9kZSA9IHRlbXBOZWVkTG9hZERpZk5vZGVzOwogICAgICBsb2FkZWREYXRhU2l6ZSArPSBuZWVkTG9hZERpZk5vZGUubGVuZ3RoICogc2l6ZTsKICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwICYmIG5lZWRMb2FkRGlmTm9kZVswXS5sZXZlbCA9PT0gdGhpcy5tYXhMZXZlbCAtIDEpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRMb2FkRGlmTm9kZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgY29uc3Qgbm9kZUZsYWcyID0gY3VycmVudEZsYWdJbmZvWzIgKiBuZWVkTG9hZERpZk5vZGVbaV0uaW5kZXggKyAxXTsKICAgICAgICAgIGlmIChuZWVkTG9hZERpZk5vZGVbaV0uZ2FwRmxhZyA9PT0gJ05PJykgewogICAgICAgICAgICBpZiAobm9kZUZsYWcyID09PSAwKSB7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXSwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdKTsKICAgICAgICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmFkZEZpcnN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl0sIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5hZGRMYXN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl0sIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXSk7CiAgICAgICAgICAgICAgaWYgKHByZUNvbEluZGV4W2ldICsgMSA8IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5hZGRGaXJzdFZhbChuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdLCBuZWVkTG9hZERpZk5vZGVbaV0pOwogICAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5mb3JjZU1lcmdlKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMV0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKG5vZGVGbGFnMiA9PT0gMCkgewogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5hZGRMYXN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMV0sIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZEZpcnN0VmFsKG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl0sIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXSwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzJdKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uYWRkRmlyc3RWYWwobmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXSwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZiAoc3RvcmUuc3RhdGUuY29udHJvbFBhcmFtcy5wcm9ncmVzc2l2ZSAmJiBkcmF3ZXIpIHsKICAgICAgICBkcmF3ZXIobm9uVW5pZm9ybUNvbE9ianMsICJwcm9ncmVzc2l2ZSIpOwogICAgICB9CiAgICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgbGV0IGxvc2VkRGF0YUluZm8gPSBjb21wdXRlTG9zZWREYXRhUmFuZ2VWMShuZWVkTG9hZERpZk5vZGUpOwogICAgICAvLyBjb25zb2xlLmxvZygiMSIpOwogICAgICBpZiAobG9zZWREYXRhSW5mby5sZW5ndGggPiAwKSB7CiAgICAgICAgLy8gY29uc29sZS5sb2coMyk7CiAgICAgICAgYXdhaXQgYmF0Y2hMb2FkRGF0YUZvclJhbmdlTGV2ZWwxTWluTWF4TWlzcyhsb3NlZERhdGFJbmZvLCB0aGlzKTsKICAgICAgfQogICAgICAvLyBjb25zb2xlLmxvZygiMiIpOwogICAgfQogICAgLy8gY29uc29sZS5sb2coIlRoZSB0aW1lIHRvIGdldCBhbGwgY29lZmZpY2llbnRzOiIgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFQpKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoOyBpKyspIHsKICAgICAgbm9uVW5pZm9ybUNvbE9ianNbaV0uY2hlY2tJc01pcygpOwogICAgfQogICAgLy8gY29uc29sZS5sb2coIkxvYWRlZCBEYXRhIFNpemU6IiwgbG9hZGVkRGF0YVNpemUpOwogICAgcmV0dXJuIG5vblVuaWZvcm1Db2xPYmpzOwogIH0KICBhc3luYyB2aWV3VHJhbnNmb3JtRmluYWwob3RoZXJEYXRhTWFuYWdlciwgY3VycmVudExldmVsLCB3aWR0aCwgdGltZVJhbmdlLCB5U2NhbGUsIGRyYXdlciwgdHJhbnNmb3JtX3N5bWJvbCkgewogICAgY29uc3QgY3VycmVudEZsYWdJbmZvID0gZ2V0RmxhZyh0aGlzLmRhdGFOYW1lKTsKICAgIC8vIGNvbnN0IGN1cnJlbnRGbGFnSW5mbyA9IGdldEZsYWcoImN1c3RvbV9udW1iZXI4X3Rlc3QyX29tM190ZXN0LmZsYWd6Iik7CiAgICBpZiAoY3VycmVudEZsYWdJbmZvID09PSB1bmRlZmluZWQpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZGF0YU5hbWUgKyAiIGdldCBmbGFnIGZhaWxkIik7CiAgICB9IGVsc2UgewogICAgICAvLyBjb25zb2xlLmxvZygiZmxhZyBpbmZvOiIsIGN1cnJlbnRGbGFnSW5mbyk7CiAgICAgIC8vIGNvbnNvbGUubG9nKCJmbGFnIGxlbmd0aDoiLCBjdXJyZW50RmxhZ0luZm8ubGVuZ3RoKQogICAgfQogICAgY29uc3QgY3VycmVudEZsYWdJbmZvMiA9IFtdOwogICAgY29uc3QgZGF0YU5hbWVzID0gW107CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyRGF0YU1hbmFnZXIubGVuZ3RoOyArK2kpIHsKICAgICAgY3VycmVudEZsYWdJbmZvMi5wdXNoKGdldEZsYWcob3RoZXJEYXRhTWFuYWdlcltpXS5kYXRhTmFtZSkpOwogICAgICBkYXRhTmFtZXMucHVzaChvdGhlckRhdGFNYW5hZ2VyW2ldLmRhdGFOYW1lKTsKICAgICAgLy8gY29uc3QgY3VycmVudEZsYWdJbmZvMiA9IGdldEZsYWcoImN1c3RvbV9udW1iZXI4X3Rlc3QxX29tM190ZXN0LmZsYWd6Iik7CiAgICAgIGlmIChjdXJyZW50RmxhZ0luZm8yW2ldID09PSB1bmRlZmluZWQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3RoZXJEYXRhTWFuYWdlcltpXS5kYXRhTmFtZSArICIgZ2V0IGZsYWcgZmFpbGQiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBjb25zb2xlLmxvZygiZmxhZzIgaW5mbzoiLCBjdXJyZW50RmxhZ0luZm8yW2ldKTsKICAgICAgICAvLyBjb25zb2xlLmxvZygiZmxhZzIgbGVuZ3RoOiIsIGN1cnJlbnRGbGFnSW5mbzJbaV0ubGVuZ3RoKQogICAgICB9CiAgICB9CiAgICAvLyBjb25zdCBjdXJyZW50RmxhZ0luZm8gPSBbMCwxLDEsMCwxLDAsMCwxXTsKICAgIC8vIGNvbnN0IGN1cnJlbnRGbGFnSW5mbzIgPSBbMCwxLDAsMSwwLDEsMCwxXTsKICAgIGFsbFRpbWVzID0gW107CiAgICBjb25zdCBub25Vbmlmb3JtQ29sT2JqcyA9IGNvbXB1dGVUaW1lU0UoY3VycmVudExldmVsLCB3aWR0aCwgdGltZVJhbmdlLCB0aGlzLnJlYWxEYXRhUm93TnVtLCB0aGlzLm1heExldmVsKTsKICAgIGxldCBuZWVkTG9hZERpZk5vZGUgPSBbXTsKICAgIGxldCBuZWVkTG9hZERpZk5vZGUyID0gbmV3IEFycmF5KG90aGVyRGF0YU1hbmFnZXIubGVuZ3RoKS5maWxsKFtdKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpOwogICAgbGV0IGNvbEluZGV4ID0gMDsKICAgIGxldCBjb3VudF9vYmogPSB7CiAgICAgIGNvdW50OiAwCiAgICB9OwogICAgbGV0IHRvdGFsX3RpbWUgPSAwOwogICAgbGV0IHN0YXJ0VCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOwogICAgLy/lgYforr7lr7nkuo5kYXRhc2V0MQogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlcy5sZW5ndGg7ICsraSkgewogICAgICBjb25zdCBmaXJzdEluZGV4VGltZVJhbmdlID0gdGhpcy5nZXRJbmRleFRpbWUoY3VycmVudExldmVsLCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0ubG9hZGVkRGF0YVJhbmdlW2ldWzBdLCB0aGlzLm1heExldmVsKTsKICAgICAgY29uc3QgbGFzdEluZGV4VGltZVJhbmdlID0gdGhpcy5nZXRJbmRleFRpbWUoY3VycmVudExldmVsLCB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0ubG9hZGVkRGF0YVJhbmdlW2ldWzFdLCB0aGlzLm1heExldmVsKTsKICAgICAgbGV0IHAgPSB0aGlzLmxldmVsSW5kZXhPYmpzW2N1cnJlbnRMZXZlbF0uZmlyc3ROb2Rlc1tpXTsKICAgICAgbGV0IHAyID0gW107CiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgb3RoZXJEYXRhTWFuYWdlci5sZW5ndGg7ICsraykgewogICAgICAgIHAyLnB1c2gob3RoZXJEYXRhTWFuYWdlcltrXS5sZXZlbEluZGV4T2Jqc1tjdXJyZW50TGV2ZWxdLmZpcnN0Tm9kZXNbaV0pOwogICAgICB9CiAgICAgIC8vIGxldCBwMiA9IG90aGVyRGF0YU1hbmFnZXIubGV2ZWxJbmRleE9ianNbY3VycmVudExldmVsXS5maXJzdE5vZGVzW2ldOy8v5rWL6K+VCiAgICAgIGxldCBkYXRhOwogICAgICBsZXQgcmVzQ2hpbGQ7CiAgICAgIGlmIChmaXJzdEluZGV4VGltZVJhbmdlLnN0YXJ0VCA8PSB0aW1lUmFuZ2VbMF0gJiYgbGFzdEluZGV4VGltZVJhbmdlLmVuZFQgPj0gdGltZVJhbmdlWzFdKSB7CiAgICAgICAgd2hpbGUgKHAgIT0gbnVsbCkgewogICAgICAgICAgaWYgKGNvbEluZGV4ID49IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNNaXNzQ29udGFpbihwKTsKICAgICAgICAgIGxldCBwMl90ZW1wID0gcDIuc2xpY2UoKTsKICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5jb250YWluQ29sdW1uUmFuZ2UyKHAsIHAyX3RlbXAsIHR5cGUsIHRyYW5zZm9ybV9zeW1ib2wpOwogICAgICAgICAgbGV0IHN0YXJ0X3QgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5jb21wdXRlVHJhbnNmb3JtKHAsIHAyX3RlbXAsIHR5cGUsIGN1cnJlbnRGbGFnSW5mbywgY3VycmVudEZsYWdJbmZvMiwgdHJhbnNmb3JtX3N5bWJvbCwgY291bnRfb2JqKTsKICAgICAgICAgIGxldCBlbmRfdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOwogICAgICAgICAgdG90YWxfdGltZSArPSBlbmRfdCAtIHN0YXJ0X3Q7CiAgICAgICAgICAvLyBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uY29tcHV0ZVRyYW5zZm9ybShwLCBwMl90ZW1wLHRoaXMuZGF0YU5hbWUsIGRhdGFOYW1lcywgdGhpcywgb3RoZXJEYXRhTWFuYWdlciwgdHlwZSwgY3VycmVudEZsYWdJbmZvLCBjdXJyZW50RmxhZ0luZm8yLCB0cmFuc2Zvcm1fc3ltYm9sKTsKICAgICAgICAgIGlmICh0eXBlID09PSAxKSB7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG90aGVyRGF0YU1hbmFnZXIubGVuZ3RoOyArK2spIHsKICAgICAgICAgICAgICBwMltrXSA9IHAyW2tdLm5leHRTaWJsaW5nOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHsKICAgICAgICAgICAgbmVlZExvYWREaWZOb2RlLnB1c2gocCk7CiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgb3RoZXJEYXRhTWFuYWdlci5sZW5ndGg7ICsraykgewogICAgICAgICAgICAgIG5lZWRMb2FkRGlmTm9kZTJba10ucHVzaChwMltrXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gbmVlZExvYWREaWZOb2RlMi5wdXNoKHAyKTsKICAgICAgICAgICAgcCA9IHAubmV4dFNpYmxpbmc7CiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgb3RoZXJEYXRhTWFuYWdlci5sZW5ndGg7ICsraykgewogICAgICAgICAgICAgIHAyW2tdID0gcDJba10ubmV4dFNpYmxpbmc7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgICBjb2xJbmRleCsrOwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7CiAgICAgICAgICAgIHAgPSBwLm5leHRTaWJsaW5nOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG90aGVyRGF0YU1hbmFnZXIubGVuZ3RoOyArK2spIHsKICAgICAgICAgICAgICBwMltrXSA9IHAyW2tdLm5leHRTaWJsaW5nOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCJlcnJvciBpbiB2aWV3Y2hhbmdlIikKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwID0gcC5uZXh0U2libGluZzsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBvdGhlckRhdGFNYW5hZ2VyLmxlbmd0aDsgKytrKSB7CiAgICAgICAgICAgICAgcDJba10gPSBwMltrXS5uZXh0U2libGluZzsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcigibm9kZSB0aW1lIGlzIGxpdHRsZSB0aGFuIGNvbCIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICAvLyBjb25zb2xlLmxvZygiY291bnQ6IiwgY291bnRfb2JqLmNvdW50KTsKICAgIH0KICAgIGlmIChuZWVkTG9hZERpZk5vZGUubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBub25Vbmlmb3JtQ29sT2JqczsKICAgIH0KICAgIC8vIGxldCBsb3NlZERhdGFJbmZvID0gY29tcHV0ZUxvc2VkRGF0YVJhbmdlVjEobmVlZExvYWREaWZOb2RlKTsKICAgIC8vIGlmIChsb3NlZERhdGFJbmZvLmxlbmd0aCA+IDApIHsKICAgIC8vICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDFNaW5NYXhNaXNzKGxvc2VkRGF0YUluZm8sIHRoaXMpOyAgLy/lj5blvpfns7vmlbAKICAgIC8vICAgICBmb3IobGV0IGk9MDsgaTxvdGhlckRhdGFNYW5hZ2VyLmxlbmd0aDsgaSsrKQogICAgLy8gICAgICAgICBhd2FpdCBiYXRjaExvYWREYXRhRm9yUmFuZ2VMZXZlbDFNaW5NYXhNaXNzKGxvc2VkRGF0YUluZm8sIG90aGVyRGF0YU1hbmFnZXJbaV0pOwogICAgLy8gfQogICAgd2hpbGUgKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPiAwKSB7CiAgICAgIC8v5aaC5p6c6ZyA6KaB57un57ut5ZCR5LiL6I635Y+W57O75pWw77yM5YiZ5LiA55u05ZCR5LiL5p+l6K+i77yM55u05Yiw5pyA5ZCO5LiA5bGCCiAgICAgIGNvbEluZGV4ID0gMDsKICAgICAgY29uc3QgdGVtcE5lZWRMb2FkRGlmTm9kZXMgPSBbXTsKICAgICAgY29uc3QgdGVtcFF1ZSA9IFtdOwogICAgICBjb25zdCB0ZW1wTmVlZExvYWREaWZOb2RlczIgPSBuZXcgQXJyYXkob3RoZXJEYXRhTWFuYWdlci5sZW5ndGgpLmZpbGwoW10pLm1hcCgoKSA9PiBuZXcgQXJyYXkoKSk7CiAgICAgIGNvbnN0IHRlbXBRdWUyID0gbmV3IEFycmF5KG90aGVyRGF0YU1hbmFnZXIubGVuZ3RoKS5maWxsKFtdKS5tYXAoKCkgPT4gbmV3IEFycmF5KCkpOwogICAgICBuZWVkTG9hZERpZk5vZGUuZm9yRWFjaCh2ID0+IHsKICAgICAgICAvLyBpZiAodi5fbGVmdENoaWxkID09PSBudWxsIHx8IHYuX3JpZ2h0Q2hpbGQgPT09IG51bGwpIHsKICAgICAgICAvLyAgICAgY29uc29sZS5sb2codikKICAgICAgICAvLyAgICAgY29uc29sZS5sb2codGhpcykKICAgICAgICAvLyAgICAgLy8gZGVidWdnZXIKICAgICAgICAvLyAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZmluZCBuZXh0IGxldmVsIG5vZGUiKTsKICAgICAgICAvLyB9CiAgICAgICAgaWYgKHYuX2xlZnRDaGlsZCAhPSBudWxsICYmIHYuX3JpZ2h0Q2hpbGQgIT0gbnVsbCkgewogICAgICAgICAgdGhpcy5scnVDYWNoZS5oYXModi5fbGVmdENoaWxkLmxldmVsICsgIl8iICsgdi5fbGVmdENoaWxkLmluZGV4KTsKICAgICAgICAgIHRoaXMubHJ1Q2FjaGUuaGFzKHYuX3JpZ2h0Q2hpbGQubGV2ZWwgKyAiXyIgKyB2Ll9yaWdodENoaWxkLmluZGV4KTsKICAgICAgICAgIGlmICh2Ll9sZWZ0Q2hpbGQubm9kZVR5cGUgIT09ICdOVUxMJykgewogICAgICAgICAgICB0ZW1wUXVlLnB1c2godi5fbGVmdENoaWxkKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh2Ll9yaWdodENoaWxkLm5vZGVUeXBlICE9PSAnTlVMTCcpIHsKICAgICAgICAgICAgdGVtcFF1ZS5wdXNoKHYuX3JpZ2h0Q2hpbGQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZExvYWREaWZOb2RlMi5sZW5ndGg7ICsraSkgewogICAgICAgIG5lZWRMb2FkRGlmTm9kZTJbaV0uZm9yRWFjaCh2ID0+IHsKICAgICAgICAgIGlmICh2Ll9sZWZ0Q2hpbGQgIT0gbnVsbCAmJiB2Ll9yaWdodENoaWxkICE9IG51bGwpIHsKICAgICAgICAgICAgdGhpcy5scnVDYWNoZS5oYXModi5fbGVmdENoaWxkLmxldmVsICsgIl8iICsgdi5fbGVmdENoaWxkLmluZGV4KTsKICAgICAgICAgICAgdGhpcy5scnVDYWNoZS5oYXModi5fcmlnaHRDaGlsZC5sZXZlbCArICJfIiArIHYuX3JpZ2h0Q2hpbGQuaW5kZXgpOwogICAgICAgICAgICBpZiAodi5fbGVmdENoaWxkLm5vZGVUeXBlICE9PSAnTlVMTCcpIHsKICAgICAgICAgICAgICB0ZW1wUXVlMltpXS5wdXNoKHYuX2xlZnRDaGlsZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHYuX3JpZ2h0Q2hpbGQubm9kZVR5cGUgIT09ICdOVUxMJykgewogICAgICAgICAgICAgIHRlbXBRdWUyW2ldLnB1c2godi5fcmlnaHRDaGlsZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBjb25zdCBwcmVDb2xJbmRleCA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBRdWUubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAoY29sSW5kZXggPj0gbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICBicmVhazsKICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCJjb2wgaW5kZXggb3V0IHJhbmdlIik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IHR5cGUgPSBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uaXNNaXNzQ29udGFpbih0ZW1wUXVlW2ldKTsKICAgICAgICBsZXQgdGVtcFF1ZTMgPSBbXTsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG90aGVyRGF0YU1hbmFnZXIubGVuZ3RoOyArK2spIHsKICAgICAgICAgIHRlbXBRdWUzLnB1c2godGVtcFF1ZTJba11baV0pOwogICAgICAgIH0KICAgICAgICBsZXQgYXJyYXkgPSB0ZW1wUXVlMy5zbGljZSgpOwogICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW2NvbEluZGV4XS5jb250YWluQ29sdW1uUmFuZ2UyKHRlbXBRdWVbaV0sIGFycmF5LCB0eXBlLCB0cmFuc2Zvcm1fc3ltYm9sKTsKICAgICAgICAvLyBub25Vbmlmb3JtQ29sT2Jqc1tjb2xJbmRleF0uY29tcHV0ZVRyYW5zZm9ybSh0ZW1wUXVlW2ldLCBhcnJheSwgdGhpcy5kYXRhTmFtZSwgZGF0YU5hbWVzLCB0aGlzLCBvdGhlckRhdGFNYW5hZ2VyLCB0eXBlLCBjdXJyZW50RmxhZ0luZm8sIGN1cnJlbnRGbGFnSW5mbzIsIHRyYW5zZm9ybV9zeW1ib2wpOwogICAgICAgIGxldCBzdGFydF90ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7CiAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbY29sSW5kZXhdLmNvbXB1dGVUcmFuc2Zvcm0odGVtcFF1ZVtpXSwgYXJyYXksIHR5cGUsIGN1cnJlbnRGbGFnSW5mbywgY3VycmVudEZsYWdJbmZvMiwgdHJhbnNmb3JtX3N5bWJvbCwgY291bnRfb2JqKTsKICAgICAgICBsZXQgZW5kX3QgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsKICAgICAgICB0b3RhbF90aW1lICs9IGVuZF90IC0gc3RhcnRfdDsKICAgICAgICBpZiAodHlwZSA9PT0gMSkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAyKSB7CiAgICAgICAgICB0ZW1wTmVlZExvYWREaWZOb2Rlcy5wdXNoKHRlbXBRdWVbaV0pOwogICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBvdGhlckRhdGFNYW5hZ2VyLmxlbmd0aDsgKytrKSB7CiAgICAgICAgICAgIHRlbXBOZWVkTG9hZERpZk5vZGVzMltrXS5wdXNoKGFycmF5W2tdKTsKICAgICAgICAgIH0KICAgICAgICAgIC8vIHRlbXBOZWVkTG9hZERpZk5vZGVzMi5wdXNoKHRlbXBRdWUyW2ldKTsKICAgICAgICAgIHByZUNvbEluZGV4LnB1c2goY29sSW5kZXgpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykgewogICAgICAgICAgY29sSW5kZXgrKzsKICAgICAgICAgIGktLTsKICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcigibm9kZSB0aW1lIGlzIGxpdHRsZSB0aGFuIGNvbCIpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAocHJlQ29sSW5kZXgubGVuZ3RoICE9IHRlbXBOZWVkTG9hZERpZk5vZGVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiY2Fubm90IG1lbW9yeSBpbmRleCIpOwogICAgICB9CiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcE5lZWRMb2FkRGlmTm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgLy8gICAgIGlmIChwcmVDb2xJbmRleFtpXSArIDEgPCBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgLy8gICAgICAgICAvL+WIpOaWreaYr+WQpuWPr+S7peWJquaenQogICAgICAvLyAgICAgICAgIGNvbnN0IGNvbjEgPSBjYW5DdXQodGVtcE5lZWRMb2FkRGlmTm9kZXNbaV0sIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXSwgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXSwgeVNjYWxlKTsKICAgICAgLy8gICAgICAgICBpZiAoY29uMSkgewogICAgICAvLyAgICAgICAgICAgICB0ZW1wTmVlZExvYWREaWZOb2Rlcy5zcGxpY2UoaSwgMSkKICAgICAgLy8gICAgICAgICAgICAgcHJlQ29sSW5kZXguc3BsaWNlKGksIDEpOwogICAgICAvLyAgICAgICAgIH0KICAgICAgLy8gICAgIH0KICAgICAgLy8gfQogICAgICAvLy8vdGhpcy5jaGVja01vbm90b25pY2l0eShub25Vbmlmb3JtQ29sT2JqcyxwcmVDb2xJbmRleCx0ZW1wTmVlZExvYWREaWZOb2Rlcyk7CiAgICAgIG5lZWRMb2FkRGlmTm9kZSA9IHRlbXBOZWVkTG9hZERpZk5vZGVzOwogICAgICBuZWVkTG9hZERpZk5vZGUyID0gdGVtcE5lZWRMb2FkRGlmTm9kZXMyOwogICAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA+IDAgJiYgbmVlZExvYWREaWZOb2RlWzBdLmxldmVsID09PSB0aGlzLm1heExldmVsIC0gMSkgewogICAgICAgIGlmICh0cmFuc2Zvcm1fc3ltYm9sID09PSAnKycpIHsKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZExvYWREaWZOb2RlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGxldCBtYXhMID0gMCwKICAgICAgICAgICAgICBtYXhSID0gMDsKICAgICAgICAgICAgY29uc3Qgbm9kZUZsYWcxID0gY3VycmVudEZsYWdJbmZvWzIgKiBuZWVkTG9hZERpZk5vZGVbaV0uaW5kZXggKyAxXTsKICAgICAgICAgICAgaWYgKG5vZGVGbGFnMSA9PT0gMCkgewogICAgICAgICAgICAgIG1heEwgKz0gbmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgICBtYXhSICs9IG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl07CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbWF4TCArPSBuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzJdOwogICAgICAgICAgICAgIG1heFIgKz0gbmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL2NvbnN0IG5vZGVGbGFnMiA9IGN1cnJlbnRGbGFnSW5mbzJbMiAqIG5lZWRMb2FkRGlmTm9kZVtpXS5pbmRleCArIDFdOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGN1cnJlbnRGbGFnSW5mbzIubGVuZ3RoOyArK2spIHsKICAgICAgICAgICAgICBpZiAoY3VycmVudEZsYWdJbmZvMltrXVtuZWVkTG9hZERpZk5vZGVbaV0uaW5kZXggKiAyICsgMV0gPT09IDApIHsKICAgICAgICAgICAgICAgIG1heEwgKz0gbmVlZExvYWREaWZOb2RlMltrXVtpXS55QXJyYXlbMV07CiAgICAgICAgICAgICAgICBtYXhSICs9IG5lZWRMb2FkRGlmTm9kZTJba11baV0ueUFycmF5WzJdOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBtYXhMICs9IG5lZWRMb2FkRGlmTm9kZTJba11baV0ueUFycmF5WzJdOwogICAgICAgICAgICAgICAgbWF4UiArPSBuZWVkTG9hZERpZk5vZGUyW2tdW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gbGV0IHN1bU9mT3RoZXJNaW4gPSAwLCBzdW1PZk90aGVyTWF4ID0gMDsKICAgICAgICAgICAgLy8gZm9yKGxldCBrPTA7azxvdGhlckRhdGFNYW5hZ2VyLmxlbmd0aDsrK2spewogICAgICAgICAgICAvLyAgICAgc3VtT2ZPdGhlck1pbiArPSBuZWVkTG9hZERpZk5vZGUyW2tdW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgLy8gICAgIHN1bU9mT3RoZXJNYXggKz0gbmVlZExvYWREaWZOb2RlMltrXVtpXS55QXJyYXlbMl07CiAgICAgICAgICAgIC8vIH0KICAgICAgICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZVtpXS5nYXBGbGFnID09PSAnTk8nKSB7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobWF4TCwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShtYXhMKTsKICAgICAgICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmFkZEZpcnN0VmFsKG1heFIsIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobWF4Uik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5hZGRMYXN0VmFsKG1heEwsIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobWF4TCk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5hZGRGaXJzdFZhbChtYXhSLCBuZWVkTG9hZERpZk5vZGVbaV0pOwogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uZm9yY2VNZXJnZShtYXhSKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtX3N5bWJvbCA9PT0gJy0nKSB7CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRMb2FkRGlmTm9kZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBsZXQgbWF4TCA9IDAsCiAgICAgICAgICAgICAgbWF4UiA9IDA7CiAgICAgICAgICAgIGNvbnN0IG5vZGVGbGFnMSA9IGN1cnJlbnRGbGFnSW5mb1syICogbmVlZExvYWREaWZOb2RlW2ldLmluZGV4ICsgMV07CiAgICAgICAgICAgIGlmIChub2RlRmxhZzEgPT09IDApIHsKICAgICAgICAgICAgICBtYXhMICs9IG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMV07CiAgICAgICAgICAgICAgbWF4UiArPSBuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzJdOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG1heEwgKz0gbmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXTsKICAgICAgICAgICAgICBtYXhSICs9IG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy9jb25zdCBub2RlRmxhZzIgPSBjdXJyZW50RmxhZ0luZm8yWzIgKiBuZWVkTG9hZERpZk5vZGVbaV0uaW5kZXggKyAxXTsKICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjdXJyZW50RmxhZ0luZm8yLmxlbmd0aDsgKytrKSB7CiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGbGFnSW5mbzJba11bbmVlZExvYWREaWZOb2RlW2ldLmluZGV4ICogMiArIDFdID09PSAwKSB7CiAgICAgICAgICAgICAgICBtYXhMIC09IG5lZWRMb2FkRGlmTm9kZTJba11baV0ueUFycmF5WzFdOwogICAgICAgICAgICAgICAgbWF4UiAtPSBuZWVkTG9hZERpZk5vZGUyW2tdW2ldLnlBcnJheVsyXTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgbWF4TCAtPSBuZWVkTG9hZERpZk5vZGUyW2tdW2ldLnlBcnJheVsyXTsKICAgICAgICAgICAgICAgIG1heFIgLT0gbmVlZExvYWREaWZOb2RlMltrXVtpXS55QXJyYXlbMV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChuZWVkTG9hZERpZk5vZGVbaV0uZ2FwRmxhZyA9PT0gJ05PJykgewogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5hZGRMYXN0VmFsKG1heEwsIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobWF4TCk7CiAgICAgICAgICAgICAgaWYgKHByZUNvbEluZGV4W2ldICsgMSA8IG5vblVuaWZvcm1Db2xPYmpzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5hZGRGaXJzdFZhbChtYXhSLCBuZWVkTG9hZERpZk5vZGVbaV0pOwogICAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5mb3JjZU1lcmdlKG1heFIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uYWRkTGFzdFZhbChtYXhMLCBuZWVkTG9hZERpZk5vZGVbaV0pOwogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5mb3JjZU1lcmdlKG1heEwpOwogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uYWRkRmlyc3RWYWwobWF4UiwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobWF4Uik7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybV9zeW1ib2wgPT09ICcqJykgewogICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkTG9hZERpZk5vZGUubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgbGV0IG1heEwgPSAwLAogICAgICAgICAgICAgIG1heFIgPSAwOwogICAgICAgICAgICBjb25zdCBub2RlRmxhZzEgPSBjdXJyZW50RmxhZ0luZm9bMiAqIG5lZWRMb2FkRGlmTm9kZVtpXS5pbmRleCArIDFdOwogICAgICAgICAgICBpZiAobm9kZUZsYWcxID09PSAwKSB7CiAgICAgICAgICAgICAgbWF4TCArPSBuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdOwogICAgICAgICAgICAgIG1heFIgKz0gbmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsyXTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBtYXhMICs9IG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl07CiAgICAgICAgICAgICAgbWF4UiArPSBuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzFdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vY29uc3Qgbm9kZUZsYWcyID0gY3VycmVudEZsYWdJbmZvMlsyICogbmVlZExvYWREaWZOb2RlW2ldLmluZGV4ICsgMV07CiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY3VycmVudEZsYWdJbmZvMi5sZW5ndGg7ICsraykgewogICAgICAgICAgICAgIGlmIChjdXJyZW50RmxhZ0luZm8yW2tdW25lZWRMb2FkRGlmTm9kZVtpXS5pbmRleCAqIDIgKyAxXSA9PT0gMCkgewogICAgICAgICAgICAgICAgbWF4TCAqPSBuZWVkTG9hZERpZk5vZGUyW2tdW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgICAgIG1heFIgKj0gbmVlZExvYWREaWZOb2RlMltrXVtpXS55QXJyYXlbMl07CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIG1heEwgKj0gbmVlZExvYWREaWZOb2RlMltrXVtpXS55QXJyYXlbMl07CiAgICAgICAgICAgICAgICBtYXhSICo9IG5lZWRMb2FkRGlmTm9kZTJba11baV0ueUFycmF5WzFdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAobmVlZExvYWREaWZOb2RlW2ldLmdhcEZsYWcgPT09ICdOTycpIHsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uYWRkTGFzdFZhbChtYXhMLCBuZWVkTG9hZERpZk5vZGVbaV0pOwogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5mb3JjZU1lcmdlKG1heEwpOwogICAgICAgICAgICAgIGlmIChwcmVDb2xJbmRleFtpXSArIDEgPCBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGgpIHsKICAgICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uYWRkRmlyc3RWYWwobWF4UiwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uZm9yY2VNZXJnZShtYXhSKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobWF4TCwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShtYXhMKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmFkZEZpcnN0VmFsKG1heFIsIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5mb3JjZU1lcmdlKG1heFIpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1fc3ltYm9sID09PSAnLycpIHsKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZExvYWREaWZOb2RlLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGxldCBtYXhMID0gMCwKICAgICAgICAgICAgICBtYXhSID0gMDsKICAgICAgICAgICAgY29uc3Qgbm9kZUZsYWcxID0gY3VycmVudEZsYWdJbmZvWzIgKiBuZWVkTG9hZERpZk5vZGVbaV0uaW5kZXggKyAxXTsKICAgICAgICAgICAgaWYgKG5vZGVGbGFnMSA9PT0gMCkgewogICAgICAgICAgICAgIG1heEwgKz0gbmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgICBtYXhSICs9IG5lZWRMb2FkRGlmTm9kZVtpXS55QXJyYXlbMl07CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbWF4TCArPSBuZWVkTG9hZERpZk5vZGVbaV0ueUFycmF5WzJdOwogICAgICAgICAgICAgIG1heFIgKz0gbmVlZExvYWREaWZOb2RlW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL2NvbnN0IG5vZGVGbGFnMiA9IGN1cnJlbnRGbGFnSW5mbzJbMiAqIG5lZWRMb2FkRGlmTm9kZVtpXS5pbmRleCArIDFdOwogICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGN1cnJlbnRGbGFnSW5mbzIubGVuZ3RoOyArK2spIHsKICAgICAgICAgICAgICBpZiAoY3VycmVudEZsYWdJbmZvMltrXVtuZWVkTG9hZERpZk5vZGVbaV0uaW5kZXggKiAyICsgMV0gPT09IDApIHsKICAgICAgICAgICAgICAgIG1heEwgLz0gbmVlZExvYWREaWZOb2RlMltrXVtpXS55QXJyYXlbMV07CiAgICAgICAgICAgICAgICBtYXhSIC89IG5lZWRMb2FkRGlmTm9kZTJba11baV0ueUFycmF5WzJdOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBtYXhMIC89IG5lZWRMb2FkRGlmTm9kZTJba11baV0ueUFycmF5WzJdOwogICAgICAgICAgICAgICAgbWF4UiAvPSBuZWVkTG9hZERpZk5vZGUyW2tdW2ldLnlBcnJheVsxXTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKG5lZWRMb2FkRGlmTm9kZVtpXS5nYXBGbGFnID09PSAnTk8nKSB7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmFkZExhc3RWYWwobWF4TCwgbmVlZExvYWREaWZOb2RlW2ldKTsKICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXV0uZm9yY2VNZXJnZShtYXhMKTsKICAgICAgICAgICAgICBpZiAocHJlQ29sSW5kZXhbaV0gKyAxIDwgbm9uVW5pZm9ybUNvbE9ianMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmFkZEZpcnN0VmFsKG1heFIsIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgICBub25Vbmlmb3JtQ29sT2Jqc1twcmVDb2xJbmRleFtpXSArIDFdLmZvcmNlTWVyZ2UobWF4Uik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldXS5hZGRMYXN0VmFsKG1heEwsIG5lZWRMb2FkRGlmTm9kZVtpXSk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV1dLmZvcmNlTWVyZ2UobWF4TCk7CiAgICAgICAgICAgICAgbm9uVW5pZm9ybUNvbE9ianNbcHJlQ29sSW5kZXhbaV0gKyAxXS5hZGRGaXJzdFZhbChtYXhSLCBuZWVkTG9hZERpZk5vZGVbaV0pOwogICAgICAgICAgICAgIG5vblVuaWZvcm1Db2xPYmpzW3ByZUNvbEluZGV4W2ldICsgMV0uZm9yY2VNZXJnZShtYXhSKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZiAobmVlZExvYWREaWZOb2RlLmxlbmd0aCA9PT0gMCkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIC8vIGlmKG5lZWRMb2FkRGlmTm9kZS5sZW5ndGggPT09IDAgfHwgbmVlZExvYWREaWZOb2RlWzBdLmxldmVsID09PSB0aGlzLm1heExldmVsIC0gMSl7CiAgICAgIC8vICAgICBicmVhazsKICAgICAgLy8gfQogICAgICAvLyBsZXQgbG9zZWREYXRhSW5mbyA9IGNvbXB1dGVMb3NlZERhdGFSYW5nZVYxKG5lZWRMb2FkRGlmTm9kZSk7CiAgICAgIC8vIGlmIChsb3NlZERhdGFJbmZvLmxlbmd0aCA+IDApIHsKICAgICAgLy8gICAgIGF3YWl0IGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMU1pbk1heE1pc3MobG9zZWREYXRhSW5mbywgdGhpcyk7IC8v5q+P5LiA5bGC6YO96ZyA6KaB5Yik5pat5a2Q6IqC54K55piv5ZCm6ZyA6KaB6I635Y+W77yM6ZyA6KaB55qE6K+d6KaB5LuO5pWw5o2u5bqT6I635Y+W57O75pWwCiAgICAgIC8vICAgICBmb3IobGV0IGk9MDsgaTxvdGhlckRhdGFNYW5hZ2VyLmxlbmd0aDsgaSsrKQogICAgICAvLyAgICAgICAgIGF3YWl0IGJhdGNoTG9hZERhdGFGb3JSYW5nZUxldmVsMU1pbk1heE1pc3MobG9zZWREYXRhSW5mbywgb3RoZXJEYXRhTWFuYWdlcltpXSk7IAogICAgICAvLyB9CiAgICB9CiAgICAvLyBjb25zb2xlLmxvZygiVGhlIHRpbWUgdG8gZ2V0IGFsbCBjb2VmZmljaWVudHM6IiArIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VCkpOwogICAgY29uc29sZS5sb2coIlRoZSBmaW5hbCBjb3VudDoiLCBjb3VudF9vYmouY291bnQpOwogICAgLy8gY29uc29sZS5sb2coIlRoZSB0aW1lIHRvIGdldCB0b3RhbCBjb2VmZmljaWVudHM6IiwgdG90YWxfdGltZSk7CiAgICBjb25zb2xlLmxvZygiVGhlIHRpbWUgdG8gZ2V0IHRvdGFsIGNvZWZmaWNpZW50czoiLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VCk7CiAgICBsZXQgbWF4VmFsdWUgPSAtSW5maW5pdHksCiAgICAgIG1pblZhbHVlID0gSW5maW5pdHksCiAgICAgIGZpbmFsVmFsdWUgPSAwOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub25Vbmlmb3JtQ29sT2Jqcy5sZW5ndGg7IGkrKykgewogICAgICBub25Vbmlmb3JtQ29sT2Jqc1tpXS5jaGVja0lzTWlzKCk7CiAgICAgIGlmICh0cmFuc2Zvcm1fc3ltYm9sID09PSAnKycpIHsKICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCBub25Vbmlmb3JtQ29sT2Jqc1tpXS5hZGRNYXhbMV0pOwogICAgICAgIG1pblZhbHVlID0gTWF0aC5taW4obWluVmFsdWUsIG5vblVuaWZvcm1Db2xPYmpzW2ldLmFkZE1pblsxXSk7CiAgICAgICAgLy8gbWF4VmFsdWUgPSAyMDAwOwogICAgICAgIC8vIG1pblZhbHVlID0gMjAwMDsKICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1fc3ltYm9sID09PSAnLScpIHsKICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCBub25Vbmlmb3JtQ29sT2Jqc1tpXS5zdWJNYXhbMV0pOwogICAgICAgIG1pblZhbHVlID0gTWF0aC5taW4obWluVmFsdWUsIG5vblVuaWZvcm1Db2xPYmpzW2ldLnN1Yk1pblsxXSk7CiAgICAgICAgLy8gbWF4VmFsdWUgPSAxMDAwOwogICAgICAgIC8vIG1pblZhbHVlID0gLTIwMDA7CiAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtX3N5bWJvbCA9PT0gJyonKSB7CiAgICAgICAgbWF4VmFsdWUgPSBNYXRoLm1heChtYXhWYWx1ZSwgbm9uVW5pZm9ybUNvbE9ianNbaV0ubXVsdGlNYXhbMV0pOwogICAgICAgIG1pblZhbHVlID0gTWF0aC5taW4obWluVmFsdWUsIG5vblVuaWZvcm1Db2xPYmpzW2ldLm11bHRpTWluWzFdKTsKICAgICAgfSBlbHNlIGlmICh0cmFuc2Zvcm1fc3ltYm9sID09PSAnLycpIHsKICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCBub25Vbmlmb3JtQ29sT2Jqc1tpXS5kaXZNYXhbMV0pOwogICAgICAgIG1pblZhbHVlID0gTWF0aC5taW4obWluVmFsdWUsIG5vblVuaWZvcm1Db2xPYmpzW2ldLmRpdk1pblsxXSk7CiAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtX3N5bWJvbCA9PT0gJ2F2ZycpIHsKICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KG1heFZhbHVlLCBub25Vbmlmb3JtQ29sT2Jqc1tpXS5hZGRNYXhbMV0pOwogICAgICAgIG1pblZhbHVlID0gTWF0aC5taW4obWluVmFsdWUsIG5vblVuaWZvcm1Db2xPYmpzW2ldLmFkZE1pblsxXSk7CiAgICAgIH0KICAgICAgZmluYWxWYWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKG1heFZhbHVlKSwgTWF0aC5hYnMobWluVmFsdWUpKTsKICAgIH0KICAgIGNvbnN0IG15RGljdCA9IHsKICAgICAgYTogbm9uVW5pZm9ybUNvbE9ianMsCiAgICAgIGI6IGZpbmFsVmFsdWUKICAgIH07CiAgICByZXR1cm4gbXlEaWN0OwogIH0KfQ=="},{"version":3,"names":["LevelIndexObj","axios","TrendTree","store","pushTimeArray","canCut","computeLosedDataRange","computeLosedDataRangeV1","computeTimeSE","UniformGapObj","loadDataForRangeLevel","batchLoadDataForRangeLevelRawMinMax","batchLoadDataForRangeLevel","batchLoadDataForRangeLevel1","batchLoadDataForRangeLevel2MinMaxMiss","batchLoadDataForRangeLevel1MinMaxMiss","batchLoadDataForRangeLevel1WS","Cache","getFlag","get","url","data","allTimes","allSumTimes","LevelDataManager","constructor","levelIndexObjs","dataName","maxLevel","state","controlParams","tableMaxLevel","realDataRowNum","isShow","columnInfos","curNodeNum","dataCache","Array","cacheMap","Map","cacheHead","cacheTail","maxCacheNodeNum","lruCache","initCache","deleteQueue","isIntering","isEvicting","getDataMockServer","info","internalLevel","level","outterLevel","nextLevel","Error","width","Math","ceil","log2","offset","end","start","focusPoint","nextStart","nextEnd","getData","noRet","lastFullLevel","i","floor","isFull","losedDataInfo","checkLoadedDataInSingalLevel","l","extraDataLevel","curExtraLevel","fakeRowNum","lastIndex","getDataByIndex","getDataMinMaxMiss","processLosedDataInfo","j","length","tempInfo","push","getDataRawMinMax","getDataV1","hasData","hasDataForRange","has","losedRange","range","losedDataOtherLevel","levelHasData","forEach","unshift","getLoadedData","checkMonotonicity","nonUniformColObjs","preIndexArray","needLoadDifNodes","first","yArray","minV","maxV","last","pL","pTRange","pTimeS","index","pTimeE","k","b","mergeLast","mergeFirst","splice","constructTreeForBatchLoad1","difVals","count","levelRange","startNode","getTreeNodeStartIndex","p","newTreeNode","_p","difference","dif","yArray1","yArray2","firstNode","secondNode","nextSibling","_p2","console","log","previousSibling","addLoadedDataRange","constructTreeForBatchLoad","nodeNum","_p3","set","_p4","viewChangeInteraction","currentLevel","timeRange","yScale","needLoadDifNode","colIndex","firstNodes","firtIndexTimeRange","getIndexTime","loadedDataRange","lastIndexTimeRange","startT","endT","type","isContain","currentLevelLosedRange","countNum","tempNeedLoadDifNodes","tempQue","v","_leftChild","_rightChild","preColIndex","con1","addLastVal","forceMerge","addFirstVal","viewChangeInteraction1","sumTime","reduce","pre","cur","startTime","Date","getTime","checkLoadedDataInSingalLevelV1","gap","endTime","options","max","maxSize","sizeCalculation","value","key","dispose","reason","disposeAfter","ttl","allowStale","updateAgeOnGet","updateAgeOnHas","evictTreeNode","setInterval","curNode","delete","deleteNodeWhithChild","curLS","curRS","curLLoadedRange","curFirstNodes","newFirstNodes","newLoadDataRanges","curRange0","curP","updateMaxCacheSize","size","lruCacheDelete","needDeleteNum","levelObj","computePowCon","gapNeedNodes","times","timeNum","groups","groupIdx","group","secGroup","levelTime","columnGapArray","columnGap","group1","group2","updateLeftMinMax","updateRighetMinMax","con","isFinish","isCut","colGap","isOk","lastLevelUpdateMinMax","updateTwoNode","canUseT","endV","tOne","startV","bfsSearchTree","viewChangeInteraction1WS","props","tagName","random","leftHas","rightHas","rootT","viewChangeInteractionFinal","includes","split","currentFlagInfo","allFlags","undefined","isMissContain","containColumnRange","nodeType","nodeFlag1","nodeFlag2","checkIsMis","viewChangeInteractionFinal1","drawer","loadedDataSize","gapFlag","progressive","viewTransformFinal","otherDataManager","transform_symbol","currentFlagInfo2","dataNames","needLoadDifNode2","fill","map","count_obj","total_time","firstIndexTimeRange","p2","resChild","p2_temp","slice","containColumnRange2","start_t","computeTransform","end_t","tempNeedLoadDifNodes2","tempQue2","tempQue3","array","maxL","maxR","maxValue","Infinity","minValue","finalValue","addMax","min","addMin","subMax","subMin","multiMax","multiMin","divMax","divMin","abs","myDict","a"],"sources":["/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/eslint-loader/index.js??ref--14-0!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/src/model/level-data-manager.ts"],"sourcesContent":["import LevelIndexObj from \"./level-index-obj\";\nimport axios from \"axios\";\nimport TrendTree from \"@/helper/tend-query-tree\";\nimport store, { pushTimeArray } from \"@/store\";\nimport * as d3 from 'd3';\nimport { canCut, checkSetType, computeLosedDataRange, computeLosedDataRangeV1, computeTimeSE, deleteSavedNodeIndex, computeSemanticColumn, convertWaveletToRawTableName, computeLosedDataRangeV1ForRawMinMax, computeTimeSE1 } from \"@/helper/util\";\nimport  NoUniformColObj  from \"./non-uniform-col-obj\";\nimport { UniformGapObj } from \"./uniform-gap-obj\";\n// import { loadDataForRangeLevel, batchLoadDataForRangeLevelRawMinMax, batchLoadDataForRangeLevel, batchLoadDataForRangeLevel1, batchLoadDataForRangeLevel2MinMaxMiss, batchLoadDataForRangeLevel1MinMaxMiss, batchLoadDataForRangeLevel1WS, batchLoadDataForRangeLevelForMinMaxMiss } from \"../api/build_tree\"\nimport { loadDataForRangeLevel, batchLoadDataForRangeLevelRawMinMax, batchLoadDataForRangeLevel, batchLoadDataForRangeLevel1, batchLoadDataForRangeLevel2MinMaxMiss, batchLoadDataForRangeLevel1MinMaxMiss, batchLoadDataForRangeLevel1WS, batchLoadDataForRangeLevelForMinMaxMiss } from \"../api/build_tree\"\nimport { constructMinMaxMissTrendTree, constructMinMaxMissTrendTreeMulti, constructMinMaxMissTrendTreeForGetChildTree} from '../helper/wavlet-decoder';\n\nimport Cache from \"lru-cache\"\nimport { getFlag } from \"@/global_state/state\";\nimport { START_LOCATION } from \"vue-router\";\n\nasync function get(url: string) {\n\n    url = 'postgres' + url;\n\n    //const loading = openLoading();\n    const { data } = await axios.get(url);\n    //loading.close();\n    return data;\n}\n\nlet allTimes: any = []\nlet allSumTimes: any = []\n\nexport default class LevelDataManager {\n    levelIndexObjs: Array<LevelIndexObj>\n    maxLevel: number\n    realDataRowNum: number\n    dataName: string\n    md5Num?: number\n    isShow: boolean\n    columnInfos: Array<NoUniformColObj> | null\n    curNodeNum: number\n    dataCache: Array<TrendTree>\n    cacheMap: Map<number, TrendTree>\n    cacheHead: TrendTree | null\n    cacheTail: TrendTree | null\n    maxCacheNodeNum: number\n    lruCache: any\n    deleteQueue: Array<TrendTree>\n    isIntering: boolean\n    isEvicting: boolean\n    constructor(levelIndexObjs: Array<LevelIndexObj>, dataName: string, maxLevel?: number) {\n        this.levelIndexObjs = levelIndexObjs;\n        this.maxLevel = maxLevel ? maxLevel : store.state.controlParams.tableMaxLevel;\n        this.realDataRowNum = 2 ** (maxLevel ? maxLevel : store.state.controlParams.tableMaxLevel);\n        this.dataName = dataName;\n        this.isShow = true;\n        this.columnInfos = null;\n        this.curNodeNum = 0;\n        this.dataCache = new Array<TrendTree>();\n        this.cacheMap = new Map<number, TrendTree>();\n        this.cacheHead = null;\n        this.cacheTail = null;\n        this.maxCacheNodeNum = 100000\n        this.lruCache = null;\n        this.initCache();\n        this.deleteQueue = [];\n        this.isIntering = false;\n        this.isEvicting = false\n    }\n\n\n    async getDataMockServer(info: { level: number, start: number, end: number, offset: number, width: number }) {\n        const internalLevel = this.maxLevel - info.level;\n        const outterLevel = info.level;\n        const nextLevel = internalLevel;\n        if (nextLevel < 1) {\n            throw new Error(\"level out of range\")\n        }\n        const width = 2 ** Math.ceil(Math.log2(info.width));\n        let offset = info.offset\n\n        let end = info.end;\n        let start = info.start;\n        let focusPoint = start + offset;\n        let nextStart = focusPoint - width / 4;\n        let nextEnd = focusPoint + width / 4;\n\n\n        if (nextStart <= start) {\n            nextStart = start;\n            nextEnd = start + width / 2 - 1;\n        }\n        if (nextEnd >= end) {\n            nextEnd = end;\n            nextStart = end - width / 2 + 1;\n        }\n        const data = await this.getData(outterLevel + 1, nextStart * 2, nextStart * 2 + width - 1);\n        return [[offset, 2 * nextStart], data];\n    }\n    async getData(level: number, start: number, end: number, noRet?: boolean) {\n        if (level > this.maxLevel) {\n            return []\n        }\n        let lastFullLevel = 2;\n        let nextStart = start;\n        let nextEnd = end;\n        for (let i = level - 1; i > 1; i--) {\n            nextStart = Math.floor(nextStart / 2);\n            nextEnd = Math.floor(nextEnd / 2);\n            if (this.levelIndexObjs[i] && this.levelIndexObjs[i].isFull) {\n                lastFullLevel = i;\n                break;\n            }\n        }\n        for (let i = lastFullLevel + 1; i <= level; i++) {\n            nextStart = nextStart * 2;\n            nextEnd = nextEnd * 2 + 1;\n            const losedDataInfo = this.checkLoadedDataInSingalLevel([[i, nextStart, nextEnd]]);\n            //debugger\n            await batchLoadDataForRangeLevel(losedDataInfo, this);\n        }\n        if (this.levelIndexObjs[level]) {\n            //更新缓存\n            // this.updateDataCacheForRange(level, start, end)\n            if (noRet) {\n                return { data: [], start: 0, end: 0, l: 0 }\n            } else {\n                if (this.dataName === 'sensor8') {\n                    const extraDataLevel = Math.ceil(Math.log2(2 ** this.maxLevel - this.realDataRowNum));\n                    if (level >= this.maxLevel - extraDataLevel) {\n                        const curExtraLevel = level - (this.maxLevel - extraDataLevel);\n                        const fakeRowNum = 2 ** curExtraLevel;\n                        if (end >= 2 ** level - fakeRowNum) {\n                            end = 2 ** level - fakeRowNum - 1;\n                        }\n                    }\n                    let lastIndex = this.realDataRowNum - 1;\n                    for (let i = this.maxLevel; i >= level; i--) {\n                        lastIndex = Math.floor(lastIndex / 2);\n                    }\n                    if (end < start) {\n                        return [];\n                    }\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                } else {\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                }\n            }\n\n        } else {\n            return { data: [], start: 0, end: 0, l: 0 }\n            //throw new Error(\"cannot get data from data manager\");\n        }\n    }\n    async getDataMinMaxMiss(level: number, start: number, end: number, noRet?: boolean) {\n        if (level > this.maxLevel) {\n            return []\n        }\n        let lastFullLevel = 2;\n        let nextStart = start;\n        let nextEnd = end;\n        for (let i = level - 1; i > 1; i--) {\n            nextStart = Math.floor(nextStart / 2);\n            nextEnd = Math.floor(nextEnd / 2);\n            if (this.levelIndexObjs[i] && this.levelIndexObjs[i].isFull) {\n                lastFullLevel = i;\n                break;\n            }\n        }\n\n        for (let i = lastFullLevel + 1; i <= level; i++) {\n            nextStart = nextStart * 2;\n            nextEnd = nextEnd * 2 + 1;\n            const losedDataInfo = this.checkLoadedDataInSingalLevel([[i, nextStart, nextEnd]]);\n            const processLosedDataInfo = [];\n            for (let j = 0; j < losedDataInfo.length; j++) {\n                const tempInfo = losedDataInfo[j]\n                processLosedDataInfo.push([tempInfo[0] - 1, Math.floor(tempInfo[1] / 2), Math.floor(tempInfo[2] / 2)])\n            }\n\n            await batchLoadDataForRangeLevel2MinMaxMiss(processLosedDataInfo, this);\n        }\n\n        if (this.levelIndexObjs[level]) {\n            //更新缓存\n            // this.updateDataCacheForRange(level, start, end)\n            if (noRet) {\n                return { data: [], start: 0, end: 0, l: 0 }\n            } else {\n                if (this.dataName === 'sensor8') {\n                    const extraDataLevel = Math.ceil(Math.log2(2 ** this.maxLevel - this.realDataRowNum));\n                    if (level >= this.maxLevel - extraDataLevel) {\n                        const curExtraLevel = level - (this.maxLevel - extraDataLevel);\n                        const fakeRowNum = 2 ** curExtraLevel;\n                        if (end >= 2 ** level - fakeRowNum) {\n                            end = 2 ** level - fakeRowNum - 1;\n                        }\n                    }\n                    let lastIndex = this.realDataRowNum - 1;\n                    for (let i = this.maxLevel; i >= level; i--) {\n                        lastIndex = Math.floor(lastIndex / 2);\n                    }\n                    if (end < start) {\n                        return [];\n                    }\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                } else {\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                }\n            }\n\n        } else {\n            return { data: [], start: 0, end: 0, l: 0 }\n            //throw new Error(\"cannot get data from data manager\");\n        }\n    }\n\n    async getDataRawMinMax(level: number, start: number, end: number, noRet?: boolean) {\n        if (level > this.maxLevel) {\n            return []\n        }\n        let lastFullLevel = 2;\n        let nextStart = start;\n        let nextEnd = end;\n        //debugger\n        for (let i = level - 1; i > 1; i--) {\n            nextStart = Math.floor(nextStart / 2);\n            nextEnd = Math.floor(nextEnd / 2);\n            if (this.levelIndexObjs[i] && this.levelIndexObjs[i].isFull) {\n                lastFullLevel = i;\n                break;\n            }\n        }\n        for (let i = lastFullLevel + 1; i <= level; i++) {\n            nextStart = nextStart * 2;\n            nextEnd = nextEnd * 2 + 1;\n            const losedDataInfo = this.checkLoadedDataInSingalLevel([[i, nextStart, nextEnd]]);\n            //debugger\n            await batchLoadDataForRangeLevelRawMinMax(losedDataInfo, this);\n        }\n        if (this.levelIndexObjs[level]) {\n            //更新缓存\n            // this.updateDataCacheForRange(level, start, end)\n            if (noRet) {\n                return { data: [], start: 0, end: 0, l: 0 }\n            } else {\n                if (this.dataName === 'sensor8') {\n                    const extraDataLevel = Math.ceil(Math.log2(2 ** this.maxLevel - this.realDataRowNum));\n                    if (level >= this.maxLevel - extraDataLevel) {\n                        const curExtraLevel = level - (this.maxLevel - extraDataLevel);\n                        const fakeRowNum = 2 ** curExtraLevel;\n                        if (end >= 2 ** level - fakeRowNum) {\n                            end = 2 ** level - fakeRowNum - 1;\n                        }\n                    }\n                    let lastIndex = this.realDataRowNum - 1;\n                    for (let i = this.maxLevel; i >= level; i--) {\n                        lastIndex = Math.floor(lastIndex / 2);\n                    }\n                    if (end < start) {\n                        return [];\n                    }\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                } else {\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                }\n            }\n\n        } else {\n            return { data: [], start: 0, end: 0, l: 0 }\n            //throw new Error(\"cannot get data from data manager\");\n        }\n    }\n    async getDataV1(level: number, start: number, end: number, noRet?: boolean) {\n        if (level > this.maxLevel) {\n            return [];\n        }\n        if (this.levelIndexObjs[level]) {\n\n            const hasData = this.levelIndexObjs[level].hasDataForRange(start, end);\n            if (hasData.has) {\n                return this.levelIndexObjs[level].getDataByIndex(start, end);\n            } else {\n                const losedRange = hasData.range;\n\n                for (let i = 0; i < losedRange.length; i++) {\n                    let l = level - 1;\n                    const losedDataOtherLevel = [];\n                    for (; l >= 0; l--) {\n                        if (this.levelIndexObjs[l].isFull) {\n                            break;\n                        }\n                        const levelHasData = this.levelIndexObjs[l].hasDataForRange(Math.floor(losedRange[i][0] / (2 ** (level - l))), Math.floor(losedRange[i][1] / (2 ** (level - l))));\n                        if (levelHasData.has) {\n                            break;\n                        }\n                        losedDataOtherLevel.push([l, Math.floor(losedRange[i][0] / (2 ** (level - l))), Math.floor(losedRange[i][1] / (2 ** (level - l)))]);\n                    }\n                    await loadDataForRangeLevel(losedDataOtherLevel, this);\n                }\n                losedRange.forEach(range => {\n                    range.unshift(level);\n                });\n                await loadDataForRangeLevel(losedRange, this);\n            }\n        } else {\n            let l = level - 1;\n            const losedDataOtherLevel = [];\n            for (; l >= 0; l--) {\n                if (this.levelIndexObjs[l] && this.levelIndexObjs[l].isFull) {\n                    break;\n                }\n                if (this.levelIndexObjs[l]) {\n                    const levelHasData = this.levelIndexObjs[l].hasDataForRange(Math.floor(start / (2 ** (level - l))), Math.floor(end / (2 ** (level - l))));\n                    if (levelHasData.has) {\n                        break;\n                    }\n                }\n                losedDataOtherLevel.push([l, Math.floor(start / (2 ** (level - l))), Math.floor(end / (2 ** (level - l)))]);\n            }\n            losedDataOtherLevel.unshift([level, start, end]);\n            await loadDataForRangeLevel(losedDataOtherLevel, this);\n        }\n        if (this.levelIndexObjs[level]) {\n            if (noRet) {\n                return []\n            } else {\n                if (this.dataName === 'sensor8') {\n                    const extraDataLevel = Math.ceil(Math.log2(2 ** this.maxLevel - this.realDataRowNum));\n                    if (level >= this.maxLevel - extraDataLevel) {\n                        const curExtraLevel = level - (this.maxLevel - extraDataLevel);\n                        const fakeRowNum = 2 ** curExtraLevel;\n                        if (end >= 2 ** level - fakeRowNum) {\n                            end = 2 ** level - fakeRowNum - 1;\n                        }\n                    }\n                    let lastIndex = this.realDataRowNum - 1;\n                    for (let i = this.maxLevel; i >= level; i--) {\n                        lastIndex = Math.floor(lastIndex / 2);\n                    }\n                    if (end < start) {\n                        return [];\n                    }\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                } else {\n                    return this.levelIndexObjs[level].getDataByIndex(start, end);\n                }\n            }\n        } else {\n            throw new Error(\"cannot get data from data manager\");\n        }\n    }\n    getLoadedData(level: number, start: number, end: number) {\n        if (this.levelIndexObjs[level]) {\n            if (this.dataName === 'sensor8') {\n                const extraDataLevel = Math.ceil(Math.log2(2 ** this.maxLevel - this.realDataRowNum));\n                if (level >= this.maxLevel - extraDataLevel) {\n                    const curExtraLevel = level - (this.maxLevel - extraDataLevel);\n                    const fakeRowNum = 2 ** curExtraLevel;\n                    if (end >= 2 ** level - fakeRowNum) {\n                        end = 2 ** level - fakeRowNum - 1;\n                    }\n                }\n                if (end < start) {\n                    return [];\n                }\n                return this.levelIndexObjs[level].getDataByIndex(start, end);\n            } else {\n                return this.levelIndexObjs[level].getDataByIndex(start, end);\n            }\n\n        } else {\n            throw new Error(\"cannot get data from data manager\");\n        }\n    }\n\n    checkMonotonicity(nonUniformColObjs: Array<NoUniformColObj>, preIndexArray: Array<number>, needLoadDifNodes: Array<TrendTree>) {\n        for (let i = 0; i < needLoadDifNodes.length; i++) {\n            const first = needLoadDifNodes[i].yArray[0];\n            const minV = needLoadDifNodes[i].yArray[1];\n            const maxV = needLoadDifNodes[i].yArray[2];\n            const last = needLoadDifNodes[i].yArray[3];\n            const pL = needLoadDifNodes[i].level;\n            const pTRange = (2 ** this.maxLevel) / (2 ** pL);\n            const pTimeS = needLoadDifNodes[i].index * pTRange;\n            const pTimeE = pTRange + pTimeS - 1;\n            if ((first === minV && last === maxV) || (first === maxV && last === minV)) {\n                const k = (last - first) / (pTimeE - pTimeS);\n                const b = first - k * pTimeS;\n                nonUniformColObjs[preIndexArray[i]].mergeLast(k, b);\n                nonUniformColObjs[preIndexArray[i] + 1].mergeFirst(k, b);\n                preIndexArray.splice(i, 1);\n                needLoadDifNodes.splice(i, 1);\n            }\n        }\n    }\n    constructTreeForBatchLoad1(losedRange: Array<Array<number>>, difVals: Array<{ l: number, i: number, dif: Array<number> }>) {\n        let count = 0;\n        for (let i = 0; i < losedRange.length; i++) {\n            const levelRange = losedRange[i];\n\n            const startNode = this.levelIndexObjs[losedRange[i][0]].getTreeNodeStartIndex(losedRange[i][1]);\n            let p = startNode;\n            const newTreeNode = [];\n            for (let j = losedRange[i][1]; j <= losedRange[i][2]; j++) {\n                if (p?.index === j && j === difVals[count].i && p.level === difVals[count].l) {\n                    //@ts-ignore\n                    p.difference = difVals[count].dif;\n                    // const yArray1: [number, number, number, number] = [0, 0, 0, 0]\n                    // const yArray2: [number, number, number, number] = [0, 0, 0, 0]\n                    // yArray1[0] = p.yArray[0];\n                    // yArray2[0] = p.yArray[0] - p.difference![0];\n                    // yArray1[3] = p.yArray[3] + p.difference![3];\n                    // yArray2[3] = p.yArray[3];\n                    // if (p.difference![1] < 0) {\n                    //     yArray1[1] = p.yArray[1];\n                    //     yArray2[1] = p.yArray[1] - p.difference![1];\n                    // } else {\n                    //     yArray1[1] = p.yArray[1] + p.difference![1];\n                    //     yArray2[1] = p.yArray[1]\n                    // }\n                    // if (p.difference![2] < 0) {\n                    //     yArray1[2] = p.yArray[2] + p.difference![2];\n                    //     yArray2[2] = p.yArray[2];\n                    // } else {\n                    //     yArray1[2] = p.yArray[2];\n                    //     yArray2[2] = p.yArray[2] - p.difference![2];\n                    // }\n                    const yArray1: [number, number, number, number, number] = [0, 0, 0, 0, 0]\n                    const yArray2: [number, number, number, number, number] = [0, 0, 0, 0, 0]\n                    yArray1[0] = p.yArray[0];\n                    yArray2[0] = p.yArray[0] - p.difference![0];\n                    // yArray1[3] = p.yArray[3] + p.difference![3];\n                    // yArray2[3] = p.yArray[3];\n                    yArray1[4] = p.yArray[4] + p.difference![4];\n                    yArray2[4] = p.yArray[4];\n                    if (p.difference![1] < 0) {\n                        yArray1[1] = p.yArray[1];\n                        yArray2[1] = p.yArray[1] - p.difference![1];\n                    } else {\n                        yArray1[1] = p.yArray[1] + p.difference![1];\n                        yArray2[1] = p.yArray[1]\n                    }\n                    if (p.difference![2] < 0) {\n                        yArray1[2] = p.yArray[2] + p.difference![2];\n                        yArray2[2] = p.yArray[2];\n                    } else {\n                        yArray1[2] = p.yArray[2];\n                        yArray2[2] = p.yArray[2] - p.difference![2];\n                    }\n                    if(p.difference![3] <= 0 || p.difference![3] >= 0){\n                        yArray1[3] = (p.yArray[3] * 2 + p.difference![3]) / 2; \n                        yArray2[3] = (p.yArray[3] * 2 - p.difference![3]) / 2; \n                    }\n                    const firstNode = new TrendTree(p, true, p.index, yArray1, null);\n                    const secondNode = new TrendTree(p, false, p.index, yArray2, null);\n                    newTreeNode.push(firstNode);\n                    newTreeNode.push(secondNode);\n                    p = p.nextSibling;\n                    count++;\n                    if (p === null || count >= difVals.length) {\n                        break;\n                    }\n\n                } else {\n                    console.log(losedRange[i][0], losedRange[i][1])\n                    console.log(\"lose range:\", losedRange, p, p?.index, j);\n                    console.log(this.levelIndexObjs);\n                    debugger\n                    throw new Error(\"dif not match node\");\n                }\n            }\n            for (let j = 0; j < newTreeNode.length - 1; j++) {\n                newTreeNode[j].nextSibling = newTreeNode[j + 1];\n                newTreeNode[j + 1].previousSibling = newTreeNode[j];\n                if (newTreeNode[j].index != newTreeNode[j + 1].index - 1) {\n                    throw new Error(\"sibling index error\");\n                }\n            }\n            if (this.levelIndexObjs[losedRange[i][0] + 1]) {\n                this.levelIndexObjs[losedRange[i][0] + 1].addLoadedDataRange(newTreeNode[0], [newTreeNode[0].index, newTreeNode[newTreeNode.length - 1].index]);\n            } else {\n                this.levelIndexObjs[losedRange[i][0] + 1] = new LevelIndexObj(losedRange[i][0] + 1, false);\n                this.levelIndexObjs[losedRange[i][0] + 1].addLoadedDataRange(newTreeNode[0], [newTreeNode[0].index, newTreeNode[newTreeNode.length - 1].index]);\n            }\n        }\n    }\n    constructTreeForBatchLoad(losedRange: Array<Array<number>>, difVals: Array<{ l: number, i: number, dif: Array<number> }>) {\n        let count = 0;\n        let nodeNum = 0;\n        for (let i = 0; i < losedRange.length; i++) {\n            const levelRange = losedRange[i];\n\n            const startNode = this.levelIndexObjs[losedRange[i][0] - 1].getTreeNodeStartIndex(Math.floor(losedRange[i][1] / 2));\n            let p = startNode;\n            const newTreeNode = [];\n            for (let j = Math.floor(losedRange[i][1] / 2); j <= Math.floor(losedRange[i][2] / 2); j++) {\n                if (p?.index === j && j === difVals[count].i && p.level === difVals[count].l) {\n                    //@ts-ignore\n                    p.difference = difVals[count].dif;\n                    // const yArray1: [number, number, number, number] = [0, 0, 0, 0]\n                    // const yArray2: [number, number, number, number] = [0, 0, 0, 0]\n                    // yArray1[0] = p.yArray[0];\n                    // yArray2[0] = p.yArray[0] - p.difference![0];\n                    // yArray1[3] = p.yArray[3] + p.difference![3];\n                    // yArray2[3] = p.yArray[3];\n                    // if (p.difference![1] < 0) {\n                    //     yArray1[1] = p.yArray[1];\n                    //     yArray2[1] = p.yArray[1] - p.difference![1];\n                    // } else {\n                    //     yArray1[1] = p.yArray[1] + p.difference![1];\n                    //     yArray2[1] = p.yArray[1]\n                    // }\n                    // if (p.difference![2] < 0) {\n                    //     yArray1[2] = p.yArray[2] + p.difference![2];\n                    //     yArray2[2] = p.yArray[2];\n                    // } else {\n                    //     yArray1[2] = p.yArray[2];\n                    //     yArray2[2] = p.yArray[2] - p.difference![2];\n                    // }\n                    const yArray1: [number, number, number, number, number] = [0, 0, 0, 0, 0]\n                    const yArray2: [number, number, number, number, number] = [0, 0, 0, 0, 0]\n                    yArray1[0] = p.yArray[0];\n                    yArray2[0] = p.yArray[0] - p.difference![0];\n                    // yArray1[3] = p.yArray[3] + p.difference![3];\n                    // yArray2[3] = p.yArray[3];\n                    yArray1[4] = p.yArray[4] + p.difference![4];\n                    yArray2[4] = p.yArray[4];\n                    if (p.difference![1] < 0) {\n                        yArray1[1] = p.yArray[1];\n                        yArray2[1] = p.yArray[1] - p.difference![1];\n                    } else {\n                        yArray1[1] = p.yArray[1] + p.difference![1];\n                        yArray2[1] = p.yArray[1]\n                    }\n                    if (p.difference![2] < 0) {\n                        yArray1[2] = p.yArray[2] + p.difference![2];\n                        yArray2[2] = p.yArray[2];\n                    } else {\n                        yArray1[2] = p.yArray[2];\n                        yArray2[2] = p.yArray[2] - p.difference![2];\n                    }\n                    if(p.difference![3] <= 0 || p.difference![3] >= 0){\n                        yArray1[3] = (p.yArray[3] * 2 + p.difference![3]) / 2; \n                        yArray2[3] = (p.yArray[3] * 2 - p.difference![3]) / 2; \n                    }\n                    const firstNode = new TrendTree(p, true, p.index, yArray1, null);\n                    const secondNode = new TrendTree(p, false, p.index, yArray2, null);\n                    this.cacheMap.set(firstNode.index, firstNode);\n                    this.cacheMap.set(secondNode.index, secondNode);\n                    nodeNum += 2\n                    newTreeNode.push(firstNode);\n                    newTreeNode.push(secondNode);\n                    p = p.nextSibling;\n                    count++;\n                    if (p === null || count >= difVals.length) {\n                        break;\n                    }\n\n                } else {\n                    console.log(losedRange[i][0] - 1, Math.floor(losedRange[i][1] / 2))\n                    console.log(\"lose range:\", losedRange, p, p?.index, j);\n                    console.log(this.levelIndexObjs);\n                    debugger\n                    throw new Error(\"dif not match node\");\n                }\n            }\n            for (let j = 0; j < newTreeNode.length - 1; j++) {\n                newTreeNode[j].nextSibling = newTreeNode[j + 1];\n                newTreeNode[j + 1].previousSibling = newTreeNode[j];\n                if (newTreeNode[j].index != newTreeNode[j + 1].index - 1) {\n                    throw new Error(\"sibling index error\");\n                }\n\n            }\n            if (this.levelIndexObjs[losedRange[i][0]]) {\n                this.levelIndexObjs[losedRange[i][0]].addLoadedDataRange(newTreeNode[0], [newTreeNode[0].index, newTreeNode[newTreeNode.length - 1].index]);\n            } else {\n                this.levelIndexObjs[losedRange[i][0]] = new LevelIndexObj(losedRange[i][0], false);\n                this.levelIndexObjs[losedRange[i][0]].addLoadedDataRange(newTreeNode[0], [newTreeNode[0].index, newTreeNode[newTreeNode.length - 1].index]);\n            }\n        }\n    }\n\n    async viewChangeInteraction(currentLevel: number, width: number, timeRange: Array<number>, yScale: any) {\n        // console.time(\"v_c\")\n        const nonUniformColObjs = computeTimeSE(currentLevel, width, timeRange, this.realDataRowNum, this.maxLevel, this.dataName);\n        //drawViewChangeLineChart({ dataManager:this,data: {maxv:0,minv:0,powRenderData:[],noPowRenderData:[]}, startTime: 0, endTime: timeRange[1], algorithm: \"trendtree\", width:width, height: 600 })\n        //context!.commit(\"addViewChangeQueryNoPowLineChartObj\", { dataManager:this,data: nonUniformColObjs, startTime: 0, endTime: timeRange[1], algorithm: \"trendtree\", width:width, height: 600 });\n\n        let needLoadDifNode: Array<TrendTree> = [];\n        let colIndex = 0;\n        for (let i = 0; i < this.levelIndexObjs[currentLevel].firstNodes.length; i++) {\n            const firtIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n            if (firtIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while (p != null) {\n                    if (colIndex >= nonUniformColObjs.length) {\n                        break;\n                        //throw new Error(\"col index out range\");\n                    }\n                    const type = nonUniformColObjs[colIndex].isContain(p);\n                    if (type === 1) {\n                        p = p.nextSibling!;\n                    } else if (type === 2) {\n                        needLoadDifNode.push(p);\n                        p = p.nextSibling!;\n                    } else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!\n                    } else if (type === 6) {\n                        //throw new Error(\"error in viewchange\")\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }\n\n        }\n        //const draw=drawViewChangeLineChart({width:600,height:600,minv:0,maxv:1000,x:10,y:10})\n        //draw(nonUniformColObjs)\n        if (needLoadDifNode.length === 0) {\n            //debugger\n            return nonUniformColObjs;\n        }\n        let losedDataInfo = computeLosedDataRange(needLoadDifNode);\n        if (losedDataInfo.length === 0) {\n            return nonUniformColObjs;\n        }\n        const currentLevelLosedRange = [];\n        for (let j = 0; j < losedDataInfo.length; j++) {\n            const level = losedDataInfo[j][0];\n            const start = losedDataInfo[j][1];\n            const end = losedDataInfo[j][2];\n            if (this.levelIndexObjs[level]) {\n\n                const hasData = this.levelIndexObjs[level].hasDataForRange(start, end);\n                if (!hasData.has) {\n                    const losedRange = hasData.range;\n                    losedRange.forEach(range => {\n                        range.unshift(level);\n                        currentLevelLosedRange.push(range);\n                    });\n                    //debugger\n                }\n            } else {\n                currentLevelLosedRange.push([level, start, end]);\n            }\n        }\n        if (currentLevelLosedRange.length > 0) {\n            await batchLoadDataForRangeLevel(currentLevelLosedRange, this);\n        }\n\n        let countNum = 1\n        while (needLoadDifNode.length > 0) {\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n\n            needLoadDifNode.forEach(v => {\n                if (v._leftChild === null || v._rightChild === null) {\n                    debugger\n                    throw new Error(\"cannot find next level node\");\n                }\n                tempQue.push(v._leftChild!);\n                tempQue.push(v._rightChild!);\n            });\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    //break;\n                    throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isContain(tempQue[i]);\n                if (type === 1) {\n                    continue;\n                } else if (type === 2) {\n                    tempNeedLoadDifNodes.push(tempQue[i]);\n                    preColIndex.push(colIndex);\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            for (let i = 0; i < tempNeedLoadDifNodes.length; i++) {\n                const con1 = canCut(tempNeedLoadDifNodes[i], nonUniformColObjs[preColIndex[i]], nonUniformColObjs[preColIndex[i] + 1], yScale);\n                if (con1) {\n                    tempNeedLoadDifNodes.splice(i, 1)\n                    preColIndex.splice(i, 1);\n                }\n            }\n            //this.checkMonotonicity(nonUniformColObjs,preColIndex,tempNeedLoadDifNodes);\n            needLoadDifNode = tempNeedLoadDifNodes;\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                //console.log(\"last level:\",needLoadDifNode.length);\n                for (let i = 0; i < needLoadDifNode.length; i++) {\n\n                    nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[0]);\n                    nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[0]);\n                    nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[3]);\n                    nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[3]);\n                }\n                break;\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n            let losedDataInfo = computeLosedDataRange(needLoadDifNode);\n            const currentLevelLosedRange = [];\n\n            for (let j = 0; j < losedDataInfo.length; j++) {\n                const level = losedDataInfo[j][0]\n                const start = losedDataInfo[j][1]\n                const end = losedDataInfo[j][2];\n                if (this.levelIndexObjs[level]) {\n\n                    const hasData = this.levelIndexObjs[level].hasDataForRange(start, end);\n                    if (!hasData.has) {\n                        const losedRange = hasData.range;\n                        losedRange.forEach(range => {\n                            range.unshift(level);\n                            currentLevelLosedRange.push(range);\n                        });\n                    }\n                } else {\n                    currentLevelLosedRange.push([level, start, end]);\n                }\n            }\n\n            await batchLoadDataForRangeLevel(currentLevelLosedRange, this);\n        }\n        //console.timeEnd(\"v_c\")\n        //draw(nonUniformColObjs)\n        return nonUniformColObjs;\n    }\n\n    async viewChangeInteraction1(currentLevel: number, width: number, timeRange: Array<number>, yScale: any) {\n        allTimes = []\n        // console.time(\"v_c\")\n        const nonUniformColObjs = computeTimeSE(currentLevel, width, timeRange, this.realDataRowNum, this.maxLevel);\n        let needLoadDifNode: Array<TrendTree> = [];\n        let colIndex = 0;\n        for (let i = 0; i < this.levelIndexObjs[currentLevel].firstNodes.length; i++) {\n            const firtIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n            if (firtIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while (p != null) {\n                    if (colIndex >= nonUniformColObjs.length) {\n                        break;\n                        //throw new Error(\"col index out range\");\n                    }\n                    const type = nonUniformColObjs[colIndex].isContain(p);\n                    if (type === 1) {\n                        p = p.nextSibling!;\n                    } else if (type === 2) {\n                        needLoadDifNode.push(p);\n                        p = p.nextSibling!;\n                    } else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!\n                    } else if (type === 6) {\n                        // throw new Error(\"error in viewchange\")\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }\n\n        }\n        if (needLoadDifNode.length === 0) {\n            const sumTime = allTimes.reduce((pre: any, cur: any) => pre + cur, 0)\n            allSumTimes.push(sumTime)\n            allTimes = [];\n            if (allSumTimes.length >= 50) {\n                console.log(allSumTimes)\n            }\n            //debugger\n            return nonUniformColObjs;\n        }\n        let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n        //console.log(losedDataInfo)\n        // if (losedDataInfo.length === 0) {\n        //     return nonUniformColObjs;\n        // }\n\n        if (losedDataInfo.length > 0) {\n            const startTime = new Date().getTime()\n            await batchLoadDataForRangeLevel1(losedDataInfo, this);\n            allTimes.push(new Date().getTime() - startTime)\n        }\n\n\n        while (needLoadDifNode.length > 0) {\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n\n            needLoadDifNode.forEach(v => {\n                if (v._leftChild === null || v._rightChild === null) {\n                    console.log(v)\n                    console.log(this)\n                    debugger\n                    throw new Error(\"cannot find next level node\");\n                }\n                tempQue.push(v._leftChild!);\n                tempQue.push(v._rightChild!);\n            });\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    break;\n                    //throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isContain(tempQue[i]);\n                if (type === 1) {\n                    continue;\n                } else if (type === 2) {\n                    tempNeedLoadDifNodes.push(tempQue[i]);\n                    preColIndex.push(colIndex);\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            for (let i = 0; i < tempNeedLoadDifNodes.length; i++) {\n                if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                    const con1 = canCut(tempNeedLoadDifNodes[i], nonUniformColObjs[preColIndex[i]], nonUniformColObjs[preColIndex[i] + 1], yScale);\n                    if (con1) {\n                        tempNeedLoadDifNodes.splice(i, 1)\n                        preColIndex.splice(i, 1);\n                    }\n                }\n\n            }\n            //this.checkMonotonicity(nonUniformColObjs,preColIndex,tempNeedLoadDifNodes);\n            needLoadDifNode = tempNeedLoadDifNodes;\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                //console.log(\"last level:\",needLoadDifNode.length);\n                for (let i = 0; i < needLoadDifNode.length; i++) {\n\n                    nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[0]);\n                    nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[0]);\n\n                    if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                        nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[3]);\n                        nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[3]);\n                    }\n\n                }\n                break;\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n            let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n            if (losedDataInfo.length > 0) {\n                const startTime = new Date().getTime()\n                await batchLoadDataForRangeLevel1(losedDataInfo, this);\n                allTimes.push(new Date().getTime() - startTime)\n            }\n\n        }\n        const sumTime = allTimes.reduce((pre: any, cur: any) => pre + cur, 0)\n        // console.log(sumTime)\n        //allSumTimes.push(sumTime)\n        //allTimes = [];\n        //if(allSumTimes.length>=50){\n        //    console.log(allSumTimes)\n        // }\n        //console.timeEnd(\"v_c\")\n        return nonUniformColObjs;\n    }\n\n\n    checkLoadedDataInSingalLevel(losedDataInfo: Array<Array<number>>) {\n        const currentLevelLosedRange = [];\n        for (let j = 0; j < losedDataInfo.length; j++) {\n            const level = losedDataInfo[j][0]\n            const start = losedDataInfo[j][1]\n            const end = losedDataInfo[j][2];\n            if (this.levelIndexObjs[level]) {\n\n                const hasData = this.levelIndexObjs[level].hasDataForRange(start, end);\n                if (!hasData.has) {\n                    const losedRange = hasData.range;\n                    losedRange.forEach(range => {\n                        range.unshift(level);\n                        currentLevelLosedRange.push(range);\n                    });\n                }\n            } else {\n                currentLevelLosedRange.push([level, start, end]);\n            }\n        }\n        return currentLevelLosedRange\n    }\n    checkLoadedDataInSingalLevelV1(losedDataInfo: Array<Array<number>>) {\n        const currentLevelLosedRange = [];\n        for (let j = 0; j < losedDataInfo.length; j++) {\n            const level = losedDataInfo[j][0]\n            const start = losedDataInfo[j][1]\n            const end = losedDataInfo[j][2];\n            if (this.levelIndexObjs[level]) {\n\n                const hasData = this.levelIndexObjs[level].hasDataForRange(start, end);\n                if (!hasData.has) {\n                    const losedRange = hasData.range;\n                    losedRange.forEach(range => {\n                        range.unshift(level);\n                        currentLevelLosedRange.push(range);\n                    });\n                }\n            } else {\n                currentLevelLosedRange.push([level, start, end]);\n            }\n        }\n        return currentLevelLosedRange\n    }\n\n\n    getIndexTime(l: number, index: number, maxLevel: number) {\n        const gap = 2 ** maxLevel / (2 ** l)\n        const startTime = index * gap;\n        const endTime = startTime + gap - 1;\n        return {\n            startT: startTime,\n            endT: endTime\n        }\n    }\n\n    initCache() {\n        const options = {\n            max: 1000000,\n            maxSize: 1000000,\n            sizeCalculation: (value: any, key: string) => {\n                return 1\n            },\n            dispose: (value: any, key: string, reason: string) => {\n                if (reason === \"evict\") {\n                    console.log(key)\n                    this.deleteQueue.push(value);\n                }\n\n            },\n            disposeAfter: (value: any, key: string, reason: string) => {\n                //console.log(\"dispose after----------------------\",key,reason)\n            },\n            ttl: 1000 * 60 * 60,\n            allowStale: false,\n            updateAgeOnGet: true,\n            updateAgeOnHas: true,\n\n        }\n        this.lruCache = new Cache(options);\n        this.evictTreeNode()\n        return\n    }\n\n\n    evictTreeNode() {\n        setInterval(() => {\n            if (this.isIntering) {\n                return\n            }\n            this.isEvicting = true\n            this.deleteQueue.forEach((curNode) => {\n                const l = curNode.level;\n                const i = curNode.index;\n                this.lruCache.delete(l + \"_\" + i);\n                if (this.levelIndexObjs[l].hasDataForRange(i, i).has) {\n                    this.deleteNodeWhithChild(l, i);\n                    console.log(\"evict l:\" + l + \" i:\" + i + \" finish!\")\n                }\n            })\n            this.isEvicting = false\n        }, 1000)\n\n    }\n\n\n    deleteNodeWhithChild(level: number, index: number) {\n\n        let curLS = index;\n        let curRS = index;\n        for (let j = level; j < this.maxLevel - 1; j++) {\n            if (j == level) {\n                curLS = index;\n                curRS = index;\n            } else {\n                curLS = 2 ** (j - level) * curLS;\n                curRS = 2 ** (j - level) * curRS + 1;\n            }\n            const curLLoadedRange = this.levelIndexObjs[j].loadedDataRange;\n            const curFirstNodes = this.levelIndexObjs[j].firstNodes;\n\n            if (!curLLoadedRange || !curFirstNodes) {\n                break;\n            }\n\n            const newFirstNodes: Array<TrendTree> = [];\n            const newLoadDataRanges = [];\n            for (let i = 0; i < curLLoadedRange.length; i++) {\n                const curRange0 = curLLoadedRange[i];\n                if (curRange0[1] < curRS) {\n                    newFirstNodes.push(curFirstNodes[i]);\n                    newLoadDataRanges.push([curRange0[0], curRange0[1]]);\n                } else if (curRange0[0] < curLS && curRange0[1] === curLS) {\n                    if (curFirstNodes[i].nextSibling) {\n                        newLoadDataRanges.push([curRange0[0], curRange0[1] - 1]);\n                        newFirstNodes.push(curFirstNodes[i])\n                    }\n                    let curP = curFirstNodes[i];\n                    while (curP) {\n                        if (curP.index === curLS) {\n                            if (curP.previousSibling) {\n                                curP.previousSibling.nextSibling = null\n                                curP.previousSibling = null\n                            }\n                            break;\n                        }\n                        //@ts-ignore\n                        curP = curP.nextSibling\n                    }\n                    if (curP === null) {\n                        throw new Error(\"cannot find range node\");\n                    }\n                } else if (curRange0[0] < curLS && curRange0[1] > curLS && curRange0[1] < curRS) {\n                    newFirstNodes.push(curFirstNodes[i]);\n                    newLoadDataRanges.push([curRange0[0], curLS - 1]);\n                    let curP = curFirstNodes[i];\n                    while (curP) {\n                        if (curP.index === curLS) {\n                            if (curP.previousSibling) {\n                                curP.previousSibling.nextSibling = null\n                                curP.previousSibling = null\n                            }\n                            break;\n                        }\n                        //@ts-ignore\n                        curP = curP.nextSibling\n                    }\n                    if (curP === null) {\n                        throw new Error(\"cannot find range node\");\n                    }\n                } else if (curRange0[0] < curLS && curRange0[1] === curRS) {\n                    newFirstNodes.push(curFirstNodes[i]);\n                    newLoadDataRanges.push([curRange0[0], curLS - 1]);\n                    let curP = curFirstNodes[i];\n                    while (curP) {\n                        if (curP.index === curLS) {\n                            if (curP.previousSibling) {\n                                curP.previousSibling.nextSibling = null;\n                                curP.previousSibling = null;\n                            }\n                            break;\n                        }\n                        //@ts-ignore\n                        curP = curP.nextSibling\n                    }\n                    if (curP === null) {\n                        throw new Error(\"cannot find range node\");\n                    }\n\n                } else if (curRange0[0] < curLS && curRange0[1] > curRS) {\n                    //debugger\n                    newFirstNodes.push(curFirstNodes[i]);\n                    newLoadDataRanges.push([curRange0[0], curLS - 1])\n\n                    let curP = curFirstNodes[i];\n                    while (curP) {\n                        if (curP.index === curLS) {\n                            if (curP.previousSibling) {\n                                curP.previousSibling.nextSibling = null\n                                curP.previousSibling = null;\n                            }\n                        }\n                        if (curP.index === curRS) {\n                            if (curP.nextSibling) {\n                                newFirstNodes.push(curP.nextSibling);\n                                newLoadDataRanges.push([curRS + 1, curRange0[1]]);\n                                curP.nextSibling.previousSibling = null;\n                                curP.nextSibling = null\n                            }\n                            break;\n                        }\n                        //@ts-ignore\n                        curP = curP.nextSibling\n                    }\n                    if (curP === null) {\n                        throw new Error(\"cannot find range node\");\n                    }\n\n                } else if (curRange0[0] === curLS && curRange0[1] > curRS) {\n                    let curP = curFirstNodes[i];\n                    while (curP) {\n                        if (curP.index === curRS) {\n                            if (curP.nextSibling) {\n                                newFirstNodes.push(curP.nextSibling);\n                                newLoadDataRanges.push([curRS + 1, curRange0[1]]);\n                                curP.nextSibling.previousSibling = null;\n                                curP.nextSibling = null\n                            }\n                            break;\n                        }\n                        //@ts-ignore\n                        curP = curP.nextSibling\n                    }\n                    if (curP === null) {\n                        throw new Error(\"cannot find range node\");\n                    }\n\n                } else if (curRange0[0] === curLS && curRange0[1] === curRS) {\n                    continue;\n                } else if (curRange0[0] === curLS && curRange0[1] < curRS) {\n                    continue\n                } else if (curRange0[0] > curLS && curRange0[1] > curRS && curRange0[0] < curRS) {\n                    let curP = curFirstNodes[i];\n                    while (curP) {\n                        if (curP.index === curRS) {\n                            if (curP.nextSibling) {\n                                newFirstNodes.push(curP.nextSibling);\n                                newLoadDataRanges.push([curRS + 1, curRange0[1]]);\n                                curP.nextSibling.previousSibling = null;\n                                curP.nextSibling = null;\n                            }\n                            break;\n                        }\n                        //@ts-ignore\n                        curP = curP.nextSibling\n                    }\n                    if (curP === null) {\n                        throw new Error(\"cannot find range node\");\n                    }\n                } else if (curRange0[0] > curLS && curRange0[0] === curRS) {\n                    if (curFirstNodes[i].nextSibling) {\n                        newFirstNodes.push(curFirstNodes[i].nextSibling!)\n                        newLoadDataRanges.push([curRange0[0] + 1, curRange0[1]])\n                        curFirstNodes[i]!.nextSibling!.previousSibling = null\n                        curFirstNodes[i].nextSibling = null\n\n                    }\n\n                } else if (curRange0[0] > curRS) {\n                    newFirstNodes.push(curFirstNodes[i])\n                    newLoadDataRanges.push([curRange0[0], curRange0[1]])\n                } else if (curRange0[0] > curLS && curRange0[1] === curRS) {\n                    continue\n                }\n                else {\n                    console.log(curRange0, curLS, curRS)\n                    throw new Error(\"range error\");\n\n                }\n            }\n\n            this.levelIndexObjs[j].loadedDataRange = newLoadDataRanges;\n            this.levelIndexObjs[j].firstNodes = newFirstNodes;\n        }\n    }\n\n\n    updateMaxCacheSize(size: number) {\n        this.maxCacheNodeNum = size;\n    }\n\n    \n    lruCacheDelete() {\n        console.log(this.cacheMap.size)\n        if (this.cacheMap.size <= this.maxCacheNodeNum) {\n\n            return\n        }\n        let needDeleteNum = this.cacheMap.size - this.maxCacheNodeNum\n        if (needDeleteNum % 2 != 0) {\n            needDeleteNum++\n        }\n        console.log(\"delete nums:\", needDeleteNum)\n        for (let i = this.levelIndexObjs.length - 2; i > 0; i--) {\n            if (needDeleteNum <= 0) {\n                break\n            }\n            const levelObj = this.levelIndexObjs[i];\n            for (let j = 0; j < levelObj.firstNodes.length; j++) {\n                let firstNode = levelObj.firstNodes[j];\n                this.levelIndexObjs[firstNode.level + 1].loadedDataRange = [];\n                this.levelIndexObjs[firstNode.level + 1].firstNodes = [];\n                this.levelIndexObjs[firstNode.level + 1].isFull = false;\n                while (firstNode) {\n                    if (firstNode._leftChild) {\n                        this.cacheMap.delete(firstNode._leftChild.index)\n                    }\n                    if (firstNode._rightChild) {\n                        this.cacheMap.delete(firstNode._rightChild.index)\n                    }\n                    //@ts-ignore\n                    firstNode = firstNode.nextSibling\n                    needDeleteNum -= 2;\n                }\n            }\n        }\n    }\n\n\n    async computePowCon(currentLevel: number, width: number, gapNeedNodes: Array<TrendTree>, nonUniformColObjs: Array<NoUniformColObj>) {\n        //debugger\n        console.log(\"pwo:\", width)\n        const times = [];\n        let needLoadDifNode: Array<TrendTree> = [];\n        if (gapNeedNodes.length % width !== 0) {\n            throw new Error(\"gap node not match widht\")\n        }\n        const timeNum = gapNeedNodes.length / width;\n        const groups = new Array<Array<TrendTree>>(width)\n        for (let i = 0; i < groups.length; i++) {\n            groups[i] = []\n        }\n        if (timeNum > 1) {\n            for (let i = 0; i < gapNeedNodes.length; i++) {\n                const groupIdx = Math.floor(i / timeNum)\n                groups[groupIdx].push(gapNeedNodes[i])\n            }\n            for (let i = 0; i < groups.length - 1; i++) {\n                const group = groups[i];\n                const secGroup = groups[i + 1]\n                needLoadDifNode.push(group[group.length - 1])\n                needLoadDifNode.push(secGroup[0])\n            }\n        } else {\n            needLoadDifNode = gapNeedNodes;\n        }\n\n\n        let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n\n\n        if (losedDataInfo.length > 0) {\n            const levelTime = new Date().getTime()\n            await batchLoadDataForRangeLevel1(losedDataInfo, this);\n            times.push(new Date().getTime() - levelTime);\n        } else {\n            times.push(1)\n        }\n        //debugger\n        let columnGapArray: Array<UniformGapObj> = [];\n        if (timeNum == 1) {\n            for (let i = 0; i < needLoadDifNode.length - 1; i++) {\n                // debugger\n                if (needLoadDifNode[i]._rightChild && needLoadDifNode[i + 1]._leftChild) {\n                    const columnGap = new UniformGapObj(needLoadDifNode[i], needLoadDifNode[i + 1])\n                    columnGapArray.push(columnGap);\n                } else {\n                    throw new Error(\"children cannot empty\")\n                }\n            }\n        } else {\n            for (let i = 0; i < needLoadDifNode.length; i += 2) {\n                if (needLoadDifNode[i]._rightChild && needLoadDifNode[i + 1]._leftChild) {\n                    const columnGap = new UniformGapObj(needLoadDifNode[i], needLoadDifNode[i + 1])\n                    columnGapArray.push(columnGap);\n                } else {\n                    throw new Error(\"children cannot empty\")\n                }\n            }\n            for (let i = 0; i < groups.length - 1; i++) {\n                const group1 = groups[i];\n                const group2 = groups[i + 1];\n                for (let j = 0; j < group1.length - 1; j++) {\n                    columnGapArray[i].updateLeftMinMax(group1[j])\n                }\n                for (let j = 1; j < group2.length; j++) {\n                    columnGapArray[i].updateRighetMinMax(group2[j])\n                }\n            }\n        }\n        let con = true\n        while (con) {\n            //debugger\n            let isFinish = false\n            needLoadDifNode = []\n            for (let i = 0; i < columnGapArray.length; i++) {\n                const isCut = columnGapArray[i].canCut()\n                isFinish = isCut && isFinish\n                if (!isCut) {\n                    needLoadDifNode.push(columnGapArray[i].firstNode);\n                    needLoadDifNode.push(columnGapArray[i].secondNode);\n                }\n            }\n            if (isFinish) {\n                break;\n            }\n            if (needLoadDifNode.length == 0) {\n                break\n            }\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                for (let i = 0; i < columnGapArray.length; i++) {\n                    const colGap = columnGapArray[i];\n                    if (!colGap.isOk) {\n                        if (colGap.firstNode && colGap.secondNode) {\n                            colGap.lastLevelUpdateMinMax()\n                        }\n                    }\n                }\n                break;\n            }\n            losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n            if (losedDataInfo.length > 0) {\n                const levelTime = new Date().getTime()\n                await batchLoadDataForRangeLevel1(losedDataInfo, this);\n                times.push(new Date().getTime() - levelTime);\n            }\n            for (let i = 0; i < columnGapArray.length; i++) {\n                const colGap = columnGapArray[i];\n                if (!colGap.isOk) {\n                    if (colGap.firstNode._rightChild && colGap.secondNode._leftChild) {\n                        colGap.updateTwoNode(colGap.firstNode, colGap.secondNode);\n                    }\n                }\n            }\n        }\n        if (nonUniformColObjs.length !== columnGapArray.length + 1) {\n            throw new Error(\"column not match gap\")\n        }\n        for (let i = 0; i < columnGapArray.length; i++) {\n            const colGap = columnGapArray[i];\n            if (colGap.canUseT) {\n                nonUniformColObjs[i].endV = colGap.tOne;\n                nonUniformColObjs[i].startV = colGap.tOne;\n            }\n        }\n\n        if (times.length >= 3) {\n            allTimes.push(times[0])\n            //allTimes.push(times[1])\n        }\n        console.log(allTimes)\n        console.log(times)\n        return nonUniformColObjs\n\n    }\n\n\n    bfsSearchTree(currentLevel: number, width: number, timeRange: Array<number>, nonUniformColObjs: Array<NoUniformColObj>) {\n        let needLoadDifNode: Array<TrendTree> = [];\n        let colIndex = 0;\n        for (let i = 0; i < this.levelIndexObjs[currentLevel].firstNodes.length; i++) {\n            const firtIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n            if (firtIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while (p != null) {\n                    if (colIndex >= nonUniformColObjs.length) {\n                        break;\n                        //throw new Error(\"col index out range\");\n                    }\n                    const type = nonUniformColObjs[colIndex].isContain(p);\n                    if (type === 1) {\n                        p = p.nextSibling!;\n                    } else if (type === 2) {\n                        needLoadDifNode.push(p);\n                        p = p.nextSibling!;\n                    } else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!\n                    } else if (type === 6) {\n                        throw new Error(\"error in viewchange\")\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }\n\n        }\n        if (needLoadDifNode.length === 0) {\n            //debugger\n            return nonUniformColObjs;\n        }\n\n        while (needLoadDifNode.length > 0) {\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n\n            needLoadDifNode.forEach(v => {\n                if (v._leftChild === null || v._rightChild === null) {\n                    console.log(v)\n                    console.log(this)\n                    debugger\n                    throw new Error(\"cannot find next level node\");\n                }\n                tempQue.push(v._leftChild!);\n                tempQue.push(v._rightChild!);\n            });\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    break;\n                    //throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isContain(tempQue[i]);\n                if (type === 1) {\n                    continue;\n                } else if (type === 2) {\n                    tempNeedLoadDifNodes.push(tempQue[i]);\n                    preColIndex.push(colIndex);\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            for (let i = 0; i < tempNeedLoadDifNodes.length; i++) {\n                if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                    const con1 = canCut(tempNeedLoadDifNodes[i], nonUniformColObjs[preColIndex[i]], nonUniformColObjs[preColIndex[i] + 1], '');\n                    if (con1) {\n                        tempNeedLoadDifNodes.splice(i, 1)\n                        preColIndex.splice(i, 1);\n                    }\n                }\n\n            }\n            needLoadDifNode = tempNeedLoadDifNodes;\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                //console.log(\"last level:\",needLoadDifNode.length);\n                for (let i = 0; i < needLoadDifNode.length; i++) {\n\n                    nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[0]);\n                    nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[0]);\n\n                    if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                        nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[3]);\n                        nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[3]);\n                    }\n                }\n                break;\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n        }\n        return nonUniformColObjs;\n    }\n\n    async viewChangeInteraction1WS(currentLevel: number, width: number, timeRange: Array<number>, yScale: any, props?: any) {\n        // while(this.isEvicting){console.log()};\n        this.isIntering = true\n        const tagName = \"\" + Math.random() + \"\" + Math.random()\n        allTimes = []\n        // console.time(\"v_c\")\n        const nonUniformColObjs = computeTimeSE(currentLevel, width, timeRange, this.realDataRowNum, this.maxLevel);\n        let needLoadDifNode: Array<TrendTree> = [];\n        let colIndex = 0;\n        for (let i = 0; i < this.levelIndexObjs[currentLevel].firstNodes.length; i++) {\n            const firtIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n            if (firtIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while (p != null) {\n                    if (colIndex >= nonUniformColObjs.length) {\n                        break;\n                        //throw new Error(\"col index out range\");\n                    }\n                    const type = nonUniformColObjs[colIndex].isContain(p);\n                    if (type === 1) {\n                        p = p.nextSibling!;\n                    } else if (type === 2) {\n                        needLoadDifNode.push(p);\n                        p = p.nextSibling!;\n                    } else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!\n                    } else if (type === 6) {\n                        throw new Error(\"error in viewchange\")\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }\n\n        }\n        if (needLoadDifNode.length === 0) {\n            const sumTime = allTimes.reduce((pre: any, cur: any) => pre + cur, 0)\n            allSumTimes.push(sumTime)\n            await batchLoadDataForRangeLevel1WS([], this, \"empty\");\n            allTimes = [];\n            if (allSumTimes.length >= 50) {\n                console.log(allSumTimes)\n            }\n            //debugger\n            return nonUniformColObjs;\n        }\n        let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n\n\n        if (losedDataInfo.length > 0) {\n            const startTime = new Date().getTime()\n            await batchLoadDataForRangeLevel1WS(losedDataInfo, this, tagName);\n            allTimes.push(new Date().getTime() - startTime)\n        }\n\n\n        while (needLoadDifNode.length > 0) {\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n\n            needLoadDifNode.forEach(v => {\n                if (v._leftChild === null || v._rightChild === null) {\n                    debugger\n                    throw new Error(\"cannot find next level node\");\n                }\n                tempQue.push(v._leftChild!);\n                tempQue.push(v._rightChild!);\n                const leftHas = this.lruCache.has(v._leftChild.level + \"_\" + v._leftChild.index);\n                const rightHas = this.lruCache.has(v._rightChild.level + \"_\" + v._rightChild.index);\n                // if(!leftHas){\n                //     console.log(\"fddddd\",v._leftChild.level)\n                // }\n\n            });\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    break;\n                    //throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isContain(tempQue[i]);\n                if (type === 1) {\n                    continue;\n                } else if (type === 2) {\n                    tempNeedLoadDifNodes.push(tempQue[i]);\n                    preColIndex.push(colIndex);\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            for (let i = 0; i < tempNeedLoadDifNodes.length; i++) {\n                if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                    const con1 = canCut(tempNeedLoadDifNodes[i], nonUniformColObjs[preColIndex[i]], nonUniformColObjs[preColIndex[i] + 1], yScale);\n                    if (con1) {\n                        tempNeedLoadDifNodes.splice(i, 1)\n                        preColIndex.splice(i, 1);\n                    }\n                }\n\n            }\n            //this.checkMonotonicity(nonUniformColObjs,preColIndex,tempNeedLoadDifNodes);\n            needLoadDifNode = tempNeedLoadDifNodes;\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                //console.log(\"last level:\",needLoadDifNode.length);\n                for (let i = 0; i < needLoadDifNode.length; i++) {\n\n                    nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[0]);\n                    nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[0]);\n\n                    if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                        nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[3]);\n                        nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[3]);\n                    }\n\n                }\n                break;\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n            let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n            if (losedDataInfo.length > 0) {\n                const startTime = new Date().getTime()\n                await batchLoadDataForRangeLevel1WS(losedDataInfo, this, tagName);\n                allTimes.push(new Date().getTime() - startTime)\n            }\n\n        }\n        if (props && props.rootT) {\n            console.log(\"roott:\", props.rootT)\n            allTimes.push(props.rootT);\n        }\n        //console.log(allTimes)\n        const sumTime = allTimes.reduce((pre: any, cur: any) => pre + cur, 0)\n        allSumTimes.push(sumTime);\n        if (allSumTimes.length === 6) {\n            pushTimeArray(allSumTimes);\n            allSumTimes = []\n        }\n\n        console.log(\"AllLevelTime:\", allSumTimes);\n        await batchLoadDataForRangeLevel1WS(losedDataInfo, this, \"empty\");\n        this.isIntering = false;\n        return nonUniformColObjs;\n    }\n\n\n    async viewChangeInteractionFinal(currentLevel: number, width: number, timeRange: Array<number>, yScale: any) {\n        console.log(currentLevel, width, timeRange)\n        const dataName = this.dataName.includes(\".\") ? this.dataName.split(\".\")[1] : this.dataName;\n        const currentFlagInfo = store.state.allFlags[this.dataName];\n        if (currentFlagInfo === undefined) {\n            throw new Error(this.dataName + \"get flag faild\")\n        } else {\n            console.log(\"flag length:\", currentFlagInfo.length)\n        }\n\n        allTimes = []\n        // console.time(\"v_c\")\n        const nonUniformColObjs = computeTimeSE(currentLevel, width, timeRange, this.realDataRowNum, this.maxLevel);\n        let needLoadDifNode: Array<TrendTree> = [];\n        let colIndex = 0;\n\n        for (let i = 0; i < this.levelIndexObjs[currentLevel].firstNodes.length; i++) {\n            const firtIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n\n            if (firtIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while (p != null) {\n                    if (colIndex >= nonUniformColObjs.length) {\n                        break;\n                        //throw new Error(\"col index out range\");\n                    }\n                    const type = nonUniformColObjs[colIndex].isMissContain(p);\n                    nonUniformColObjs[colIndex].containColumnRange(p, type);\n                    if (type === 1) {\n                        p = p.nextSibling!;\n                    } else if (type === 2) {\n                        needLoadDifNode.push(p);\n                        p = p.nextSibling!;\n                    } else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!\n                    } else if (type === 6) {\n                        throw new Error(\"error in viewchange\")\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }\n\n        }\n\n        if (needLoadDifNode.length === 0) {\n            return nonUniformColObjs;\n        }\n\n        let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n\n\n        if (losedDataInfo.length > 0) {\n\n            await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, this);\n        }\n\n\n        while (needLoadDifNode.length > 0) {\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n\n            needLoadDifNode.forEach(v => {\n                if (v._leftChild === null || v._rightChild === null) {\n                    console.log(v)\n                    console.log(this)\n                    debugger\n                    throw new Error(\"cannot find next level node\");\n                }\n                this.lruCache.has(v._leftChild.level + \"_\" + v._leftChild.index);\n                this.lruCache.has(v._rightChild.level + \"_\" + v._rightChild.index);\n                if (v._leftChild.nodeType !== 'NULL') {\n                    tempQue.push(v._leftChild!);\n                }\n                if (v._rightChild.nodeType !== 'NULL') {\n                    tempQue.push(v._rightChild!);\n                }\n            });\n            // loadedDataSize += Math.floor(Math.random() * (500 - 0 + 1)) + 500;\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    break;\n                    //throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isMissContain(tempQue[i]);\n                nonUniformColObjs[colIndex].containColumnRange(tempQue[i], type);\n                if (type === 1) {\n                    continue;\n                } else if (type === 2) {\n                    tempNeedLoadDifNodes.push(tempQue[i]);\n                    preColIndex.push(colIndex);\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            for (let i = 0; i < tempNeedLoadDifNodes.length; i++) {\n                if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                    const con1 = canCut(tempNeedLoadDifNodes[i], nonUniformColObjs[preColIndex[i]], nonUniformColObjs[preColIndex[i] + 1], yScale);\n                    if (con1) {\n                        tempNeedLoadDifNodes.splice(i, 1)\n                        preColIndex.splice(i, 1);\n                    }\n                }\n\n            }\n            //this.checkMonotonicity(nonUniformColObjs,preColIndex,tempNeedLoadDifNodes);\n            needLoadDifNode = tempNeedLoadDifNodes;\n\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n\n                console.log(\"last level:\", needLoadDifNode.length);\n\n                for (let i = 0; i < needLoadDifNode.length; i++) {\n                    const nodeFlag1 = currentFlagInfo[2 * needLoadDifNode[i].index];\n                    if (nodeFlag1 === 1) {\n                        throw new Error(\"flag error\")\n                    }\n                    const nodeFlag2 = currentFlagInfo[2 * needLoadDifNode[i].index + 1]\n                    if (nodeFlag2 === 0) {\n                        nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[1]);\n                        nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[1]);\n                        if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                            nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[2]);\n                            nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[2]);\n                        }\n                    } else {\n                        nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[2]);\n                        nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[2]);\n                        if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                            nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[1]);\n                            nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[1]);\n                        }\n                    }\n\n                }\n                break;\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n            let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n            if (losedDataInfo.length > 0) {\n                await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, this);\n            }\n\n        }\n        for (let i = 0; i < nonUniformColObjs.length; i++) {\n            nonUniformColObjs[i].checkIsMis();\n        }\n        return nonUniformColObjs;\n    }\n\n\n    async viewChangeInteractionFinal1(currentLevel: number, width: number, timeRange: Array<number>, yScale: any, drawer: any) {\n        \n        const currentFlagInfo = getFlag(this.dataName);\n        // const currentFlagInfo = getFlag(\"mock_guassian_sin_8m_om3_8m\");\n        if (currentFlagInfo === undefined) {\n            throw new Error(this.dataName + \" get flag faild\")\n        } else {\n            // console.log(\"flag length:\", currentFlagInfo.length)\n        }\n\n        allTimes = []\n        // console.time(\"v_c\")\n        let loadedDataSize = 0;\n        let size = 1;\n        const nonUniformColObjs = computeTimeSE(currentLevel, width, timeRange, this.realDataRowNum, this.maxLevel);\n        let needLoadDifNode: Array<TrendTree> = [];\n        let colIndex = 0;\n        loadedDataSize += Math.floor(Math.random() * (500 - 0 + 1)) + 500;\n        let startT = new Date().getTime();\n        for (let i = 0; i < this.levelIndexObjs[currentLevel].firstNodes.length; i++) {\n            const firtIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n\n            if (firtIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while (p != null) {\n                    if (colIndex >= nonUniformColObjs.length) {\n                        break;\n                        //throw new Error(\"col index out range\");\n                    }\n                    const type = nonUniformColObjs[colIndex].isMissContain(p);\n                    nonUniformColObjs[colIndex].containColumnRange(p, type);\n                    if (type === 1) {\n                        p = p.nextSibling!;\n                    } else if (type === 2 || type === 7 || type === 8 || type === 9 || type === 10) {\n                        if (type === 2) {\n                            needLoadDifNode.push(p);\n                        }\n                        if(type === 7 || type === 9){\n                            colIndex++;\n                        }\n                        p = p.nextSibling!;\n                    } else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!\n                    } else if (type === 6) {\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }else{\n                debugger\n            }\n        }\n        // debugger\n        if (needLoadDifNode.length === 0) {\n            return nonUniformColObjs;\n        }\n        loadedDataSize += needLoadDifNode.length*size;\n        let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n        // debugger\n        if (losedDataInfo.length > 0) {\n            await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, this);\n        }\n\n        while (needLoadDifNode.length > 0 && needLoadDifNode[0].level < 16) {\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n\n            needLoadDifNode.forEach(v => {\n                if ((v._leftChild === null || v._rightChild === null) && v.nodeType === 'O') {\n                // if ((v._leftChild != null && v._rightChild != null) && v.nodeType === 'O') {\n                    // debugger\n                    console.log(v.level);\n                    throw new Error(\"cannot find next level node\");\n                }\n                if (v.nodeType === 'NULL') {\n                    //\n                } else {\n                    this.lruCache.has(v._leftChild!.level + \"_\" + v._leftChild!.index);\n                    this.lruCache.has(v._rightChild!.level + \"_\" + v._rightChild!.index);\n                    if (v._leftChild!.nodeType !== 'NULL') {\n                        tempQue.push(v._leftChild!);\n                    }\n                    if (v._rightChild!.nodeType !== 'NULL') {\n                        tempQue.push(v._rightChild!);\n                    }\n                }\n\n            });\n\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    break;\n                    //throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isMissContain(tempQue[i]);\n                nonUniformColObjs[colIndex].containColumnRange(tempQue[i], type);\n                if (type === 1) {\n                    continue;\n                } else if (type === 2 || type === 7 || type === 8 || type === 9 || type === 10) {\n                    if (type === 2) {\n                        tempNeedLoadDifNodes.push(tempQue[i]);\n                        preColIndex.push(colIndex);\n                    }\n\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            needLoadDifNode = tempNeedLoadDifNodes;\n            loadedDataSize += needLoadDifNode.length*size;\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                for (let i = 0; i < needLoadDifNode.length; i++) {\n                    const nodeFlag2 = currentFlagInfo[2 * needLoadDifNode[i].index + 1]\n                    if (needLoadDifNode[i].gapFlag === 'NO') {\n                        if (nodeFlag2 === 0) {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[1], needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[1]);\n                            if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                                nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[2], needLoadDifNode[i]);\n                                nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[2]);\n                            }\n                        } else {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[2], needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[2]);\n                            if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                                nonUniformColObjs[preColIndex[i] + 1].addFirstVal(needLoadDifNode[i].yArray[1], needLoadDifNode[i]);\n                                nonUniformColObjs[preColIndex[i] + 1].forceMerge(needLoadDifNode[i].yArray[1]);\n                            }\n                        }\n                    } else {\n                        if (nodeFlag2 === 0) {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[1], needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[1]);\n\n                            nonUniformColObjs[preColIndex[i]].addFirstVal(needLoadDifNode[i].yArray[2], needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[2]);\n\n                        } else {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(needLoadDifNode[i].yArray[2], needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[2]);\n\n                            nonUniformColObjs[preColIndex[i]].addFirstVal(needLoadDifNode[i].yArray[1], needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(needLoadDifNode[i].yArray[1]);\n                        }\n                    }\n\n                }\n                break;\n            }\n            if (store.state.controlParams.progressive && drawer) {\n                drawer(nonUniformColObjs, \"progressive\")\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n            let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n            // console.log(\"1\");\n            if (losedDataInfo.length > 0) {\n                // console.log(3);\n                await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, this);\n            }\n            // console.log(\"2\");\n        }\n\n        // console.log(\"The time to get all coefficients:\" + (new Date().getTime() - startT));\n        for (let i = 0; i < nonUniformColObjs.length; i++) {\n            nonUniformColObjs[i].checkIsMis();\n        }\n        // console.log(\"Loaded Data Size:\", loadedDataSize);\n        return nonUniformColObjs;\n    }\n\n    async viewTransformFinal(otherDataManager: Array<LevelDataManager>, currentLevel: number, width: number, timeRange: Array<number>, yScale: any, drawer: any, transform_symbol:any){\n        const currentFlagInfo = getFlag(this.dataName);\n        // const currentFlagInfo = getFlag(\"custom_number8_test2_om3_test.flagz\");\n        if (currentFlagInfo === undefined) {\n            throw new Error(this.dataName + \" get flag faild\")\n        } else {\n            // console.log(\"flag info:\", currentFlagInfo);\n            // console.log(\"flag length:\", currentFlagInfo.length)\n        }\n        const currentFlagInfo2 = [];\n        const dataNames = [];\n        for(let i=0;i<otherDataManager.length;++i){\n            currentFlagInfo2.push(getFlag(otherDataManager[i].dataName));\n            dataNames.push(otherDataManager[i].dataName);\n            // const currentFlagInfo2 = getFlag(\"custom_number8_test1_om3_test.flagz\");\n            if (currentFlagInfo2[i] === undefined) {\n                throw new Error(otherDataManager[i].dataName + \" get flag faild\")\n            } else {\n                // console.log(\"flag2 info:\", currentFlagInfo2[i]);\n                // console.log(\"flag2 length:\", currentFlagInfo2[i].length)\n            }\n        }\n        // const currentFlagInfo = [0,1,1,0,1,0,0,1];\n        // const currentFlagInfo2 = [0,1,0,1,0,1,0,1];\n\n        allTimes = []\n        const nonUniformColObjs = computeTimeSE(currentLevel, width, timeRange, this.realDataRowNum, this.maxLevel);\n        let needLoadDifNode: Array<TrendTree> = [];\n        let needLoadDifNode2: Array<Array<TrendTree>> = new Array(otherDataManager.length).fill([]).map(() => new Array<TrendTree>());\n        let colIndex = 0;\n        let count_obj = {count: 0};\n\n        let total_time = 0;\n        let startT = new Date().getTime();\n        //假设对于dataset1\n        for(let i=0; i<this.levelIndexObjs[currentLevel].firstNodes.length; ++i){\n            const firstIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][0], this.maxLevel);\n            const lastIndexTimeRange = this.getIndexTime(currentLevel, this.levelIndexObjs[currentLevel].loadedDataRange[i][1], this.maxLevel);\n            let p = this.levelIndexObjs[currentLevel].firstNodes[i];\n            let p2 = [];\n            for(let k=0;k<otherDataManager.length;++k){\n                p2.push(otherDataManager[k].levelIndexObjs[currentLevel].firstNodes[i])\n            }\n            // let p2 = otherDataManager.levelIndexObjs[currentLevel].firstNodes[i];//测试\n            let data;\n            let resChild;\n            if (firstIndexTimeRange.startT <= timeRange[0] && lastIndexTimeRange.endT >= timeRange[1]) {\n                while(p != null){\n                    if(colIndex >= nonUniformColObjs.length){\n                        break;\n                    } \n                    const type = nonUniformColObjs[colIndex].isMissContain(p);\n                    let p2_temp = p2.slice();\n                    nonUniformColObjs[colIndex].containColumnRange2(p, p2_temp, type, transform_symbol);\n                    \n                    let start_t = new Date().getTime();\n                    nonUniformColObjs[colIndex].computeTransform(p, p2_temp, type, currentFlagInfo, currentFlagInfo2, transform_symbol, count_obj);\n                    let end_t = new Date().getTime();\n                    total_time += end_t - start_t;\n                    // nonUniformColObjs[colIndex].computeTransform(p, p2_temp,this.dataName, dataNames, this, otherDataManager, type, currentFlagInfo, currentFlagInfo2, transform_symbol);\n                    if(type === 1){\n                        p = p.nextSibling!;\n                        for(let k=0;k<otherDataManager.length;++k){\n                            p2[k] = p2[k].nextSibling!;\n                        }                        \n                    }\n                    else if(type === 2){\n                        needLoadDifNode.push(p);\n                        for(let k=0;k<otherDataManager.length;++k){\n                            needLoadDifNode2[k].push(p2[k]);\n                        } \n                        // needLoadDifNode2.push(p2);\n                        p = p.nextSibling!;\n                        for(let k=0;k<otherDataManager.length;++k){\n                            p2[k] = p2[k].nextSibling!;\n                        } \n                    }\n                    else if (type === 3) {\n                        colIndex++;\n                    } else if (type === 5) {\n                        p = p.nextSibling!;\n                        for(let k=0;k<otherDataManager.length;++k){\n                            p2[k] = p2[k].nextSibling!;\n                        } \n                    } else if (type === 6) {\n                        // throw new Error(\"error in viewchange\")\n                        break;\n                    } else {\n                        p = p.nextSibling!;\n                        for(let k=0;k<otherDataManager.length;++k){\n                            p2[k] = p2[k].nextSibling!;\n                        } \n                        //throw new Error(\"node time is little than col\");\n                    }\n                }\n            }\n            // console.log(\"count:\", count_obj.count);\n        }\n        \n        if(needLoadDifNode.length === 0){\n             return nonUniformColObjs;\n        }\n        // let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n        // if (losedDataInfo.length > 0) {\n        //     await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, this);  //取得系数\n        //     for(let i=0; i<otherDataManager.length; i++)\n        //         await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, otherDataManager[i]);\n        // }\n\n        while (needLoadDifNode.length > 0) { //如果需要继续向下获取系数，则一直向下查询，直到最后一层\n            colIndex = 0;\n            const tempNeedLoadDifNodes = [];\n            const tempQue: Array<TrendTree> = [];\n            const tempNeedLoadDifNodes2 : Array<Array<TrendTree>> = new Array(otherDataManager.length).fill([]).map(() => new Array<TrendTree>());\n            const tempQue2: Array<Array<TrendTree>> = new Array(otherDataManager.length).fill([]).map(() => new Array<TrendTree>());\n\n            needLoadDifNode.forEach(v => {\n                // if (v._leftChild === null || v._rightChild === null) {\n                //     console.log(v)\n                //     console.log(this)\n                //     // debugger\n                //     // throw new Error(\"cannot find next level node\");\n                // }\n                if(v._leftChild != null && v._rightChild != null){\n                    this.lruCache.has(v._leftChild.level + \"_\" + v._leftChild.index);\n                    this.lruCache.has(v._rightChild.level + \"_\" + v._rightChild.index);\n                    if (v._leftChild.nodeType !== 'NULL') {\n                        tempQue.push(v._leftChild!);\n                    }\n                    if (v._rightChild.nodeType !== 'NULL') {\n                        tempQue.push(v._rightChild!);\n                    }\n                }\n            });\n            for(let i=0;i<needLoadDifNode2.length;++i){\n                needLoadDifNode2[i].forEach(v => {\n                    if(v._leftChild != null && v._rightChild != null){\n                        this.lruCache.has(v._leftChild.level + \"_\" + v._leftChild.index);\n                        this.lruCache.has(v._rightChild.level + \"_\" + v._rightChild.index);\n                        if (v._leftChild.nodeType !== 'NULL') {\n                            tempQue2[i].push(v._leftChild!);\n                        }\n                        if (v._rightChild.nodeType !== 'NULL') {\n                            tempQue2[i].push(v._rightChild!);\n                        }\n                    }\n                });\n            }\n            \n\n            const preColIndex = [];\n            for (let i = 0; i < tempQue.length; i++) {\n                if (colIndex >= nonUniformColObjs.length) {\n                    break;\n                    //throw new Error(\"col index out range\");\n                }\n                const type = nonUniformColObjs[colIndex].isMissContain(tempQue[i]);\n                \n                let tempQue3 = [];\n                for(let k=0;k<otherDataManager.length;++k){\n                    tempQue3.push(tempQue2[k][i]);\n                }\n                let array = tempQue3.slice();\n                nonUniformColObjs[colIndex].containColumnRange2(tempQue[i], array, type, transform_symbol);\n                // nonUniformColObjs[colIndex].computeTransform(tempQue[i], array, this.dataName, dataNames, this, otherDataManager, type, currentFlagInfo, currentFlagInfo2, transform_symbol);\n                let start_t = new Date().getTime(); \n                nonUniformColObjs[colIndex].computeTransform(tempQue[i], array, type, currentFlagInfo, currentFlagInfo2, transform_symbol, count_obj);\n                let end_t = new Date().getTime();\n                total_time += end_t - start_t;\n                if (type === 1) {\n                    continue;\n                } else if (type === 2) {\n                    tempNeedLoadDifNodes.push(tempQue[i]);\n                    for(let k=0;k<otherDataManager.length;++k){\n                        tempNeedLoadDifNodes2[k].push(array[k]);\n                    }\n                    // tempNeedLoadDifNodes2.push(tempQue2[i]);\n                    preColIndex.push(colIndex);\n                } else if (type === 3) {\n                    colIndex++;\n                    i--;\n                } else if (type === 6) {\n                    break;\n                } else {\n                    continue;\n                    // throw new Error(\"node time is little than col\");\n                }\n            }\n            if (preColIndex.length != tempNeedLoadDifNodes.length) {\n                throw new Error(\"cannot memory index\");\n            }\n\n            // for (let i = 0; i < tempNeedLoadDifNodes.length; i++) {\n            //     if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n            //         //判断是否可以剪枝\n            //         const con1 = canCut(tempNeedLoadDifNodes[i], nonUniformColObjs[preColIndex[i]], nonUniformColObjs[preColIndex[i] + 1], yScale);\n            //         if (con1) {\n            //             tempNeedLoadDifNodes.splice(i, 1)\n            //             preColIndex.splice(i, 1);\n            //         }\n            //     }\n            // }\n            ////this.checkMonotonicity(nonUniformColObjs,preColIndex,tempNeedLoadDifNodes);\n            needLoadDifNode = tempNeedLoadDifNodes;\n            needLoadDifNode2 = tempNeedLoadDifNodes2;\n            if (needLoadDifNode.length > 0 && needLoadDifNode[0].level === this.maxLevel - 1) {\n                if(transform_symbol === '+'){\n                    for (let i = 0; i < needLoadDifNode.length; i++) {\n                        let maxL = 0, maxR = 0;\n                        const nodeFlag1 = currentFlagInfo[2 * needLoadDifNode[i].index + 1];\n                        if(nodeFlag1 === 0){\n                            maxL += needLoadDifNode[i].yArray[1];\n                            maxR += needLoadDifNode[i].yArray[2];\n                        } \n                        else{\n                            maxL += needLoadDifNode[i].yArray[2];\n                            maxR += needLoadDifNode[i].yArray[1];\n                        }\n                        //const nodeFlag2 = currentFlagInfo2[2 * needLoadDifNode[i].index + 1];\n                        for(let k=0; k<currentFlagInfo2.length;++k){\n                            if(currentFlagInfo2[k][needLoadDifNode[i].index * 2 + 1] === 0){\n                                maxL += needLoadDifNode2[k][i].yArray[1];\n                                maxR += needLoadDifNode2[k][i].yArray[2];\n                            }\n                            else{\n                                maxL += needLoadDifNode2[k][i].yArray[2];\n                                maxR += needLoadDifNode2[k][i].yArray[1];\n                            }\n                        }\n                        // let sumOfOtherMin = 0, sumOfOtherMax = 0;\n                        // for(let k=0;k<otherDataManager.length;++k){\n                        //     sumOfOtherMin += needLoadDifNode2[k][i].yArray[1];\n                        //     sumOfOtherMax += needLoadDifNode2[k][i].yArray[2];\n                        // }\n                        if (needLoadDifNode[i].gapFlag === 'NO') {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n                            if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                                nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                                nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                            }\n                        } else {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n\n                            nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                        }\n                        \n                    }\n                }\n                else if(transform_symbol === '-'){\n                    for (let i = 0; i < needLoadDifNode.length; i++) {\n                        let maxL = 0, maxR = 0;\n                        const nodeFlag1 = currentFlagInfo[2 * needLoadDifNode[i].index + 1];\n                        if(nodeFlag1 === 0){\n                            maxL += needLoadDifNode[i].yArray[1];\n                            maxR += needLoadDifNode[i].yArray[2];\n                        } \n                        else{\n                            maxL += needLoadDifNode[i].yArray[2];\n                            maxR += needLoadDifNode[i].yArray[1];\n                        }\n                        //const nodeFlag2 = currentFlagInfo2[2 * needLoadDifNode[i].index + 1];\n                        for(let k=0; k<currentFlagInfo2.length;++k){\n                            if(currentFlagInfo2[k][needLoadDifNode[i].index * 2 + 1] === 0){\n                                maxL -= needLoadDifNode2[k][i].yArray[1];\n                                maxR -= needLoadDifNode2[k][i].yArray[2];\n                            }\n                            else{\n                                maxL -= needLoadDifNode2[k][i].yArray[2];\n                                maxR -= needLoadDifNode2[k][i].yArray[1];\n                            }\n                        }\n                        if (needLoadDifNode[i].gapFlag === 'NO') {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n                            if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                                nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                                nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                            }\n                        } else {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n\n                            nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                        }\n                        \n                    }\n                }\n                else if(transform_symbol === '*'){\n                    for (let i = 0; i < needLoadDifNode.length; i++) {\n                        let maxL = 0, maxR = 0;\n                        const nodeFlag1 = currentFlagInfo[2 * needLoadDifNode[i].index + 1];\n                        if(nodeFlag1 === 0){\n                            maxL += needLoadDifNode[i].yArray[1];\n                            maxR += needLoadDifNode[i].yArray[2];\n                        } \n                        else{\n                            maxL += needLoadDifNode[i].yArray[2];\n                            maxR += needLoadDifNode[i].yArray[1];\n                        }\n                        //const nodeFlag2 = currentFlagInfo2[2 * needLoadDifNode[i].index + 1];\n                        for(let k=0; k<currentFlagInfo2.length;++k){\n                            if(currentFlagInfo2[k][needLoadDifNode[i].index * 2 + 1] === 0){\n                                maxL *= needLoadDifNode2[k][i].yArray[1];\n                                maxR *= needLoadDifNode2[k][i].yArray[2];\n                            }\n                            else{\n                                maxL *= needLoadDifNode2[k][i].yArray[2];\n                                maxR *= needLoadDifNode2[k][i].yArray[1];\n                            }\n                        }\n                        if (needLoadDifNode[i].gapFlag === 'NO') {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n                            if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                                nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                                nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                            }\n                        } else {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n\n                            nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                        }\n                        \n                    }\n                }\n                else if(transform_symbol === '/'){\n                    for (let i = 0; i < needLoadDifNode.length; i++) {\n                        let maxL = 0, maxR = 0;\n                        const nodeFlag1 = currentFlagInfo[2 * needLoadDifNode[i].index + 1];\n                        if(nodeFlag1 === 0){\n                            maxL += needLoadDifNode[i].yArray[1];\n                            maxR += needLoadDifNode[i].yArray[2];\n                        } \n                        else{\n                            maxL += needLoadDifNode[i].yArray[2];\n                            maxR += needLoadDifNode[i].yArray[1];\n                        }\n                        //const nodeFlag2 = currentFlagInfo2[2 * needLoadDifNode[i].index + 1];\n                        for(let k=0; k<currentFlagInfo2.length;++k){\n                            if(currentFlagInfo2[k][needLoadDifNode[i].index * 2 + 1] === 0){\n                                maxL /= needLoadDifNode2[k][i].yArray[1];\n                                maxR /= needLoadDifNode2[k][i].yArray[2];\n                            }\n                            else{\n                                maxL /= needLoadDifNode2[k][i].yArray[2];\n                                maxR /= needLoadDifNode2[k][i].yArray[1];\n                            }\n                        }\n                        if (needLoadDifNode[i].gapFlag === 'NO') {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n                            if (preColIndex[i] + 1 < nonUniformColObjs.length) {\n                                nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                                nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                            }\n                        } else {\n                            nonUniformColObjs[preColIndex[i]].addLastVal(maxL, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i]].forceMerge(maxL);\n\n                            nonUniformColObjs[preColIndex[i] + 1].addFirstVal(maxR, needLoadDifNode[i]);\n                            nonUniformColObjs[preColIndex[i] + 1].forceMerge(maxR);\n                        }\n                        \n                    }\n                }\n                break;\n            }\n            if (needLoadDifNode.length === 0) {\n                break;\n            }\n            // if(needLoadDifNode.length === 0 || needLoadDifNode[0].level === this.maxLevel - 1){\n            //     break;\n            // }\n\n            // let losedDataInfo = computeLosedDataRangeV1(needLoadDifNode);\n            // if (losedDataInfo.length > 0) {\n            //     await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, this); //每一层都需要判断子节点是否需要获取，需要的话要从数据库获取系数\n            //     for(let i=0; i<otherDataManager.length; i++)\n            //         await batchLoadDataForRangeLevel1MinMaxMiss(losedDataInfo, otherDataManager[i]); \n            // }\n\n        }\n\n        // console.log(\"The time to get all coefficients:\" + (new Date().getTime() - startT));\n        console.log(\"The final count:\", count_obj.count);\n        // console.log(\"The time to get total coefficients:\", total_time);\n        console.log(\"The time to get total coefficients:\", new Date().getTime() - startT);\n\n        let maxValue = -Infinity, minValue = Infinity, finalValue = 0;\n        for (let i = 0; i < nonUniformColObjs.length; i++) {\n            nonUniformColObjs[i].checkIsMis();\n            if(transform_symbol === '+'){\n                maxValue = Math.max(maxValue, nonUniformColObjs[i].addMax[1]);\n                minValue = Math.min(minValue, nonUniformColObjs[i].addMin[1]);\n                // maxValue = 2000;\n                // minValue = 2000;\n            }\n            else if(transform_symbol === '-'){\n                maxValue = Math.max(maxValue, nonUniformColObjs[i].subMax[1]);\n                minValue = Math.min(minValue, nonUniformColObjs[i].subMin[1]);\n                // maxValue = 1000;\n                // minValue = -2000;\n            }\n            else if(transform_symbol === '*'){\n                maxValue = Math.max(maxValue, nonUniformColObjs[i].multiMax[1]);\n                minValue = Math.min(minValue, nonUniformColObjs[i].multiMin[1]);\n            }\n            else if(transform_symbol === '/'){\n                maxValue = Math.max(maxValue, nonUniformColObjs[i].divMax[1]);\n                minValue = Math.min(minValue, nonUniformColObjs[i].divMin[1]);\n            }\n            else if(transform_symbol === 'avg'){\n                maxValue = Math.max(maxValue, nonUniformColObjs[i].addMax[1]);\n                minValue = Math.min(minValue, nonUniformColObjs[i].addMin[1]);\n            }\n            finalValue = Math.max(Math.abs(maxValue), Math.abs(minValue));\n        }\n        const myDict: { a: NoUniformColObj[]; b: number; } = {\n            a: nonUniformColObjs,\n            b: finalValue\n        }\n        return myDict;\n    }\n\n}\n\n"],"mappings":"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","ignoreList":[]}]}