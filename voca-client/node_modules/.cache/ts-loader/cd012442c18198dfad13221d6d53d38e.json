{"remainingRequest":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/babel-loader/lib/index.js!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/ts-loader/index.js??ref--15-2!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/eslint-loader/index.js??ref--14-0!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/src/helper/wavlet-decoder.ts","dependencies":[{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/src/helper/wavlet-decoder.ts","mtime":1732546288000},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/babel.config.js","mtime":1732546288000},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/cache-loader/dist/cjs.js","mtime":1732627998206},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/babel-loader/lib/index.js","mtime":1732627998426},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/ts-loader/index.js","mtime":1732627997224},{"path":"/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/eslint-loader/index.js","mtime":1732627997140}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZXJyb3IuY2F1c2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5wdXNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmZvci1lYWNoLmpzIjsKaW1wb3J0IEhhYXJEYXRhTWFuYWdlciBmcm9tICJAL21vZGVsL2hhYXItZGF0YS1tYW5hZ2VyIjsKaW1wb3J0IEhhYXJJbmRleE9iaiBmcm9tICJAL21vZGVsL2hhYXItaW5kZXgtb2JqIjsKaW1wb3J0IExldmVsRGF0YU1hbmFnZXIgZnJvbSAiQC9tb2RlbC9sZXZlbC1kYXRhLW1hbmFnZXIiOwppbXBvcnQgTGV2ZWxJbmRleE9iaiBmcm9tICJAL21vZGVsL2xldmVsLWluZGV4LW9iaiI7CmltcG9ydCBzdG9yZSBmcm9tICJAL3N0b3JlIjsKaW1wb3J0IEhhYXJUcmVlIGZyb20gIi4vaGFhci10cmVlIjsKaW1wb3J0IFRyZW5kVHJlZSBmcm9tICIuL3RlbmQtcXVlcnktdHJlZSI7CmZ1bmN0aW9uIGluaXRXYXZlbGV0RGVjb2RlKGRpZmZEYXRhKSB7CiAgbGV0IG1pblQgPSBkaWZmRGF0YS5taW50ZDsKICBsZXQgbWluViA9IGRpZmZEYXRhLm1pbnZkOwogIGxldCBtYXhWID0gZGlmZkRhdGEubWF4dmQ7CiAgbGV0IG1heFQgPSBkaWZmRGF0YS5tYXh0ZDsKICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubG9nMihtYXhWLmxlbmd0aCk7IGkrKykgewogICAgY29uc3QgdGVtcE1heFYgPSBbXTsKICAgIGNvbnN0IHRlbXBNYXhUID0gW107CiAgICBjb25zdCB0ZW1wTWluViA9IFtdOwogICAgY29uc3QgdGVtcE1pblQgPSBbXTsKICAgIGZvciAobGV0IGogPSAwOyBqIDwgMiAqKiBpOyBqKyspIHsKICAgICAgaWYgKG1heFZbaiArIDIgKiogaV0gPj0gMCkgewogICAgICAgIHRlbXBNYXhWLnB1c2gobWF4VltqXSk7CiAgICAgICAgdGVtcE1heFYucHVzaChtYXhWW2pdIC0gbWF4VltqICsgMiAqKiBpXSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGVtcE1heFYucHVzaChtYXhWW2pdICsgbWF4VltqICsgMiAqKiBpXSk7CiAgICAgICAgdGVtcE1heFYucHVzaChtYXhWW2pdKTsKICAgICAgfQogICAgICBpZiAobWluVltqICsgMiAqKiBpXSA+PSAwKSB7CiAgICAgICAgdGVtcE1pblYucHVzaChtaW5WW2pdICsgbWluVltqICsgMiAqKiBpXSk7CiAgICAgICAgdGVtcE1pblYucHVzaChtaW5WW2pdKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0ZW1wTWluVi5wdXNoKG1pblZbal0pOwogICAgICAgIHRlbXBNaW5WLnB1c2gobWluVltqXSAtIG1pblZbaiArIDIgKiogaV0pOwogICAgICB9CiAgICAgIHRlbXBNaW5ULnB1c2gobWluVFtqXSk7CiAgICAgIHRlbXBNaW5ULnB1c2gobWluVFtqXSAtIG1pblRbaiArIDIgKiogaV0pOwogICAgICB0ZW1wTWF4VC5wdXNoKG1heFRbal0gKyBtYXhUW2ogKyAyICoqIGldKTsKICAgICAgdGVtcE1heFQucHVzaChtYXhUW2pdKTsKICAgIH0KICAgIG1heFYgPSBbLi4udGVtcE1heFYsIC4uLm1heFYuc2xpY2UoMiAqKiAoaSArIDEpKV07CiAgICBtYXhUID0gWy4uLnRlbXBNYXhULCAuLi5tYXhULnNsaWNlKDIgKiogKGkgKyAxKSldOwogICAgbWluViA9IFsuLi50ZW1wTWluViwgLi4ubWluVi5zbGljZSgyICoqIChpICsgMSkpXTsKICAgIG1pblQgPSBbLi4udGVtcE1pblQsIC4uLm1pblQuc2xpY2UoMiAqKiAoaSArIDEpKV07CiAgfQogIGNvbnN0IG00RGF0YSA9IHsKICAgIG1pbnQ6IG1pblQsCiAgICBtaW52OiBtaW5WLAogICAgbWF4djogbWF4ViwKICAgIG1heHQ6IG1heFQKICB9OwogIHJldHVybiBtNERhdGE7Cn0KZXhwb3J0IGZ1bmN0aW9uIGluaXRIYWFyRGVjb2RlKGRpZikgewogIGxldCBtaW5UID0gZGlmOwogIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5sb2cyKG1pblQubGVuZ3RoKTsgaSsrKSB7CiAgICBjb25zdCB0ZW1wTWluVCA9IFtdOwogICAgZm9yIChsZXQgaiA9IDA7IGogPCAyICoqIGk7IGorKykgewogICAgICBjb25zdCBhID0gKDIgKiBtaW5UW2pdICsgbWluVFtqICsgMiAqKiBpXSkgLyAyOwogICAgICB0ZW1wTWluVC5wdXNoKGEpOwogICAgICBjb25zdCBiID0gKDIgKiBtaW5UW2pdIC0gbWluVFtqICsgMiAqKiBpXSkgLyAyOwogICAgICB0ZW1wTWluVC5wdXNoKGIpOwogICAgfQogICAgbWluVCA9IFsuLi50ZW1wTWluVCwgLi4ubWluVC5zbGljZSgyICoqIChpICsgMSkpXTsKICB9CiAgcmV0dXJuIG1pblQ7Cn0KZnVuY3Rpb24gd2F2ZWxldERlY29kZShoaXN0cm9yeURhdGEsIGRpZmZEYXRhLCByYW5nZSkgewogIGNvbnN0IGhpc3RvcnlNaW5UID0gaGlzdHJvcnlEYXRhWzFdLnNsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSk7CiAgY29uc3QgaGlzdG9yeU1pblYgPSBoaXN0cm9yeURhdGFbMl0uc2xpY2UocmFuZ2VbMF0sIHJhbmdlWzFdKTsKICBjb25zdCBoaXN0b3J5TWF4ViA9IGhpc3Ryb3J5RGF0YVszXS5zbGljZShyYW5nZVswXSwgcmFuZ2VbMV0pOwogIGNvbnN0IGhpc3RvcnlNYXhUID0gaGlzdHJvcnlEYXRhWzRdLnNsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSk7CiAgY29uc3QgZGlmTWluVCA9IGRpZmZEYXRhLm1pbnRkOwogIGNvbnN0IGRpZk1pblYgPSBkaWZmRGF0YS5taW52ZDsKICBjb25zdCBkaWZNYXhWID0gZGlmZkRhdGEubWF4dmQ7CiAgY29uc3QgZGlmTWF4VCA9IGRpZmZEYXRhLm1heHRkOwogIGNvbnN0IG5vd01pblQgPSBbXTsKICBjb25zdCBub3dNaW5WID0gW107CiAgY29uc3Qgbm93TWF4ViA9IFtdOwogIGNvbnN0IG5vd01heFQgPSBbXTsKICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvcnlNaW5ULmxlbmd0aDsgaSsrKSB7CiAgICBub3dNaW5ULnB1c2goaGlzdG9yeU1pblRbaV0sIGhpc3RvcnlNaW5UW2ldIC0gZGlmTWluVFtpXSk7CiAgICBpZiAoZGlmTWluVltpXSA8IDApIHsKICAgICAgbm93TWluVi5wdXNoKGhpc3RvcnlNaW5WW2ldLCBoaXN0b3J5TWluVltpXSAtIGRpZk1pblZbaV0pOwogICAgfSBlbHNlIHsKICAgICAgbm93TWluVi5wdXNoKGhpc3RvcnlNaW5WW2ldICsgZGlmTWluVltpXSwgaGlzdG9yeU1pblZbaV0pOwogICAgfQogICAgaWYgKGRpZk1heFZbaV0gPCAwKSB7CiAgICAgIG5vd01heFYucHVzaChoaXN0b3J5TWF4VltpXSArIGRpZk1heFZbaV0sIGhpc3RvcnlNYXhWW2ldKTsKICAgIH0gZWxzZSB7CiAgICAgIG5vd01heFYucHVzaChoaXN0b3J5TWF4VltpXSwgaGlzdG9yeU1heFZbaV0gLSBkaWZNYXhWW2ldKTsKICAgIH0KICAgIG5vd01heFQucHVzaChoaXN0b3J5TWF4VFtpXSArIGRpZk1heFRbaV0sIGhpc3RvcnlNYXhUW2ldKTsKICB9CiAgcmV0dXJuIHsKICAgIG1pbnQ6IG5vd01pblQsCiAgICBtaW52OiBub3dNaW5WLAogICAgbWF4djogbm93TWF4ViwKICAgIG1heHQ6IG5vd01heFQKICB9Owp9CmZ1bmN0aW9uIGNvbnN0cnVjdEhhYXJUcmVlKGRhdGEsIHRhYmxlTmFtZSkgewogIGNvbnN0IGxldmVsSW5kZXggPSBuZXcgQXJyYXkoTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSk7CiAgLy9jb25zdCBkYXRhTWFuYWdlcj1uZXcgTGV2ZWxEYXRhTWFuYWdlcigpCiAgY29uc3QgbWludGQgPSBbXTsKICBkYXRhLmZvckVhY2godiA9PiB7CiAgICBtaW50ZC5wdXNoKHYuZGlmKTsKICB9KTsKICBsZXQgdGVtcExhc3QgPSBtaW50ZC5wb3AoKTsKICBtaW50ZC51bnNoaWZ0KHRlbXBMYXN0KTsKICBsZXQgbGFzdExldmVsTm9kZXMgPSBuZXcgQXJyYXkoKTsKICBsZXQgY3VycmVudExldmVsTm9kZXMgPSBuZXcgQXJyYXkoKTsKICBjb25zdCByb290ID0gbmV3IEhhYXJUcmVlKG51bGwsIHRydWUsIDAsIG1pbnRkWzBdLCBtaW50ZFsxXSk7CiAgbGFzdExldmVsTm9kZXMucHVzaChyb290KTsKICBsZXZlbEluZGV4WzBdID0gbmV3IEhhYXJJbmRleE9iaigwLCB0cnVlKTsKICBsZXZlbEluZGV4WzBdLmFkZExvYWRlZERhdGFSYW5nZShyb290LCBbMCwgMF0pOwogIGZvciAobGV0IGkgPSAxOyBpIDw9IE1hdGgubG9nMihkYXRhLmxlbmd0aCk7IGkrKykgewogICAgZm9yIChsZXQgaiA9IDA7IGogPCAyICoqIChpIC0gMSk7IGorKykgewogICAgICBjb25zdCBsYXN0Tm9kZSA9IGxhc3RMZXZlbE5vZGVzW2pdOwogICAgICBjb25zdCBhID0gKDIgKiBsYXN0Tm9kZS52YWx1ZSArIGxhc3ROb2RlLmRpZmZlcmVuY2UpIC8gMjsKICAgICAgY29uc3QgYiA9ICgyICogbGFzdE5vZGUudmFsdWUgLSBsYXN0Tm9kZS5kaWZmZXJlbmNlKSAvIDI7CiAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IG5ldyBIYWFyVHJlZShsYXN0Tm9kZSwgdHJ1ZSwgbGFzdE5vZGUuaW5kZXgsIGEsIGkgPT09IE1hdGgubG9nMihkYXRhLmxlbmd0aCkgPyB1bmRlZmluZWQgOiBtaW50ZFtqICogMiArIDIgKiogaV0pOwogICAgICBjb25zdCBzZWNvbmROb2RlID0gbmV3IEhhYXJUcmVlKGxhc3ROb2RlLCBmYWxzZSwgbGFzdE5vZGUuaW5kZXgsIGIsIGkgPT09IE1hdGgubG9nMihkYXRhLmxlbmd0aCkgPyB1bmRlZmluZWQgOiBtaW50ZFtqICogMiArIDEgKyAyICoqIGldKTsKICAgICAgY3VycmVudExldmVsTm9kZXMucHVzaChmaXJzdE5vZGUpOwogICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKHNlY29uZE5vZGUpOwogICAgfQogICAgbGV2ZWxJbmRleFtpXSA9IG5ldyBIYWFySW5kZXhPYmooY3VycmVudExldmVsTm9kZXNbMF0ubGV2ZWwsIHRydWUpOwogICAgbGV2ZWxJbmRleFtpXS5hZGRMb2FkZWREYXRhUmFuZ2UoY3VycmVudExldmVsTm9kZXNbMF0sIFswLCBjdXJyZW50TGV2ZWxOb2Rlcy5sZW5ndGggLSAxXSk7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbE5vZGVzLmxlbmd0aCAtIDE7IGkrKykgewogICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpXS5uZXh0U2libGluZyA9IGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXTsKICAgICAgY3VycmVudExldmVsTm9kZXNbaSArIDFdLnByZXZpb3VzU2libGluZyA9IGN1cnJlbnRMZXZlbE5vZGVzW2ldOwogICAgfQogICAgbGFzdExldmVsTm9kZXMgPSBjdXJyZW50TGV2ZWxOb2RlczsKICAgIGN1cnJlbnRMZXZlbE5vZGVzID0gW107CiAgfQogIHJldHVybiB7CiAgICBkYXRhTWFuYWdlcjogbmV3IEhhYXJEYXRhTWFuYWdlcihsZXZlbEluZGV4LCB0YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiBzdG9yZS5zdGF0ZS5jb250cm9sUGFyYW1zLmN1cnJlbnRUYWJsZSksCiAgICB0cmVuZFRyZWU6IHJvb3QKICB9Owp9CmZ1bmN0aW9uIGNvbnN0cnVjdFRyZW5kVHJlZShkYXRhLCB0YWJsZU5hbWUpIHsKICBjb25zdCBsZXZlbEluZGV4ID0gbmV3IEFycmF5KE1hdGgubG9nMihkYXRhLmxlbmd0aCkpOwogIC8vY29uc3QgZGF0YU1hbmFnZXI9bmV3IExldmVsRGF0YU1hbmFnZXIoKQogIGNvbnN0IG1pbnRkID0gW107CiAgY29uc3QgbWludmQgPSBbXTsKICBjb25zdCBtYXh2ZCA9IFtdOwogIGNvbnN0IG1heHRkID0gW107CiAgY29uc3QgYXZldmQgPSBbXTsKICBkYXRhLmZvckVhY2godiA9PiB7CiAgICBtaW50ZC5wdXNoKHYubWluaWQpOwogICAgbWludmQucHVzaCh2Lm1pbnZkKTsKICAgIG1heHZkLnB1c2godi5tYXh2ZCk7CiAgICBtYXh0ZC5wdXNoKHYubWF4aWQpOwogICAgYXZldmQucHVzaCh2LmF2ZXZkKTsKICB9KTsKICBsZXQgdGVtcExhc3QgPSBtaW50ZC5wb3AoKTsKICBtaW50ZC51bnNoaWZ0KHRlbXBMYXN0KTsKICB0ZW1wTGFzdCA9IG1pbnZkLnBvcCgpOwogIG1pbnZkLnVuc2hpZnQodGVtcExhc3QpOwogIHRlbXBMYXN0ID0gbWF4dmQucG9wKCk7CiAgbWF4dmQudW5zaGlmdCh0ZW1wTGFzdCk7CiAgdGVtcExhc3QgPSBtYXh0ZC5wb3AoKTsKICBtYXh0ZC51bnNoaWZ0KHRlbXBMYXN0KTsKICB0ZW1wTGFzdCA9IGF2ZXZkLnBvcCgpOwogIGF2ZXZkLnVuc2hpZnQodGVtcExhc3QpOwogIGxldCBsYXN0TGV2ZWxOb2RlcyA9IG5ldyBBcnJheSgpOwogIGxldCBjdXJyZW50TGV2ZWxOb2RlcyA9IG5ldyBBcnJheSgpOwogIGxldCBub2RlTnVtID0gMTsKICBjb25zdCByb290ID0gbmV3IFRyZW5kVHJlZShudWxsLCB0cnVlLCAwLCBbbWludGRbMF0sIG1pbnZkWzBdLCBtYXh2ZFswXSwgYXZldmRbMF0sIG1heHRkWzBdXSwgW21pbnRkWzFdLCBtaW52ZFsxXSwgbWF4dmRbMV0sIGF2ZXZkWzFdLCBtYXh0ZFsxXV0pOwogIGxhc3RMZXZlbE5vZGVzLnB1c2gocm9vdCk7CiAgbGV2ZWxJbmRleFswXSA9IG5ldyBMZXZlbEluZGV4T2JqKDAsIHRydWUpOwogIGxldmVsSW5kZXhbMF0uYWRkTG9hZGVkRGF0YVJhbmdlKHJvb3QsIFswLCAwXSk7CiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKTsgaSsrKSB7CiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDIgKiogKGkgLSAxKTsgaisrKSB7CiAgICAgIGNvbnN0IGxhc3ROb2RlID0gbGFzdExldmVsTm9kZXNbal07CiAgICAgIC8vQHRzLWlnbm9yZQogICAgICAvLyBjb25zdCB5QXJyYXkxOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IG5ldyBBcnJheSg0KTsKICAgICAgLy9AdHMtaWdub3JlCiAgICAgIC8vIGNvbnN0IHlBcnJheTI6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gbmV3IEFycmF5KDQpOwogICAgICAvL0B0cy1pZ25vcmUKICAgICAgY29uc3QgeUFycmF5MSA9IG5ldyBBcnJheSg1KTsKICAgICAgLy9AdHMtaWdub3JlCiAgICAgIGNvbnN0IHlBcnJheTIgPSBuZXcgQXJyYXkoNSk7CiAgICAgIC8vIHlBcnJheTFbMF0gPSBsYXN0Tm9kZS55QXJyYXlbMF07CiAgICAgIC8vIHlBcnJheTJbMF0gPSBsYXN0Tm9kZS55QXJyYXlbMF0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlIVswXTsKICAgICAgLy8gaWYgKGxhc3ROb2RlLmRpZmZlcmVuY2UhWzFdID49IDApIHsKICAgICAgLy8gICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlIVsxXTsKICAgICAgLy8gICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgICAgIC8vIH0gZWxzZSB7CiAgICAgIC8vICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAvLyAgICAgeUFycmF5MlsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXSAtIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzFdOwogICAgICAvLyB9CiAgICAgIC8vIGlmIChsYXN0Tm9kZS5kaWZmZXJlbmNlIVsyXSA+PSAwKSB7CiAgICAgIC8vICAgICB5QXJyYXkxWzJdID0gbGFzdE5vZGUueUFycmF5WzJdOwogICAgICAvLyAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSAtIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdOwogICAgICAvLyB9IGVsc2UgewogICAgICAvLyAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSArIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdOwogICAgICAvLyAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAgICAgLy8gfQogICAgICAvLyB5QXJyYXkxWzNdID0gbGFzdE5vZGUueUFycmF5WzNdICsgbGFzdE5vZGUuZGlmZmVyZW5jZSFbM107CiAgICAgIC8vIHlBcnJheTJbM10gPSBsYXN0Tm9kZS55QXJyYXlbM107CiAgICAgIC8vIC8vQHRzLWlnbm9yZQogICAgICAvLyBjb25zdCBmaXJzdE5vZGUgPSBuZXcgVHJlbmRUcmVlKGxhc3ROb2RlLCB0cnVlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MSwgaSA9PT0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSA/IG51bGwgOiBbbWludGRbaiAqIDIgKyAyICoqIGldLCBtaW52ZFtqICogMiArIDIgKiogaV0sIG1heHZkW2ogKiAyICsgMiAqKiBpXSwgbWF4dGRbaiAqIDIgKyAyICoqIGldXSk7CiAgICAgIC8vIC8vQHRzLWlnbm9yZQogICAgICAvLyBjb25zdCBzZWNvbmROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgZmFsc2UsIGxhc3ROb2RlLmluZGV4LCB5QXJyYXkyLCBpID09PSBNYXRoLmxvZzIoZGF0YS5sZW5ndGgpID8gbnVsbCA6IFttaW50ZFtqICogMiArIDEgKyAyICoqIGldLCBtaW52ZFtqICogMiArIDEgKyAyICoqIGldLCBtYXh2ZFtqICogMiArIDEgKyAyICoqIGldLCBtYXh0ZFtqICogMiArIDEgKyAyICoqIGldXSk7CiAgICAgIHlBcnJheTFbMF0gPSBsYXN0Tm9kZS55QXJyYXlbMF07CiAgICAgIHlBcnJheTJbMF0gPSBsYXN0Tm9kZS55QXJyYXlbMF0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlWzBdOwogICAgICBpZiAobGFzdE5vZGUuZGlmZmVyZW5jZVsxXSA+PSAwKSB7CiAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXSArIGxhc3ROb2RlLmRpZmZlcmVuY2VbMV07CiAgICAgICAgeUFycmF5MlsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKICAgICAgfSBlbHNlIHsKICAgICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlWzFdOwogICAgICB9CiAgICAgIGlmIChsYXN0Tm9kZS5kaWZmZXJlbmNlWzJdID49IDApIHsKICAgICAgICB5QXJyYXkxWzJdID0gbGFzdE5vZGUueUFycmF5WzJdOwogICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlWzJdOwogICAgICB9IGVsc2UgewogICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl0gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlWzJdOwogICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgIH0KICAgICAgaWYgKGxhc3ROb2RlLmRpZmZlcmVuY2VbM10gPj0gMCB8fCBsYXN0Tm9kZS5kaWZmZXJlbmNlWzNdIDw9IDApIHsKICAgICAgICB5QXJyYXkxWzNdID0gKGxhc3ROb2RlLnlBcnJheVszXSAqIDIgKyBsYXN0Tm9kZS5kaWZmZXJlbmNlWzJdKSAvIDI7CiAgICAgICAgeUFycmF5MlszXSA9IChsYXN0Tm9kZS55QXJyYXlbM10gKiAyIC0gbGFzdE5vZGUuZGlmZmVyZW5jZVsyXSkgLyAyOwogICAgICB9CiAgICAgIHlBcnJheTFbNF0gPSBsYXN0Tm9kZS55QXJyYXlbNF0gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlWzRdOwogICAgICB5QXJyYXkyWzRdID0gbGFzdE5vZGUueUFycmF5WzRdOwogICAgICAvL0B0cy1pZ25vcmUKICAgICAgY29uc3QgZmlyc3ROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgdHJ1ZSwgbGFzdE5vZGUuaW5kZXgsIHlBcnJheTEsIGkgPT09IE1hdGgubG9nMihkYXRhLmxlbmd0aCkgPyBudWxsIDogW21pbnRkW2ogKiAyICsgMiAqKiBpXSwgbWludmRbaiAqIDIgKyAyICoqIGldLCBtYXh2ZFtqICogMiArIDIgKiogaV0sIGF2ZXZkW2ogKiAyICsgMiAqKiBpXSwgbWF4dGRbaiAqIDIgKyAyICoqIGldXSk7CiAgICAgIC8vQHRzLWlnbm9yZQogICAgICBjb25zdCBzZWNvbmROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgZmFsc2UsIGxhc3ROb2RlLmluZGV4LCB5QXJyYXkyLCBpID09PSBNYXRoLmxvZzIoZGF0YS5sZW5ndGgpID8gbnVsbCA6IFttaW50ZFtqICogMiArIDEgKyAyICoqIGldLCBtaW52ZFtqICogMiArIDEgKyAyICoqIGldLCBtYXh2ZFtqICogMiArIDEgKyAyICoqIGldLCBhdmV2ZFtqICogMiArIDEgKyAyICoqIGldLCBtYXh0ZFtqICogMiArIDEgKyAyICoqIGldXSk7CiAgICAgIC8vIGlmIChqID09PSAwKSB7CiAgICAgIC8vICAgICBsZXZlbEluZGV4W2ldPW5ldyBMZXZlbEluZGV4T2JqKGZpcnN0Tm9kZS5sZXZlbCx0cnVlKTsKICAgICAgLy8gICAgIGxldmVsSW5kZXhbaV0uYWRkTG9hZGVkRGF0YVJhbmdlKGZpcnN0Tm9kZSxbMCxdKQogICAgICAvLyB9CiAgICAgIGN1cnJlbnRMZXZlbE5vZGVzLnB1c2goZmlyc3ROb2RlKTsKICAgICAgY3VycmVudExldmVsTm9kZXMucHVzaChzZWNvbmROb2RlKTsKICAgICAgbm9kZU51bSArPSAyOwogICAgfQogICAgbGV2ZWxJbmRleFtpXSA9IG5ldyBMZXZlbEluZGV4T2JqKGN1cnJlbnRMZXZlbE5vZGVzWzBdLmxldmVsLCB0cnVlKTsKICAgIGxldmVsSW5kZXhbaV0uYWRkTG9hZGVkRGF0YVJhbmdlKGN1cnJlbnRMZXZlbE5vZGVzWzBdLCBbMCwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0pOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGV2ZWxOb2Rlcy5sZW5ndGggLSAxOyBpKyspIHsKICAgICAgY3VycmVudExldmVsTm9kZXNbaV0ubmV4dFNpYmxpbmcgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV07CiAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS5wcmV2aW91c1NpYmxpbmcgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpXTsKICAgICAgLy8gY29uc3QgazEgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzJdIC0gY3VycmVudExldmVsTm9kZXNbaV0ueUFycmF5WzFdOwogICAgICAvLyBjb25zdCBrMiA9IGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS55QXJyYXlbMV0gLSBjdXJyZW50TGV2ZWxOb2Rlc1tpXS55QXJyYXlbMl07CiAgICAgIC8vIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnRyZW5kUmFuZ2UgPSBrMSA8IGsyID8gW2N1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS55QXJyYXlbMl0sIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnlBcnJheVsxXSwgY3VycmVudExldmVsTm9kZXNbaSArIDFdLnlBcnJheVsxXSwgY3VycmVudExldmVsTm9kZXNbaV0ueUFycmF5WzJdXSA6IFtjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzFdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpXS55QXJyYXlbMl0sIGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS55QXJyYXlbMl0sIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnlBcnJheVsxXV07CiAgICB9CiAgICBsYXN0TGV2ZWxOb2RlcyA9IGN1cnJlbnRMZXZlbE5vZGVzOwogICAgY3VycmVudExldmVsTm9kZXMgPSBbXTsKICB9CiAgY29uc3QgbGV2ZWxEYXRhTWFuYWdlciA9IG5ldyBMZXZlbERhdGFNYW5hZ2VyKGxldmVsSW5kZXgsIHRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHN0b3JlLnN0YXRlLmNvbnRyb2xQYXJhbXMuY3VycmVudFRhYmxlKTsKICAvLyBsZXZlbERhdGFNYW5hZ2VyLmFkZE5vZGVOdW0obm9kZU51bSkKICAvLyBjb25zb2xlLmxvZyhsZXZlbERhdGFNYW5hZ2VyLmN1ck5vZGVOdW0sbGV2ZWxEYXRhTWFuYWdlci5jYWNoZU1hcC5zaXplKQogIHJldHVybiB7CiAgICBkYXRhTWFuYWdlcjogbGV2ZWxEYXRhTWFuYWdlciwKICAgIHRyZW5kVHJlZTogcm9vdAogIH07Cn0KLy8gZnVuY3Rpb24gY29uc3RydWN0UmF3TWluTWF4VHJlbmRUcmVlKGRhdGE6IEFycmF5PGFueT4sIHRhYmxlTmFtZT86IHN0cmluZykgewovLyAgICAgY29uc3QgbGV2ZWxJbmRleCA9IG5ldyBBcnJheTxMZXZlbEluZGV4T2JqPihNYXRoLmNlaWwoTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSkpOwovLyAgICAgLy9jb25zdCBkYXRhTWFuYWdlcj1uZXcgTGV2ZWxEYXRhTWFuYWdlcigpCi8vICAgICBjb25zdCBtaW50ZDogQXJyYXk8bnVtYmVyPiA9IFtdOwovLyAgICAgY29uc3QgbWludmQ6IEFycmF5PG51bWJlcj4gPSBbXTsKLy8gICAgIGNvbnN0IG1heHZkOiBBcnJheTxudW1iZXI+ID0gW107Ci8vICAgICBjb25zdCBtYXh0ZDogQXJyYXk8bnVtYmVyPiA9IFtdOwovLyAgICAgZGF0YS5mb3JFYWNoKHYgPT4gewovLyAgICAgICAgIG1pbnRkLnB1c2godi5taW50KTsKLy8gICAgICAgICBtaW52ZC5wdXNoKHYubWludik7Ci8vICAgICAgICAgbWF4dmQucHVzaCh2Lm1heHYpOwovLyAgICAgICAgIG1heHRkLnB1c2godi5tYXh0KTsKLy8gICAgIH0pOwovLyAgICAgbGV0IHRlbXBMYXN0ID0gbWludGQucG9wKCk7Ci8vICAgICBtaW50ZC51bnNoaWZ0KHRlbXBMYXN0ISk7Ci8vICAgICB0ZW1wTGFzdCA9IG1pbnZkLnBvcCgpOwovLyAgICAgbWludmQudW5zaGlmdCh0ZW1wTGFzdCEpOwovLyAgICAgdGVtcExhc3QgPSBtYXh2ZC5wb3AoKTsKLy8gICAgIG1heHZkLnVuc2hpZnQodGVtcExhc3QhKTsKLy8gICAgIHRlbXBMYXN0ID0gbWF4dGQucG9wKCk7Ci8vICAgICBtYXh0ZC51bnNoaWZ0KHRlbXBMYXN0ISk7Ci8vICAgICBsZXQgbGFzdExldmVsTm9kZXMgPSBuZXcgQXJyYXk8VHJlbmRUcmVlPigpOwovLyAgICAgbGV0IGN1cnJlbnRMZXZlbE5vZGVzID0gbmV3IEFycmF5PFRyZW5kVHJlZT4oKTsKLy8gICAgIGxldCBub2RlTnVtID0gMQovLyAgICAgY29uc3Qgcm9vdCA9IG5ldyBUcmVuZFRyZWUobnVsbCwgdHJ1ZSwgMCwgW21pbnRkWzBdLCBtaW52ZFswXSwgbWF4dmRbMF0sIG1heHRkWzBdXSwgWzAsIDAsIDAsIDBdKTsKLy8gICAgIGxhc3RMZXZlbE5vZGVzLnB1c2gocm9vdCk7Ci8vICAgICBsZXZlbEluZGV4WzBdID0gbmV3IExldmVsSW5kZXhPYmooMCwgdHJ1ZSk7Ci8vICAgICBsZXZlbEluZGV4WzBdLmFkZExvYWRlZERhdGFSYW5nZShyb290LCBbMCwgMF0pOwovLyAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKTsgaSsrKSB7Ci8vICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyICoqIChpIC0gMSk7IGorKykgewovLyAgICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IGxhc3RMZXZlbE5vZGVzW2pdOwovLyAgICAgICAgICAgICAvL0B0cy1pZ25vcmUKLy8gICAgICAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgdHJ1ZSwgbGFzdE5vZGUuaW5kZXgsIFttaW50ZFtqICogMiArIDIgKiogaV0sIG1pbnZkW2ogKiAyICsgMiAqKiBpXSwgbWF4dmRbaiAqIDIgKyAyICoqIGldLCBtYXh0ZFtqICogMiArIDIgKiogaV1dLCBbMCwgMCwgMCwgMF0pOwovLyAgICAgICAgICAgICAvL0B0cy1pZ25vcmUKLy8gICAgICAgICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIGZhbHNlLCBsYXN0Tm9kZS5pbmRleCwgW21pbnRkW2ogKiAyICsgMSArIDIgKiogaV0sIG1pbnZkW2ogKiAyICsgMSArIDIgKiogaV0sIG1heHZkW2ogKiAyICsgMSArIDIgKiogaV0sIG1heHRkW2ogKiAyICsgMSArIDIgKiogaV1dLCBbMCwgMCwgMCwgMF0pOwovLyAgICAgICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKGZpcnN0Tm9kZSk7Ci8vICAgICAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzLnB1c2goc2Vjb25kTm9kZSk7Ci8vICAgICAgICAgICAgIG5vZGVOdW0gKz0gMgovLyAgICAgICAgIH0KLy8gICAgICAgICBsZXZlbEluZGV4W2ldID0gbmV3IExldmVsSW5kZXhPYmooY3VycmVudExldmVsTm9kZXNbMF0ubGV2ZWwsIHRydWUpOwovLyAgICAgICAgIGxldmVsSW5kZXhbaV0uYWRkTG9hZGVkRGF0YVJhbmdlKGN1cnJlbnRMZXZlbE5vZGVzWzBdLCBbMCwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0pOwovLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7Ci8vICAgICAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2ldLm5leHRTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdOwovLyAgICAgICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ucHJldmlvdXNTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaV07Ci8vICAgICAgICAgfQovLyAgICAgICAgIGxhc3RMZXZlbE5vZGVzID0gY3VycmVudExldmVsTm9kZXM7Ci8vICAgICAgICAgY3VycmVudExldmVsTm9kZXMgPSBbXTsKLy8gICAgIH0KLy8gICAgIGNvbnN0IGxldmVsRGF0YU1hbmFnZXIgPSBuZXcgTGV2ZWxEYXRhTWFuYWdlcihsZXZlbEluZGV4LCB0YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiBzdG9yZS5zdGF0ZS5jb250cm9sUGFyYW1zLmN1cnJlbnRUYWJsZSk7Ci8vICAgICByZXR1cm4gewovLyAgICAgICAgIGRhdGFNYW5hZ2VyOiBsZXZlbERhdGFNYW5hZ2VyLAovLyAgICAgICAgIHRyZW5kVHJlZTogcm9vdAovLyAgICAgfQovLyB9Ci8vIGZ1bmN0aW9uIGNvbnN0cnVjdE1pbk1heFRyZW5kVHJlZShkYXRhOiBBcnJheTxhbnk+LCB0YWJsZU5hbWU/OiBzdHJpbmcpIHsKLy8gICAgIGNvbnNvbGUubG9nKGRhdGEubGVuZ3RoKTsKLy8gICAgIGNvbnN0IGxldmVsSW5kZXggPSBuZXcgQXJyYXk8TGV2ZWxJbmRleE9iaj4oTWF0aC5jZWlsKE1hdGgubG9nMihkYXRhLmxlbmd0aCkpKTsKLy8gICAgIC8vY29uc3QgZGF0YU1hbmFnZXI9bmV3IExldmVsRGF0YU1hbmFnZXIoKQovLyAgICAgY29uc3QgbWludmQ6IEFycmF5PG51bWJlcj4gPSBbXTsKLy8gICAgIGNvbnN0IG1heHZkOiBBcnJheTxudW1iZXI+ID0gW107Ci8vICAgICBkYXRhLmZvckVhY2godiA9PiB7Ci8vICAgICAgICAgbWludmQucHVzaCh2Lm1pbnZkKTsKLy8gICAgICAgICBtYXh2ZC5wdXNoKHYubWF4dmQpOwovLyAgICAgfSk7Ci8vICAgICBsZXQgdGVtcExhc3QgPSBtaW52ZC5wb3AoKTsKLy8gICAgIG1pbnZkLnVuc2hpZnQodGVtcExhc3QhKTsKLy8gICAgIHRlbXBMYXN0ID0gbWF4dmQucG9wKCk7Ci8vICAgICBtYXh2ZC51bnNoaWZ0KHRlbXBMYXN0ISk7Ci8vICAgICBsZXQgbGFzdExldmVsTm9kZXMgPSBuZXcgQXJyYXk8VHJlbmRUcmVlPigpOwovLyAgICAgbGV0IGN1cnJlbnRMZXZlbE5vZGVzID0gbmV3IEFycmF5PFRyZW5kVHJlZT4oKTsKLy8gICAgIGxldCBub2RlTnVtID0gMQovLyAgICAgY29uc3Qgcm9vdCA9IG5ldyBUcmVuZFRyZWUobnVsbCwgdHJ1ZSwgMCwgWzAsIG1pbnZkWzBdLCBtYXh2ZFswXSwgMF0sIFswLCBtaW52ZFsxXSwgbWF4dmRbMV0sIDBdKTsKLy8gICAgIGxhc3RMZXZlbE5vZGVzLnB1c2gocm9vdCk7Ci8vICAgICBsZXZlbEluZGV4WzBdID0gbmV3IExldmVsSW5kZXhPYmooMCwgdHJ1ZSk7Ci8vICAgICBsZXZlbEluZGV4WzBdLmFkZExvYWRlZERhdGFSYW5nZShyb290LCBbMCwgMF0pOwovLyAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKTsgaSsrKSB7Ci8vICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyICoqIChpIC0gMSk7IGorKykgewovLyAgICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IGxhc3RMZXZlbE5vZGVzW2pdOwovLyAgICAgICAgICAgICAvL0B0cy1pZ25vcmUKLy8gICAgICAgICAgICAgY29uc3QgeUFycmF5MTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBuZXcgQXJyYXkoNCk7Ci8vICAgICAgICAgICAgIC8vQHRzLWlnbm9yZQovLyAgICAgICAgICAgICBjb25zdCB5QXJyYXkyOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IG5ldyBBcnJheSg0KTsKLy8gICAgICAgICAgICAgeUFycmF5MVswXSA9IGxhc3ROb2RlLnlBcnJheVswXTsKLy8gICAgICAgICAgICAgeUFycmF5MlswXSA9IGxhc3ROb2RlLnlBcnJheVswXSAtIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzBdOwovLyAgICAgICAgICAgICBpZiAobGFzdE5vZGUuZGlmZmVyZW5jZSFbMV0gPj0gMCkgewovLyAgICAgICAgICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXSArIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzFdOwovLyAgICAgICAgICAgICAgICAgeUFycmF5MlsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKLy8gICAgICAgICAgICAgfSBlbHNlIHsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07Ci8vICAgICAgICAgICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdIC0gbGFzdE5vZGUuZGlmZmVyZW5jZSFbMV07Ci8vICAgICAgICAgICAgIH0KLy8gICAgICAgICAgICAgaWYgKGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdID49IDApIHsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07Ci8vICAgICAgICAgICAgICAgICB5QXJyYXkyWzJdID0gbGFzdE5vZGUueUFycmF5WzJdIC0gbGFzdE5vZGUuZGlmZmVyZW5jZSFbMl07Ci8vICAgICAgICAgICAgIH0gZWxzZSB7Ci8vICAgICAgICAgICAgICAgICB5QXJyYXkxWzJdID0gbGFzdE5vZGUueUFycmF5WzJdICsgbGFzdE5vZGUuZGlmZmVyZW5jZSFbMl07Ci8vICAgICAgICAgICAgICAgICB5QXJyYXkyWzJdID0gbGFzdE5vZGUueUFycmF5WzJdOwovLyAgICAgICAgICAgICB9Ci8vICAgICAgICAgICAgIHlBcnJheTFbM10gPSBsYXN0Tm9kZS55QXJyYXlbM10gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlIVszXTsKLy8gICAgICAgICAgICAgeUFycmF5MlszXSA9IGxhc3ROb2RlLnlBcnJheVszXTsKLy8gICAgICAgICAgICAgLy9AdHMtaWdub3JlCi8vICAgICAgICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIHRydWUsIGxhc3ROb2RlLmluZGV4LCB5QXJyYXkxLCBpID09PSBNYXRoLmxvZzIoZGF0YS5sZW5ndGgpID8gbnVsbCA6IFswLCBtaW52ZFtqICogMiArIDIgKiogaV0sIG1heHZkW2ogKiAyICsgMiAqKiBpXSwgMF0pOwovLyAgICAgICAgICAgICAvL0B0cy1pZ25vcmUKLy8gICAgICAgICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIGZhbHNlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MiwgaSA9PT0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSA/IG51bGwgOiBbMCwgbWludmRbaiAqIDIgKyAxICsgMiAqKiBpXSwgbWF4dmRbaiAqIDIgKyAxICsgMiAqKiBpXSwgMF0pOwovLyAgICAgICAgICAgICAvLyBpZiAoaiA9PT0gMCkgewovLyAgICAgICAgICAgICAvLyAgICAgbGV2ZWxJbmRleFtpXT1uZXcgTGV2ZWxJbmRleE9iaihmaXJzdE5vZGUubGV2ZWwsdHJ1ZSk7Ci8vICAgICAgICAgICAgIC8vICAgICBsZXZlbEluZGV4W2ldLmFkZExvYWRlZERhdGFSYW5nZShmaXJzdE5vZGUsWzAsXSkKLy8gICAgICAgICAgICAgLy8gfQovLyAgICAgICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKGZpcnN0Tm9kZSk7Ci8vICAgICAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzLnB1c2goc2Vjb25kTm9kZSk7Ci8vICAgICAgICAgICAgIG5vZGVOdW0gKz0gMgovLyAgICAgICAgIH0KLy8gICAgICAgICBsZXZlbEluZGV4W2ldID0gbmV3IExldmVsSW5kZXhPYmooY3VycmVudExldmVsTm9kZXNbMF0ubGV2ZWwsIHRydWUpOwovLyAgICAgICAgIGxldmVsSW5kZXhbaV0uYWRkTG9hZGVkRGF0YVJhbmdlKGN1cnJlbnRMZXZlbE5vZGVzWzBdLCBbMCwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0pOwovLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7Ci8vICAgICAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2ldLm5leHRTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdOwovLyAgICAgICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ucHJldmlvdXNTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaV07Ci8vICAgICAgICAgICAgIC8vIGNvbnN0IGsxID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdLnlBcnJheVsyXSAtIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnlBcnJheVsxXTsKLy8gICAgICAgICAgICAgLy8gY29uc3QgazIgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzFdIC0gY3VycmVudExldmVsTm9kZXNbaV0ueUFycmF5WzJdOwovLyAgICAgICAgICAgICAvLyBjdXJyZW50TGV2ZWxOb2Rlc1tpXS50cmVuZFJhbmdlID0gazEgPCBrMiA/IFtjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzJdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpXS55QXJyYXlbMV0sIGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS55QXJyYXlbMV0sIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnlBcnJheVsyXV0gOiBbY3VycmVudExldmVsTm9kZXNbaSArIDFdLnlBcnJheVsxXSwgY3VycmVudExldmVsTm9kZXNbaV0ueUFycmF5WzJdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzJdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpXS55QXJyYXlbMV1dOwovLyAgICAgICAgIH0KLy8gICAgICAgICBsYXN0TGV2ZWxOb2RlcyA9IGN1cnJlbnRMZXZlbE5vZGVzOwovLyAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzID0gW107Ci8vICAgICB9Ci8vICAgICBjb25zdCBsZXZlbERhdGFNYW5hZ2VyID0gbmV3IExldmVsRGF0YU1hbmFnZXIobGV2ZWxJbmRleCwgdGFibGVOYW1lID8gdGFibGVOYW1lIDogc3RvcmUuc3RhdGUuY29udHJvbFBhcmFtcy5jdXJyZW50VGFibGUpOwovLyAgICAgLy8gbGV2ZWxEYXRhTWFuYWdlci5hZGROb2RlTnVtKG5vZGVOdW0pCi8vICAgICAvLyBjb25zb2xlLmxvZyhsZXZlbERhdGFNYW5hZ2VyLmN1ck5vZGVOdW0sbGV2ZWxEYXRhTWFuYWdlci5jYWNoZU1hcC5zaXplKQovLyAgICAgcmV0dXJuIHsKLy8gICAgICAgICBkYXRhTWFuYWdlcjogbGV2ZWxEYXRhTWFuYWdlciwKLy8gICAgICAgICB0cmVuZFRyZWU6IHJvb3QKLy8gICAgIH0KLy8gfQovLyBmdW5jdGlvbiBjb25zdHJ1Y3RNaXNzVHJlbmRUcmVlKGRhdGE6IEFycmF5PGFueT4sIHRhYmxlTmFtZT86IHN0cmluZykgewovLyAgICAgY29uc3QgbGV2ZWxJbmRleCA9IG5ldyBBcnJheTxMZXZlbEluZGV4T2JqPihNYXRoLmNlaWwoTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSkpOwovLyAgICAgLy9jb25zdCBkYXRhTWFuYWdlcj1uZXcgTGV2ZWxEYXRhTWFuYWdlcigpCi8vICAgICBjb25zdCBtaW50ZDogQXJyYXk8bnVtYmVyPiA9IFtdOwovLyAgICAgY29uc3QgbWludmQ6IEFycmF5PG51bWJlcj4gPSBbXTsKLy8gICAgIGNvbnN0IG1heHZkOiBBcnJheTxudW1iZXI+ID0gW107Ci8vICAgICBjb25zdCBtYXh0ZDogQXJyYXk8bnVtYmVyPiA9IFtdOwovLyAgICAgZGF0YS5mb3JFYWNoKHYgPT4gewovLyAgICAgICAgIG1pbnRkLnB1c2godi5taW5pZCk7Ci8vICAgICAgICAgbWludmQucHVzaCh2Lm1pbnZkKTsKLy8gICAgICAgICBtYXh2ZC5wdXNoKHYubWF4dmQpOwovLyAgICAgICAgIG1heHRkLnB1c2godi5tYXhpZCk7Ci8vICAgICB9KTsKLy8gICAgIGxldCB0ZW1wTGFzdCA9IG1pbnRkLnBvcCgpOwovLyAgICAgbWludGQudW5zaGlmdCh0ZW1wTGFzdCEpOwovLyAgICAgdGVtcExhc3QgPSBtaW52ZC5wb3AoKTsKLy8gICAgIG1pbnZkLnVuc2hpZnQodGVtcExhc3QhKTsKLy8gICAgIHRlbXBMYXN0ID0gbWF4dmQucG9wKCk7Ci8vICAgICBtYXh2ZC51bnNoaWZ0KHRlbXBMYXN0ISk7Ci8vICAgICB0ZW1wTGFzdCA9IG1heHRkLnBvcCgpOwovLyAgICAgbWF4dGQudW5zaGlmdCh0ZW1wTGFzdCEpOwovLyAgICAgbGV0IGxhc3RMZXZlbE5vZGVzID0gbmV3IEFycmF5PFRyZW5kVHJlZT4oKTsKLy8gICAgIGxldCBjdXJyZW50TGV2ZWxOb2RlcyA9IG5ldyBBcnJheTxUcmVuZFRyZWU+KCk7Ci8vICAgICBsZXQgbm9kZU51bSA9IDEKLy8gICAgIGNvbnN0IHJvb3QgPSBuZXcgVHJlbmRUcmVlKG51bGwsIHRydWUsIDAsIFttaW50ZFswXSwgbWludmRbMF0sIG1heHZkWzBdLCBtYXh0ZFswXV0sIFttaW50ZFsxXSwgbWludmRbMV0sIG1heHZkWzFdLCBtYXh0ZFsxXV0pOwovLyAgICAgbGFzdExldmVsTm9kZXMucHVzaChyb290KTsKLy8gICAgIGxldmVsSW5kZXhbMF0gPSBuZXcgTGV2ZWxJbmRleE9iaigwLCB0cnVlKTsKLy8gICAgIGxldmVsSW5kZXhbMF0uYWRkTG9hZGVkRGF0YVJhbmdlKHJvb3QsIFswLCAwXSk7Ci8vICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBNYXRoLmxvZzIoZGF0YS5sZW5ndGgpOyBpKyspIHsKLy8gICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDIgKiogKGkgLSAxKTsgaisrKSB7Ci8vICAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gbGFzdExldmVsTm9kZXNbal07Ci8vICAgICAgICAgICAgIGxldCBkaWYgPSBsYXN0Tm9kZS5kaWZmZXJlbmNlITsKLy8gICAgICAgICAgICAgbGV0IGN1ck5vZGVUeXBlOiAiTyIgfCAiTlVMTCIgfCAiTEVGVE5VTEwiIHwgIlJJR0hUTlVMTCIgPSAnTyc7Ci8vICAgICAgICAgICAgIGlmIChkaWZbMV0gPT09IG51bGwgJiYgZGlmWzJdID09PSBudWxsKSB7Ci8vICAgICAgICAgICAgICAgICBjdXJOb2RlVHlwZSA9ICJOVUxMIjsKLy8gICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZbMF0gPT09IG51bGwgJiYgZGlmWzFdID09PSBudWxsKSB7Ci8vICAgICAgICAgICAgICAgICBjdXJOb2RlVHlwZSA9ICJMRUZUTlVMTCIKLy8gICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZbMl0gPT09IG51bGwgJiYgZGlmWzNdID09PSBudWxsKSB7Ci8vICAgICAgICAgICAgICAgICBjdXJOb2RlVHlwZSA9ICJSSUdIVE5VTEwiOwovLyAgICAgICAgICAgICB9Ci8vICAgICAgICAgICAgIGxhc3ROb2RlLm5vZGVUeXBlID0gY3VyTm9kZVR5cGU7Ci8vICAgICAgICAgICAgIGNvbnN0IHlBcnJheTE6IFthbnksIGFueSwgYW55LCBhbnldID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF0KLy8gICAgICAgICAgICAgY29uc3QgeUFycmF5MjogW2FueSwgYW55LCBhbnksIGFueV0gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXQovLyAgICAgICAgICAgICBpZiAoY3VyTm9kZVR5cGUgPT09ICdPJykgewovLyAgICAgICAgICAgICAgICAgeUFycmF5MVswXSA9IGxhc3ROb2RlLnlBcnJheVswXTsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMF0gPSBsYXN0Tm9kZS55QXJyYXlbMF0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlIVswXTsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbM10gPSBsYXN0Tm9kZS55QXJyYXlbM10gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlIVszXTsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbM10gPSBsYXN0Tm9kZS55QXJyYXlbM107Ci8vICAgICAgICAgICAgICAgICBpZiAobGFzdE5vZGUuZGlmZmVyZW5jZSFbMV0gPCAwKSB7Ci8vICAgICAgICAgICAgICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKLy8gICAgICAgICAgICAgICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdIC0gbGFzdE5vZGUuZGlmZmVyZW5jZSFbMV07Ci8vICAgICAgICAgICAgICAgICB9IGVsc2UgewovLyAgICAgICAgICAgICAgICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlIVsxXTsKLy8gICAgICAgICAgICAgICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdCi8vICAgICAgICAgICAgICAgICB9Ci8vICAgICAgICAgICAgICAgICBpZiAobGFzdE5vZGUuZGlmZmVyZW5jZSFbMl0gPCAwKSB7Ci8vICAgICAgICAgICAgICAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSArIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdOwovLyAgICAgICAgICAgICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07Ci8vICAgICAgICAgICAgICAgICB9IGVsc2UgewovLyAgICAgICAgICAgICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07Ci8vICAgICAgICAgICAgICAgICAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSAtIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdOwovLyAgICAgICAgICAgICAgICAgfQovLyAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09ICJMRUZUTlVMTCIpIHsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMF0gPSBsYXN0Tm9kZS55QXJyYXlbMF0KLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07Ci8vICAgICAgICAgICAgICAgICB5QXJyYXkyWzJdID0gbGFzdE5vZGUueUFycmF5WzJdOwovLyAgICAgICAgICAgICAgICAgeUFycmF5MlszXSA9IGxhc3ROb2RlLnlBcnJheVszXTsKLy8gICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJOb2RlVHlwZSA9PSAiUklHSFROVUxMIikgewovLyAgICAgICAgICAgICAgICAgeUFycmF5MVswXSA9IGxhc3ROb2RlLnlBcnJheVswXQovLyAgICAgICAgICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07Ci8vICAgICAgICAgICAgICAgICB5QXJyYXkxWzNdID0gbGFzdE5vZGUueUFycmF5WzNdOwovLyAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09PSAnTlVMTCcpIHsKLy8gICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIm51bGwgbm9kZSIpCi8vICAgICAgICAgICAgIH0KLy8gICAgICAgICAgICAgZWxzZSB7Ci8vICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInR5cGUgZXJyb3IiKQovLyAgICAgICAgICAgICB9Ci8vICAgICAgICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIHRydWUsIGxhc3ROb2RlLmluZGV4LCB5QXJyYXkxLCBpID09PSBNYXRoLmxvZzIoZGF0YS5sZW5ndGgpID8gbnVsbCA6IFttaW50ZFtqICogMiArIDIgKiogaV0sIG1pbnZkW2ogKiAyICsgMiAqKiBpXSwgbWF4dmRbaiAqIDIgKyAyICoqIGldLCBtYXh0ZFtqICogMiArIDIgKiogaV1dKTsKLy8gICAgICAgICAgICAgaWYgKGxhc3ROb2RlLm5vZGVUeXBlID09PSAnTEVGVE5VTEwnIHx8IGxhc3ROb2RlLm5vZGVUeXBlID09PSAnTlVMTCcpIHsKLy8gICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5ub2RlVHlwZSA9ICdOVUxMJzsKLy8gICAgICAgICAgICAgfQovLyAgICAgICAgICAgICAvL0B0cy1pZ25vcmUKLy8gICAgICAgICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIGZhbHNlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MiwgaSA9PT0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSA/IG51bGwgOiBbbWludGRbaiAqIDIgKyAxICsgMiAqKiBpXSwgbWludmRbaiAqIDIgKyAxICsgMiAqKiBpXSwgbWF4dmRbaiAqIDIgKyAxICsgMiAqKiBpXSwgbWF4dGRbaiAqIDIgKyAxICsgMiAqKiBpXV0pOwovLyAgICAgICAgICAgICBpZiAobGFzdE5vZGUubm9kZVR5cGUgPT09ICdSSUdIVE5VTEwnIHx8IGxhc3ROb2RlLm5vZGVUeXBlID09ICdOVUxMJykgewovLyAgICAgICAgICAgICAgICAgc2Vjb25kTm9kZS5ub2RlVHlwZSA9ICdOVUxMJzsKLy8gICAgICAgICAgICAgfQovLyAgICAgICAgICAgICAvLyBpZiAoaiA9PT0gMCkgewovLyAgICAgICAgICAgICAvLyAgICAgbGV2ZWxJbmRleFtpXT1uZXcgTGV2ZWxJbmRleE9iaihmaXJzdE5vZGUubGV2ZWwsdHJ1ZSk7Ci8vICAgICAgICAgICAgIC8vICAgICBsZXZlbEluZGV4W2ldLmFkZExvYWRlZERhdGFSYW5nZShmaXJzdE5vZGUsWzAsXSkKLy8gICAgICAgICAgICAgLy8gfQovLyAgICAgICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKGZpcnN0Tm9kZSk7Ci8vICAgICAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzLnB1c2goc2Vjb25kTm9kZSk7Ci8vICAgICAgICAgICAgIG5vZGVOdW0gKz0gMgovLyAgICAgICAgIH0KLy8gICAgICAgICBsZXZlbEluZGV4W2ldID0gbmV3IExldmVsSW5kZXhPYmooY3VycmVudExldmVsTm9kZXNbMF0ubGV2ZWwsIHRydWUpOwovLyAgICAgICAgIGxldmVsSW5kZXhbaV0uYWRkTG9hZGVkRGF0YVJhbmdlKGN1cnJlbnRMZXZlbE5vZGVzWzBdLCBbMCwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0pOwovLyAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7Ci8vICAgICAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2ldLm5leHRTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdOwovLyAgICAgICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ucHJldmlvdXNTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaV07Ci8vICAgICAgICAgICAgIC8vIGNvbnN0IGsxID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdLnlBcnJheVsyXSAtIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnlBcnJheVsxXTsKLy8gICAgICAgICAgICAgLy8gY29uc3QgazIgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzFdIC0gY3VycmVudExldmVsTm9kZXNbaV0ueUFycmF5WzJdOwovLyAgICAgICAgICAgICAvLyBjdXJyZW50TGV2ZWxOb2Rlc1tpXS50cmVuZFJhbmdlID0gazEgPCBrMiA/IFtjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzJdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpXS55QXJyYXlbMV0sIGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS55QXJyYXlbMV0sIGN1cnJlbnRMZXZlbE5vZGVzW2ldLnlBcnJheVsyXV0gOiBbY3VycmVudExldmVsTm9kZXNbaSArIDFdLnlBcnJheVsxXSwgY3VycmVudExldmVsTm9kZXNbaV0ueUFycmF5WzJdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ueUFycmF5WzJdLCBjdXJyZW50TGV2ZWxOb2Rlc1tpXS55QXJyYXlbMV1dOwovLyAgICAgICAgIH0KLy8gICAgICAgICBsYXN0TGV2ZWxOb2RlcyA9IGN1cnJlbnRMZXZlbE5vZGVzOwovLyAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzID0gW107Ci8vICAgICB9Ci8vICAgICBjb25zdCBsZXZlbERhdGFNYW5hZ2VyID0gbmV3IExldmVsRGF0YU1hbmFnZXIobGV2ZWxJbmRleCwgdGFibGVOYW1lID8gdGFibGVOYW1lIDogc3RvcmUuc3RhdGUuY29udHJvbFBhcmFtcy5jdXJyZW50VGFibGUpOwovLyAgICAgLy8gbGV2ZWxEYXRhTWFuYWdlci5hZGROb2RlTnVtKG5vZGVOdW0pCi8vICAgICAvLyBjb25zb2xlLmxvZyhsZXZlbERhdGFNYW5hZ2VyLmN1ck5vZGVOdW0sbGV2ZWxEYXRhTWFuYWdlci5jYWNoZU1hcC5zaXplKQovLyAgICAgcmV0dXJuIHsKLy8gICAgICAgICBkYXRhTWFuYWdlcjogbGV2ZWxEYXRhTWFuYWdlciwKLy8gICAgICAgICB0cmVuZFRyZWU6IHJvb3QKLy8gICAgIH0KLy8gfQpmdW5jdGlvbiBjb25zdHJ1Y3RNaW5NYXhNaXNzVHJlbmRUcmVlKGRhdGEsIHdpZHRoLCB0YWJsZU5hbWUpIHsKICBjb25zdCBpbml0TGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSk7CiAgLy8gY29uc3QgaW5pdExldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nMih3aWR0aCkpOwogIC8vIGNvbnN0IGluaXRMZXZlbCA9IDI7CiAgLy9kZWJ1Z2dlcgogIGNvbnN0IGxldmVsSW5kZXggPSBuZXcgQXJyYXkoTWF0aC5jZWlsKE1hdGgubG9nMihkYXRhLmxlbmd0aCkpICsgMSk7CiAgY29uc3QgbWludmQgPSBbXTsKICBjb25zdCBtYXh2ZCA9IFtdOwogIGNvbnN0IGF2ZXZkID0gW107CiAgZGF0YS5mb3JFYWNoKHYgPT4gewogICAgbWludmQucHVzaCh2Lm1pbnZkKTsKICAgIG1heHZkLnB1c2godi5tYXh2ZCk7CiAgICBhdmV2ZC5wdXNoKHYuYXZldmQpOwogIH0pOwogIGxldCB0ZW1wTGFzdCA9IG1pbnZkLnBvcCgpOwogIG1pbnZkLnVuc2hpZnQodGVtcExhc3QpOwogIHRlbXBMYXN0ID0gbWF4dmQucG9wKCk7CiAgbWF4dmQudW5zaGlmdCh0ZW1wTGFzdCk7CiAgdGVtcExhc3QgPSBhdmV2ZC5wb3AoKTsKICBhdmV2ZC51bnNoaWZ0KHRlbXBMYXN0KTsKICBsZXQgbGFzdExldmVsTm9kZXMgPSBuZXcgQXJyYXkoKTsKICBsZXQgY3VycmVudExldmVsTm9kZXMgPSBuZXcgQXJyYXkoKTsKICBsZXQgbm9kZU51bSA9IDE7CiAgLy9AdHMtaWdub3JlCiAgY29uc3Qgcm9vdCA9IG5ldyBUcmVuZFRyZWUobnVsbCwgdHJ1ZSwgMCwgW3VuZGVmaW5lZCwgbWludmRbMF0sIG1heHZkWzBdLCBhdmV2ZFswXSwgdW5kZWZpbmVkXSwgW3VuZGVmaW5lZCwgbWludmRbMV0sIG1heHZkWzFdLCBhdmV2ZFsxXSwgdW5kZWZpbmVkXSk7CiAgbGFzdExldmVsTm9kZXMucHVzaChyb290KTsKICBsZXZlbEluZGV4WzBdID0gbmV3IExldmVsSW5kZXhPYmooMCwgdHJ1ZSk7CiAgbGV2ZWxJbmRleFswXS5hZGRMb2FkZWREYXRhUmFuZ2Uocm9vdCwgWzAsIDBdKTsKICBsZXQgZGlmSW5kZXggPSAxOwogIGZvciAobGV0IGkgPSAxOyBpIDw9IGluaXRMZXZlbDsgaSsrKSB7CiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxhc3RMZXZlbE5vZGVzLmxlbmd0aDsgaisrKSB7CiAgICAgIGNvbnN0IGxhc3ROb2RlID0gbGFzdExldmVsTm9kZXNbal07CiAgICAgIGlmIChsYXN0Tm9kZS5ub2RlVHlwZSA9PT0gIk5VTEwiKSB7CiAgICAgICAgLy9kZWJ1Z2dlcgogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmIChkaWZJbmRleCA9PT0gbWludmQubGVuZ3RoKSB7CiAgICAgICAgZGVidWdnZXI7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJkaWZmIGluZGV4IGVycm9yIik7CiAgICAgIH0KICAgICAgbGV0IGRpZiA9IFttaW52ZFtkaWZJbmRleF0sIG1heHZkW2RpZkluZGV4XSwgYXZldmRbZGlmSW5kZXhdXTsKICAgICAgZGlmSW5kZXgrKzsKICAgICAgbGV0IGN1ck5vZGVUeXBlID0gJ08nOwogICAgICBpZiAoZGlmWzBdID09PSBudWxsICYmIGRpZlsxXSA9PT0gbnVsbCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiZGF0YSBlcnJvciIpOwogICAgICAgIC8vIGN1ck5vZGVUeXBlID0gIk5VTEwiOwogICAgICB9IGVsc2UgaWYgKGRpZlswXSA9PT0gbnVsbCkgewogICAgICAgIGN1ck5vZGVUeXBlID0gIkxFRlROVUxMIjsKICAgICAgICBsYXN0Tm9kZS5nYXBGbGFnID0gJ0wnOwogICAgICB9IGVsc2UgaWYgKGRpZlsxXSA9PT0gbnVsbCkgewogICAgICAgIGN1ck5vZGVUeXBlID0gIlJJR0hUTlVMTCI7CiAgICAgICAgbGFzdE5vZGUuZ2FwRmxhZyA9ICdSJzsKICAgICAgfQogICAgICBpZiAoY3VyTm9kZVR5cGUgIT09ICJPIikgewogICAgICAgIGxhc3ROb2RlLm5vZGVUeXBlID0gY3VyTm9kZVR5cGU7CiAgICAgIH0KICAgICAgY29uc3QgeUFycmF5MSA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF07CiAgICAgIGNvbnN0IHlBcnJheTIgPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdOwogICAgICBpZiAoY3VyTm9kZVR5cGUgPT09ICdPJykgewogICAgICAgIGlmIChkaWZbMF0gPCAwKSB7CiAgICAgICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgICAgeUFycmF5MlsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXSAtIGRpZlswXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXSArIGRpZlswXTsKICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgICAgICAgfQogICAgICAgIGlmIChkaWZbMV0gPCAwKSB7CiAgICAgICAgICB5QXJyYXkxWzJdID0gbGFzdE5vZGUueUFycmF5WzJdICsgZGlmWzFdOwogICAgICAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl0gLSBkaWZbMV07CiAgICAgICAgfQogICAgICAgIGlmIChkaWZbMl0gPD0gMCB8fCBkaWZbMl0gPj0gMCkgewogICAgICAgICAgeUFycmF5MVszXSA9IChsYXN0Tm9kZS55QXJyYXlbM10gKiAyICsgZGlmWzJdKSAvIDI7CiAgICAgICAgICB5QXJyYXkyWzNdID0gKGxhc3ROb2RlLnlBcnJheVszXSAqIDIgLSBkaWZbMl0pIC8gMjsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAoY3VyTm9kZVR5cGUgPT0gIkxFRlROVUxMIikgewogICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgICAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAgICAgICB5QXJyYXkyWzNdID0gbGFzdE5vZGUueUFycmF5WzNdIC8gMjsKICAgICAgfSBlbHNlIGlmIChjdXJOb2RlVHlwZSA9PSAiUklHSFROVUxMIikgewogICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAgICAgICB5QXJyYXkxWzNdID0gbGFzdE5vZGUueUFycmF5WzNdOwogICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09PSAnTlVMTCcpIHsKICAgICAgICBkZWJ1Z2dlcjsKICAgICAgICAvL2NvbnNvbGUubG9nKCJudWxsIG5vZGUiKQogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigidHlwZSBlcnJvciIpOwogICAgICB9CiAgICAgIC8vQHRzLWlnbm9yZQogICAgICBjb25zdCBmaXJzdE5vZGUgPSBuZXcgVHJlbmRUcmVlKGxhc3ROb2RlLCB0cnVlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MSwgbnVsbCwgIk8iKTsKICAgICAgaWYgKGN1ck5vZGVUeXBlID09PSAiTEVGVE5VTEwiKSB7CiAgICAgICAgZmlyc3ROb2RlLm5vZGVUeXBlID0gJ05VTEwnOwogICAgICB9CiAgICAgIC8vQHRzLWlnbm9yZQogICAgICBjb25zdCBzZWNvbmROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgZmFsc2UsIGxhc3ROb2RlLmluZGV4LCB5QXJyYXkyLCBudWxsLCAiTyIpOwogICAgICBpZiAoY3VyTm9kZVR5cGUgPT09ICJSSUdIVE5VTEwiKSB7CiAgICAgICAgc2Vjb25kTm9kZS5ub2RlVHlwZSA9ICdOVUxMJzsKICAgICAgfQogICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKGZpcnN0Tm9kZSk7CiAgICAgIGN1cnJlbnRMZXZlbE5vZGVzLnB1c2goc2Vjb25kTm9kZSk7CiAgICAgIG5vZGVOdW0gKz0gMjsKICAgIH0KICAgIGxldmVsSW5kZXhbaV0gPSBuZXcgTGV2ZWxJbmRleE9iaihjdXJyZW50TGV2ZWxOb2Rlc1swXS5sZXZlbCwgdHJ1ZSk7CiAgICBsZXZlbEluZGV4W2ldLmFkZExvYWRlZERhdGFSYW5nZShjdXJyZW50TGV2ZWxOb2Rlc1swXSwgW2N1cnJlbnRMZXZlbE5vZGVzWzBdLmluZGV4LCBjdXJyZW50TGV2ZWxOb2Rlc1tjdXJyZW50TGV2ZWxOb2Rlcy5sZW5ndGggLSAxXS5pbmRleF0pOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50TGV2ZWxOb2Rlcy5sZW5ndGggLSAxOyBpKyspIHsKICAgICAgY3VycmVudExldmVsTm9kZXNbaV0ubmV4dFNpYmxpbmcgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV07CiAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS5wcmV2aW91c1NpYmxpbmcgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpXTsKICAgIH0KICAgIGxhc3RMZXZlbE5vZGVzID0gY3VycmVudExldmVsTm9kZXM7CiAgICBjdXJyZW50TGV2ZWxOb2RlcyA9IFtdOwogIH0KICBpZiAoZGlmSW5kZXggIT09IG1pbnZkLmxlbmd0aCkgewogICAgZGVidWdnZXI7CiAgICB0aHJvdyBuZXcgRXJyb3IoImRpZmYgbm90IHVlc2VkIik7CiAgfQogIC8vIGRlYnVnZ2VyCiAgLy8gZm9yIChsZXQgaSA9IDE7IGkgPD0gTWF0aC5jZWlsKE1hdGgubG9nMihkYXRhLmxlbmd0aCkpOyBpKyspIHsKICAvLyAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyICoqIChpIC0gMSk7IGorKykgewogIC8vICAgICAgICAgY29uc3QgbGFzdE5vZGUgPSBsYXN0TGV2ZWxOb2Rlc1tqXTsKICAvLyAgICAgICAgIGxldCBkaWYgPSBsYXN0Tm9kZS5kaWZmZXJlbmNlITsKICAvLyAgICAgICAgIGxldCBjdXJOb2RlVHlwZTogIk8iIHwgIk5VTEwiIHwgIkxFRlROVUxMIiB8ICJSSUdIVE5VTEwiID0gJ08nOwogIC8vICAgICAgICAgaWYgKGRpZlsxXSA9PT0gbnVsbCAmJiBkaWZbMl0gPT09IG51bGwpIHsKICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImRhdGEgZXJyb3IiKQogIC8vICAgICAgICAgICAgIC8vIGN1ck5vZGVUeXBlID0gIk5VTEwiOwogIC8vICAgICAgICAgfSBlbHNlIGlmIChkaWZbMV0gPT09IG51bGwpIHsKICAvLyAgICAgICAgICAgICBjdXJOb2RlVHlwZSA9ICJMRUZUTlVMTCIKICAvLyAgICAgICAgIH0gZWxzZSBpZiAoZGlmWzJdID09PSBudWxsKSB7CiAgLy8gICAgICAgICAgICAgZGVidWdnZXIKICAvLyAgICAgICAgICAgICBjdXJOb2RlVHlwZSA9ICJSSUdIVE5VTEwiOwogIC8vICAgICAgICAgfQogIC8vICAgICAgICAgaWYgKGN1ck5vZGVUeXBlICE9PSAiTyIpIHsKICAvLyAgICAgICAgICAgICBsYXN0Tm9kZS5ub2RlVHlwZSA9IGN1ck5vZGVUeXBlCiAgLy8gICAgICAgICB9CiAgLy8gICAgICAgICBjb25zdCB5QXJyYXkxOiBbYW55LCBhbnksIGFueSwgYW55XSA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdCiAgLy8gICAgICAgICBjb25zdCB5QXJyYXkyOiBbYW55LCBhbnksIGFueSwgYW55XSA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdCiAgLy8gICAgICAgICBpZiAoY3VyTm9kZVR5cGUgPT09ICdPJykgewogIC8vICAgICAgICAgICAgIGlmIChsYXN0Tm9kZS5kaWZmZXJlbmNlIVsxXSA8IDApIHsKICAvLyAgICAgICAgICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKICAvLyAgICAgICAgICAgICAgICAgeUFycmF5MlsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXSAtIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzFdOwogIC8vICAgICAgICAgICAgIH0gZWxzZSB7CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gKyBsYXN0Tm9kZS5kaWZmZXJlbmNlIVsxXTsKICAvLyAgICAgICAgICAgICAgICAgeUFycmF5MlsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKICAvLyAgICAgICAgICAgICB9CiAgLy8gICAgICAgICAgICAgaWYgKGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdIDwgMCkgewogIC8vICAgICAgICAgICAgICAgICB5QXJyYXkxWzJdID0gbGFzdE5vZGUueUFycmF5WzJdICsgbGFzdE5vZGUuZGlmZmVyZW5jZSFbMl07CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgLy8gICAgICAgICAgICAgfSBlbHNlIHsKICAvLyAgICAgICAgICAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAvLyAgICAgICAgICAgICAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSAtIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdOwogIC8vICAgICAgICAgICAgIH0KICAvLyAgICAgICAgIH0gZWxzZSBpZiAoY3VyTm9kZVR5cGUgPT0gIkxFRlROVUxMIikgewogIC8vICAgICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgLy8gICAgICAgICAgICAgeUFycmF5MlsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXTsKICAvLyAgICAgICAgIH0gZWxzZSBpZiAoY3VyTm9kZVR5cGUgPT0gIlJJR0hUTlVMTCIpIHsKICAvLyAgICAgICAgICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogIC8vICAgICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgLy8gICAgICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09PSAnTlVMTCcpIHsKICAvLyAgICAgICAgICAgICBkZWJ1Z2dlcgogIC8vICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIm51bGwgbm9kZSIpCiAgLy8gICAgICAgICB9CiAgLy8gICAgICAgICBlbHNlIHsKICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInR5cGUgZXJyb3IiKQogIC8vICAgICAgICAgfQogIC8vICAgICAgICAgLy9AdHMtaWdub3JlCiAgLy8gICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBuZXcgVHJlbmRUcmVlKGxhc3ROb2RlLCB0cnVlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MSwgaSA9PT0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSA/IG51bGwgOiBbdW5kZWZpbmVkLCBtaW52ZFtqICogMiArIDIgKiogaV0sIG1heHZkW2ogKiAyICsgMiAqKiBpXSwgdW5kZWZpbmVkXSk7CiAgLy8gICAgICAgICBpZiAobGFzdE5vZGUubm9kZVR5cGUgPT09ICJMRUZUTlVMTCIpIHsKICAvLyAgICAgICAgICAgICBkZWJ1Z2dlcgogIC8vICAgICAgICAgICAgIGZpcnN0Tm9kZS5ub2RlVHlwZSA9ICdOVUxMJzsKICAvLyAgICAgICAgIH0KICAvLyAgICAgICAgIC8vQHRzLWlnbm9yZQogIC8vICAgICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIGZhbHNlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MiwgaSA9PT0gTWF0aC5sb2cyKGRhdGEubGVuZ3RoKSA/IG51bGwgOiBbdW5kZWZpbmVkLCBtaW52ZFtqICogMiArIDEgKyAyICoqIGldLCBtYXh2ZFtqICogMiArIDEgKyAyICoqIGldLCB1bmRlZmluZWRdKTsKICAvLyAgICAgICAgIGlmIChsYXN0Tm9kZS5ub2RlVHlwZSA9PT0gIlJJR0hUTlVMTCIpIHsKICAvLyAgICAgICAgICAgICBkZWJ1Z2dlcgogIC8vICAgICAgICAgICAgIHNlY29uZE5vZGUubm9kZVR5cGUgPSAnTlVMTCc7CiAgLy8gICAgICAgICB9CiAgLy8gICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKGZpcnN0Tm9kZSk7CiAgLy8gICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKHNlY29uZE5vZGUpOwogIC8vICAgICAgICAgbm9kZU51bSArPSAyCiAgLy8gICAgIH0KICAvLyAgICAgbGV2ZWxJbmRleFtpXSA9IG5ldyBMZXZlbEluZGV4T2JqKGN1cnJlbnRMZXZlbE5vZGVzWzBdLmxldmVsLCB0cnVlKTsKICAvLyAgICAgbGV2ZWxJbmRleFtpXS5hZGRMb2FkZWREYXRhUmFuZ2UoY3VycmVudExldmVsTm9kZXNbMF0sIFswLCBjdXJyZW50TGV2ZWxOb2Rlcy5sZW5ndGggLSAxXSk7CiAgLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7CiAgLy8gICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpXS5uZXh0U2libGluZyA9IGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXTsKICAvLyAgICAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2kgKyAxXS5wcmV2aW91c1NpYmxpbmcgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpXTsKICAvLyAgICAgfQogIC8vICAgICBsYXN0TGV2ZWxOb2RlcyA9IGN1cnJlbnRMZXZlbE5vZGVzOwogIC8vICAgICBjdXJyZW50TGV2ZWxOb2RlcyA9IFtdOwogIC8vIH0KICAvL2RlYnVnZ2VyCiAgY29uc3QgbGV2ZWxEYXRhTWFuYWdlciA9IG5ldyBMZXZlbERhdGFNYW5hZ2VyKGxldmVsSW5kZXgsIHRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHN0b3JlLnN0YXRlLmNvbnRyb2xQYXJhbXMuY3VycmVudFRhYmxlKTsKICByZXR1cm4gewogICAgZGF0YU1hbmFnZXI6IGxldmVsRGF0YU1hbmFnZXIsCiAgICB0cmVuZFRyZWU6IHJvb3QKICB9Owp9CmZ1bmN0aW9uIGNvbnN0cnVjdE1pbk1heE1pc3NUcmVuZFRyZWVGb3JHZXRDaGlsZFRyZWUoZGF0YSwgd2lkdGgsIHRhYmxlTmFtZSkgewogIC8vIGNvbnN0IGluaXRMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIoNjU1MzYpKS0xOwogIGNvbnN0IGluaXRMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIoZGF0YS5sZW5ndGgpKTsKICAvLyBjb25zdCBpbml0TGV2ZWwgPSAyOwogIC8vZGVidWdnZXIKICBjb25zdCBsZXZlbEluZGV4ID0gbmV3IEFycmF5KE1hdGguY2VpbChNYXRoLmxvZzIoZGF0YS5sZW5ndGgpKSArIDEpOwogIGNvbnN0IG1pbnZkID0gW107CiAgY29uc3QgbWF4dmQgPSBbXTsKICBjb25zdCBhdmV2ZCA9IFtdOwogIGRhdGEuZm9yRWFjaCh2ID0+IHsKICAgIG1pbnZkLnB1c2godi5taW52ZCk7CiAgICBtYXh2ZC5wdXNoKHYubWF4dmQpOwogICAgYXZldmQucHVzaCh2LmF2ZXZkKTsKICB9KTsKICBsZXQgdGVtcExhc3QgPSBtaW52ZC5wb3AoKTsKICBtaW52ZC51bnNoaWZ0KHRlbXBMYXN0KTsKICB0ZW1wTGFzdCA9IG1heHZkLnBvcCgpOwogIG1heHZkLnVuc2hpZnQodGVtcExhc3QpOwogIHRlbXBMYXN0ID0gYXZldmQucG9wKCk7CiAgYXZldmQudW5zaGlmdCh0ZW1wTGFzdCk7CiAgbGV0IGxhc3RMZXZlbE5vZGVzID0gbmV3IEFycmF5KCk7CiAgbGV0IGN1cnJlbnRMZXZlbE5vZGVzID0gbmV3IEFycmF5KCk7CiAgbGV0IG5vZGVOdW0gPSAxOwogIC8vQHRzLWlnbm9yZQogIGNvbnN0IHJvb3QgPSBuZXcgVHJlbmRUcmVlKG51bGwsIHRydWUsIDAsIFt1bmRlZmluZWQsIG1pbnZkWzBdLCBtYXh2ZFswXSwgYXZldmRbMF0sIHVuZGVmaW5lZF0sIFt1bmRlZmluZWQsIG1pbnZkWzFdLCBtYXh2ZFsxXSwgYXZldmRbMV0sIHVuZGVmaW5lZF0pOwogIGxhc3RMZXZlbE5vZGVzLnB1c2gocm9vdCk7CiAgbGV2ZWxJbmRleFswXSA9IG5ldyBMZXZlbEluZGV4T2JqKDAsIHRydWUpOwogIGxldmVsSW5kZXhbMF0uYWRkTG9hZGVkRGF0YVJhbmdlKHJvb3QsIFswLCAwXSk7CiAgbGV0IGRpZkluZGV4ID0gMTsKICBmb3IgKGxldCBpID0gMTsgaSA8PSBpbml0TGV2ZWw7IGkrKykgewogICAgZm9yIChsZXQgaiA9IDA7IGogPCBsYXN0TGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykgewogICAgICBjb25zdCBsYXN0Tm9kZSA9IGxhc3RMZXZlbE5vZGVzW2pdOwogICAgICBpZiAobGFzdE5vZGUubm9kZVR5cGUgPT09ICJOVUxMIikgewogICAgICAgIC8vZGVidWdnZXIKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoZGlmSW5kZXggPT09IG1pbnZkLmxlbmd0aCkgewogICAgICAgIGRlYnVnZ2VyOwogICAgICAgIHRocm93IG5ldyBFcnJvcigiZGlmZiBpbmRleCBlcnJvciIpOwogICAgICB9CiAgICAgIGxldCBkaWYgPSBbbWludmRbZGlmSW5kZXhdLCBtYXh2ZFtkaWZJbmRleF0sIGF2ZXZkW2RpZkluZGV4XV07CiAgICAgIGRpZkluZGV4Kys7CiAgICAgIGxldCBjdXJOb2RlVHlwZSA9ICdPJzsKICAgICAgaWYgKGRpZlswXSA9PT0gbnVsbCAmJiBkaWZbMV0gPT09IG51bGwpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImRhdGEgZXJyb3IiKTsKICAgICAgICAvLyBjdXJOb2RlVHlwZSA9ICJOVUxMIjsKICAgICAgfSBlbHNlIGlmIChkaWZbMF0gPT09IG51bGwpIHsKICAgICAgICBjdXJOb2RlVHlwZSA9ICJMRUZUTlVMTCI7CiAgICAgICAgbGFzdE5vZGUuZ2FwRmxhZyA9ICdMJzsKICAgICAgfSBlbHNlIGlmIChkaWZbMV0gPT09IG51bGwpIHsKICAgICAgICBjdXJOb2RlVHlwZSA9ICJSSUdIVE5VTEwiOwogICAgICAgIGxhc3ROb2RlLmdhcEZsYWcgPSAnUic7CiAgICAgIH0KICAgICAgaWYgKGN1ck5vZGVUeXBlICE9PSAiTyIpIHsKICAgICAgICBsYXN0Tm9kZS5ub2RlVHlwZSA9IGN1ck5vZGVUeXBlOwogICAgICB9CiAgICAgIGNvbnN0IHlBcnJheTEgPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdOwogICAgICBjb25zdCB5QXJyYXkyID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTsKICAgICAgaWYgKGN1ck5vZGVUeXBlID09PSAnTycpIHsKICAgICAgICBpZiAoZGlmWzBdIDwgMCkgewogICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gLSBkaWZbMF07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gKyBkaWZbMF07CiAgICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGlmWzFdIDwgMCkgewogICAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSArIGRpZlsxXTsKICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgICB5QXJyYXkyWzJdID0gbGFzdE5vZGUueUFycmF5WzJdIC0gZGlmWzFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGlmWzJdIDw9IDAgfHwgZGlmWzJdID49IDApIHsKICAgICAgICAgIHlBcnJheTFbM10gPSAobGFzdE5vZGUueUFycmF5WzNdICogMiArIGRpZlsyXSkgLyAyOwogICAgICAgICAgeUFycmF5MlszXSA9IChsYXN0Tm9kZS55QXJyYXlbM10gKiAyIC0gZGlmWzJdKSAvIDI7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09ICJMRUZUTlVMTCIpIHsKICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgeUFycmF5MlszXSA9IGxhc3ROb2RlLnlBcnJheVszXSAvIDI7CiAgICAgIH0gZWxzZSBpZiAoY3VyTm9kZVR5cGUgPT0gIlJJR0hUTlVMTCIpIHsKICAgICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgeUFycmF5MVszXSA9IGxhc3ROb2RlLnlBcnJheVszXTsKICAgICAgfSBlbHNlIGlmIChjdXJOb2RlVHlwZSA9PT0gJ05VTEwnKSB7CiAgICAgICAgZGVidWdnZXI7CiAgICAgICAgLy9jb25zb2xlLmxvZygibnVsbCBub2RlIikKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInR5cGUgZXJyb3IiKTsKICAgICAgfQogICAgICAvL0B0cy1pZ25vcmUKICAgICAgY29uc3QgZmlyc3ROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgdHJ1ZSwgbGFzdE5vZGUuaW5kZXgsIHlBcnJheTEsIG51bGwsICJPIik7CiAgICAgIGlmIChjdXJOb2RlVHlwZSA9PT0gIkxFRlROVUxMIikgewogICAgICAgIGZpcnN0Tm9kZS5ub2RlVHlwZSA9ICdOVUxMJzsKICAgICAgfQogICAgICAvL0B0cy1pZ25vcmUKICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIGZhbHNlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MiwgbnVsbCwgIk8iKTsKICAgICAgaWYgKGN1ck5vZGVUeXBlID09PSAiUklHSFROVUxMIikgewogICAgICAgIHNlY29uZE5vZGUubm9kZVR5cGUgPSAnTlVMTCc7CiAgICAgIH0KICAgICAgY3VycmVudExldmVsTm9kZXMucHVzaChmaXJzdE5vZGUpOwogICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKHNlY29uZE5vZGUpOwogICAgICBub2RlTnVtICs9IDI7CiAgICB9CiAgICBsZXZlbEluZGV4W2ldID0gbmV3IExldmVsSW5kZXhPYmooY3VycmVudExldmVsTm9kZXNbMF0ubGV2ZWwsIHRydWUpOwogICAgbGV2ZWxJbmRleFtpXS5hZGRMb2FkZWREYXRhUmFuZ2UoY3VycmVudExldmVsTm9kZXNbMF0sIFtjdXJyZW50TGV2ZWxOb2Rlc1swXS5pbmRleCwgY3VycmVudExldmVsTm9kZXNbY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0uaW5kZXhdKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2ldLm5leHRTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdOwogICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ucHJldmlvdXNTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaV07CiAgICB9CiAgICBsYXN0TGV2ZWxOb2RlcyA9IGN1cnJlbnRMZXZlbE5vZGVzOwogICAgY3VycmVudExldmVsTm9kZXMgPSBbXTsKICB9CiAgaWYgKGRpZkluZGV4ICE9PSBtaW52ZC5sZW5ndGgpIHsKICAgIGRlYnVnZ2VyOwogICAgdGhyb3cgbmV3IEVycm9yKCJkaWZmIG5vdCB1ZXNlZCIpOwogIH0KICAvLyBkZWJ1Z2dlcgogIC8vIGZvciAobGV0IGkgPSAxOyBpIDw9IE1hdGguY2VpbChNYXRoLmxvZzIoZGF0YS5sZW5ndGgpKTsgaSsrKSB7CiAgLy8gICAgIGZvciAobGV0IGogPSAwOyBqIDwgMiAqKiAoaSAtIDEpOyBqKyspIHsKICAvLyAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gbGFzdExldmVsTm9kZXNbal07CiAgLy8gICAgICAgICBsZXQgZGlmID0gbGFzdE5vZGUuZGlmZmVyZW5jZSE7CiAgLy8gICAgICAgICBsZXQgY3VyTm9kZVR5cGU6ICJPIiB8ICJOVUxMIiB8ICJMRUZUTlVMTCIgfCAiUklHSFROVUxMIiA9ICdPJzsKICAvLyAgICAgICAgIGlmIChkaWZbMV0gPT09IG51bGwgJiYgZGlmWzJdID09PSBudWxsKSB7CiAgLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJkYXRhIGVycm9yIikKICAvLyAgICAgICAgICAgICAvLyBjdXJOb2RlVHlwZSA9ICJOVUxMIjsKICAvLyAgICAgICAgIH0gZWxzZSBpZiAoZGlmWzFdID09PSBudWxsKSB7CiAgLy8gICAgICAgICAgICAgY3VyTm9kZVR5cGUgPSAiTEVGVE5VTEwiCiAgLy8gICAgICAgICB9IGVsc2UgaWYgKGRpZlsyXSA9PT0gbnVsbCkgewogIC8vICAgICAgICAgICAgIGRlYnVnZ2VyCiAgLy8gICAgICAgICAgICAgY3VyTm9kZVR5cGUgPSAiUklHSFROVUxMIjsKICAvLyAgICAgICAgIH0KICAvLyAgICAgICAgIGlmIChjdXJOb2RlVHlwZSAhPT0gIk8iKSB7CiAgLy8gICAgICAgICAgICAgbGFzdE5vZGUubm9kZVR5cGUgPSBjdXJOb2RlVHlwZQogIC8vICAgICAgICAgfQogIC8vICAgICAgICAgY29uc3QgeUFycmF5MTogW2FueSwgYW55LCBhbnksIGFueV0gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXQogIC8vICAgICAgICAgY29uc3QgeUFycmF5MjogW2FueSwgYW55LCBhbnksIGFueV0gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXQogIC8vICAgICAgICAgaWYgKGN1ck5vZGVUeXBlID09PSAnTycpIHsKICAvLyAgICAgICAgICAgICBpZiAobGFzdE5vZGUuZGlmZmVyZW5jZSFbMV0gPCAwKSB7CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlIVsxXTsKICAvLyAgICAgICAgICAgICB9IGVsc2UgewogIC8vICAgICAgICAgICAgICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdICsgbGFzdE5vZGUuZGlmZmVyZW5jZSFbMV07CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV07CiAgLy8gICAgICAgICAgICAgfQogIC8vICAgICAgICAgICAgIGlmIChsYXN0Tm9kZS5kaWZmZXJlbmNlIVsyXSA8IDApIHsKICAvLyAgICAgICAgICAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSArIGxhc3ROb2RlLmRpZmZlcmVuY2UhWzJdOwogIC8vICAgICAgICAgICAgICAgICB5QXJyYXkyWzJdID0gbGFzdE5vZGUueUFycmF5WzJdOwogIC8vICAgICAgICAgICAgIH0gZWxzZSB7CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgLy8gICAgICAgICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl0gLSBsYXN0Tm9kZS5kaWZmZXJlbmNlIVsyXTsKICAvLyAgICAgICAgICAgICB9CiAgLy8gICAgICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09ICJMRUZUTlVMTCIpIHsKICAvLyAgICAgICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogIC8vICAgICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgLy8gICAgICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09ICJSSUdIVE5VTEwiKSB7CiAgLy8gICAgICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKICAvLyAgICAgICAgICAgICB5QXJyYXkxWzJdID0gbGFzdE5vZGUueUFycmF5WzJdOwogIC8vICAgICAgICAgfSBlbHNlIGlmIChjdXJOb2RlVHlwZSA9PT0gJ05VTEwnKSB7CiAgLy8gICAgICAgICAgICAgZGVidWdnZXIKICAvLyAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCJudWxsIG5vZGUiKQogIC8vICAgICAgICAgfQogIC8vICAgICAgICAgZWxzZSB7CiAgLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJ0eXBlIGVycm9yIikKICAvLyAgICAgICAgIH0KICAvLyAgICAgICAgIC8vQHRzLWlnbm9yZQogIC8vICAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgdHJ1ZSwgbGFzdE5vZGUuaW5kZXgsIHlBcnJheTEsIGkgPT09IE1hdGgubG9nMihkYXRhLmxlbmd0aCkgPyBudWxsIDogW3VuZGVmaW5lZCwgbWludmRbaiAqIDIgKyAyICoqIGldLCBtYXh2ZFtqICogMiArIDIgKiogaV0sIHVuZGVmaW5lZF0pOwogIC8vICAgICAgICAgaWYgKGxhc3ROb2RlLm5vZGVUeXBlID09PSAiTEVGVE5VTEwiKSB7CiAgLy8gICAgICAgICAgICAgZGVidWdnZXIKICAvLyAgICAgICAgICAgICBmaXJzdE5vZGUubm9kZVR5cGUgPSAnTlVMTCc7CiAgLy8gICAgICAgICB9CiAgLy8gICAgICAgICAvL0B0cy1pZ25vcmUKICAvLyAgICAgICAgIGNvbnN0IHNlY29uZE5vZGUgPSBuZXcgVHJlbmRUcmVlKGxhc3ROb2RlLCBmYWxzZSwgbGFzdE5vZGUuaW5kZXgsIHlBcnJheTIsIGkgPT09IE1hdGgubG9nMihkYXRhLmxlbmd0aCkgPyBudWxsIDogW3VuZGVmaW5lZCwgbWludmRbaiAqIDIgKyAxICsgMiAqKiBpXSwgbWF4dmRbaiAqIDIgKyAxICsgMiAqKiBpXSwgdW5kZWZpbmVkXSk7CiAgLy8gICAgICAgICBpZiAobGFzdE5vZGUubm9kZVR5cGUgPT09ICJSSUdIVE5VTEwiKSB7CiAgLy8gICAgICAgICAgICAgZGVidWdnZXIKICAvLyAgICAgICAgICAgICBzZWNvbmROb2RlLm5vZGVUeXBlID0gJ05VTEwnOwogIC8vICAgICAgICAgfQogIC8vICAgICAgICAgY3VycmVudExldmVsTm9kZXMucHVzaChmaXJzdE5vZGUpOwogIC8vICAgICAgICAgY3VycmVudExldmVsTm9kZXMucHVzaChzZWNvbmROb2RlKTsKICAvLyAgICAgICAgIG5vZGVOdW0gKz0gMgogIC8vICAgICB9CiAgLy8gICAgIGxldmVsSW5kZXhbaV0gPSBuZXcgTGV2ZWxJbmRleE9iaihjdXJyZW50TGV2ZWxOb2Rlc1swXS5sZXZlbCwgdHJ1ZSk7CiAgLy8gICAgIGxldmVsSW5kZXhbaV0uYWRkTG9hZGVkRGF0YVJhbmdlKGN1cnJlbnRMZXZlbE5vZGVzWzBdLCBbMCwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0pOwogIC8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRMZXZlbE5vZGVzLmxlbmd0aCAtIDE7IGkrKykgewogIC8vICAgICAgICAgY3VycmVudExldmVsTm9kZXNbaV0ubmV4dFNpYmxpbmcgPSBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV07CiAgLy8gICAgICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ucHJldmlvdXNTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaV07CiAgLy8gICAgIH0KICAvLyAgICAgbGFzdExldmVsTm9kZXMgPSBjdXJyZW50TGV2ZWxOb2RlczsKICAvLyAgICAgY3VycmVudExldmVsTm9kZXMgPSBbXTsKICAvLyB9CiAgLy9kZWJ1Z2dlcgogIGNvbnN0IGxldmVsRGF0YU1hbmFnZXIgPSBuZXcgTGV2ZWxEYXRhTWFuYWdlcihsZXZlbEluZGV4LCB0YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiBzdG9yZS5zdGF0ZS5jb250cm9sUGFyYW1zLmN1cnJlbnRUYWJsZSk7CiAgcmV0dXJuIHsKICAgIGRhdGFNYW5hZ2VyOiBsZXZlbERhdGFNYW5hZ2VyLAogICAgdHJlbmRUcmVlOiByb290CiAgfTsKfQpmdW5jdGlvbiBjb25zdHJ1Y3RNaW5NYXhNaXNzVHJlbmRUcmVlTXVsdGkoZGF0YSwgd2lkdGgsIHRhYmxlTmFtZSkgewogIGNvbnN0IGluaXRMZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZzIod2lkdGgpKTsKICAvLyBjb25zdCBpbml0TGV2ZWwgPSAyOwogIC8vZGVidWdnZXIKICBjb25zdCBsZXZlbEluZGV4ID0gbmV3IEFycmF5KE1hdGguY2VpbChNYXRoLmxvZzIoZGF0YS5sZW5ndGgpKSArIDEpOwogIGNvbnN0IG1pbnZkID0gW107CiAgY29uc3QgbWF4dmQgPSBbXTsKICBjb25zdCBhdmV2ZCA9IFtdOwogIGRhdGEuZm9yRWFjaCh2ID0+IHsKICAgIG1pbnZkLnB1c2godi5taW52ZCk7CiAgICBtYXh2ZC5wdXNoKHYubWF4dmQpOwogICAgYXZldmQucHVzaCh2LmF2ZXZkKTsKICB9KTsKICBsZXQgdGVtcExhc3QgPSBtaW52ZC5wb3AoKTsKICBtaW52ZC51bnNoaWZ0KHRlbXBMYXN0KTsKICB0ZW1wTGFzdCA9IG1heHZkLnBvcCgpOwogIG1heHZkLnVuc2hpZnQodGVtcExhc3QpOwogIHRlbXBMYXN0ID0gYXZldmQucG9wKCk7CiAgYXZldmQudW5zaGlmdCh0ZW1wTGFzdCk7CiAgbGV0IGxhc3RMZXZlbE5vZGVzID0gbmV3IEFycmF5KCk7CiAgbGV0IGN1cnJlbnRMZXZlbE5vZGVzID0gbmV3IEFycmF5KCk7CiAgbGV0IG5vZGVOdW0gPSAxOwogIC8vQHRzLWlnbm9yZQogIGNvbnN0IHJvb3QgPSBuZXcgVHJlbmRUcmVlKG51bGwsIHRydWUsIDAsIFt1bmRlZmluZWQsIG1pbnZkWzBdLCBtYXh2ZFswXSwgYXZldmRbMF0sIHVuZGVmaW5lZF0sIFt1bmRlZmluZWQsIG1pbnZkWzFdLCBtYXh2ZFsxXSwgYXZldmRbMV0sIHVuZGVmaW5lZF0pOwogIGxhc3RMZXZlbE5vZGVzLnB1c2gocm9vdCk7CiAgbGV2ZWxJbmRleFswXSA9IG5ldyBMZXZlbEluZGV4T2JqKDAsIHRydWUpOwogIGxldmVsSW5kZXhbMF0uYWRkTG9hZGVkRGF0YVJhbmdlKHJvb3QsIFswLCAwXSk7CiAgbGV0IGRpZkluZGV4ID0gMTsKICBmb3IgKGxldCBpID0gMTsgaSA8PSBpbml0TGV2ZWw7IGkrKykgewogICAgZm9yIChsZXQgaiA9IDA7IGogPCBsYXN0TGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykgewogICAgICBjb25zdCBsYXN0Tm9kZSA9IGxhc3RMZXZlbE5vZGVzW2pdOwogICAgICBpZiAobGFzdE5vZGUubm9kZVR5cGUgPT09ICJOVUxMIikgewogICAgICAgIC8vZGVidWdnZXIKICAgICAgICBjb250aW51ZTsKICAgICAgfQogICAgICBpZiAoZGlmSW5kZXggPT09IG1pbnZkLmxlbmd0aCkgewogICAgICAgIGRlYnVnZ2VyOwogICAgICAgIHRocm93IG5ldyBFcnJvcigiZGlmZiBpbmRleCBlcnJvciIpOwogICAgICB9CiAgICAgIGxldCBkaWYgPSBbbWludmRbZGlmSW5kZXhdLCBtYXh2ZFtkaWZJbmRleF0sIGF2ZXZkW2RpZkluZGV4XV07CiAgICAgIGRpZkluZGV4Kys7CiAgICAgIGxldCBjdXJOb2RlVHlwZSA9ICdPJzsKICAgICAgaWYgKGRpZlswXSA9PT0gbnVsbCAmJiBkaWZbMV0gPT09IG51bGwpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImRhdGEgZXJyb3IiKTsKICAgICAgICAvLyBjdXJOb2RlVHlwZSA9ICJOVUxMIjsKICAgICAgfSBlbHNlIGlmIChkaWZbMF0gPT09IG51bGwpIHsKICAgICAgICBjdXJOb2RlVHlwZSA9ICJMRUZUTlVMTCI7CiAgICAgICAgbGFzdE5vZGUuZ2FwRmxhZyA9ICdMJzsKICAgICAgfSBlbHNlIGlmIChkaWZbMV0gPT09IG51bGwpIHsKICAgICAgICBjdXJOb2RlVHlwZSA9ICJSSUdIVE5VTEwiOwogICAgICAgIGxhc3ROb2RlLmdhcEZsYWcgPSAnUic7CiAgICAgIH0KICAgICAgaWYgKGN1ck5vZGVUeXBlICE9PSAiTyIpIHsKICAgICAgICBsYXN0Tm9kZS5ub2RlVHlwZSA9IGN1ck5vZGVUeXBlOwogICAgICB9CiAgICAgIGNvbnN0IHlBcnJheTEgPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdOwogICAgICBjb25zdCB5QXJyYXkyID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTsKICAgICAgaWYgKGN1ck5vZGVUeXBlID09PSAnTycpIHsKICAgICAgICBpZiAoZGlmWzBdIDwgMCkgewogICAgICAgICAgeUFycmF5MVsxXSA9IGxhc3ROb2RlLnlBcnJheVsxXTsKICAgICAgICAgIHlBcnJheTJbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gLSBkaWZbMF07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHlBcnJheTFbMV0gPSBsYXN0Tm9kZS55QXJyYXlbMV0gKyBkaWZbMF07CiAgICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGlmWzFdIDwgMCkgewogICAgICAgICAgeUFycmF5MVsyXSA9IGxhc3ROb2RlLnlBcnJheVsyXSArIGRpZlsxXTsKICAgICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgICB5QXJyYXkyWzJdID0gbGFzdE5vZGUueUFycmF5WzJdIC0gZGlmWzFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGlmWzJdIDw9IDAgfHwgZGlmWzJdID49IDApIHsKICAgICAgICAgIHlBcnJheTFbM10gPSAobGFzdE5vZGUueUFycmF5WzNdICogMiArIGRpZlsyXSkgLyAyOwogICAgICAgICAgeUFycmF5MlszXSA9IChsYXN0Tm9kZS55QXJyYXlbM10gKiAyIC0gZGlmWzJdKSAvIDI7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGN1ck5vZGVUeXBlID09ICJMRUZUTlVMTCIpIHsKICAgICAgICB5QXJyYXkyWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIHlBcnJheTJbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgeUFycmF5MlszXSA9IGxhc3ROb2RlLnlBcnJheVszXSAvIDI7CiAgICAgIH0gZWxzZSBpZiAoY3VyTm9kZVR5cGUgPT0gIlJJR0hUTlVMTCIpIHsKICAgICAgICB5QXJyYXkxWzFdID0gbGFzdE5vZGUueUFycmF5WzFdOwogICAgICAgIHlBcnJheTFbMl0gPSBsYXN0Tm9kZS55QXJyYXlbMl07CiAgICAgICAgeUFycmF5MVszXSA9IGxhc3ROb2RlLnlBcnJheVszXTsKICAgICAgfSBlbHNlIGlmIChjdXJOb2RlVHlwZSA9PT0gJ05VTEwnKSB7CiAgICAgICAgZGVidWdnZXI7CiAgICAgICAgLy9jb25zb2xlLmxvZygibnVsbCBub2RlIikKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoInR5cGUgZXJyb3IiKTsKICAgICAgfQogICAgICAvL0B0cy1pZ25vcmUKICAgICAgY29uc3QgZmlyc3ROb2RlID0gbmV3IFRyZW5kVHJlZShsYXN0Tm9kZSwgdHJ1ZSwgbGFzdE5vZGUuaW5kZXgsIHlBcnJheTEsIG51bGwsICJPIik7CiAgICAgIGlmIChjdXJOb2RlVHlwZSA9PT0gIkxFRlROVUxMIikgewogICAgICAgIGZpcnN0Tm9kZS5ub2RlVHlwZSA9ICdOVUxMJzsKICAgICAgfQogICAgICAvL0B0cy1pZ25vcmUKICAgICAgY29uc3Qgc2Vjb25kTm9kZSA9IG5ldyBUcmVuZFRyZWUobGFzdE5vZGUsIGZhbHNlLCBsYXN0Tm9kZS5pbmRleCwgeUFycmF5MiwgbnVsbCwgIk8iKTsKICAgICAgaWYgKGN1ck5vZGVUeXBlID09PSAiUklHSFROVUxMIikgewogICAgICAgIHNlY29uZE5vZGUubm9kZVR5cGUgPSAnTlVMTCc7CiAgICAgIH0KICAgICAgY3VycmVudExldmVsTm9kZXMucHVzaChmaXJzdE5vZGUpOwogICAgICBjdXJyZW50TGV2ZWxOb2Rlcy5wdXNoKHNlY29uZE5vZGUpOwogICAgICBub2RlTnVtICs9IDI7CiAgICB9CiAgICBsZXZlbEluZGV4W2ldID0gbmV3IExldmVsSW5kZXhPYmooY3VycmVudExldmVsTm9kZXNbMF0ubGV2ZWwsIHRydWUpOwogICAgbGV2ZWxJbmRleFtpXS5hZGRMb2FkZWREYXRhUmFuZ2UoY3VycmVudExldmVsTm9kZXNbMF0sIFtjdXJyZW50TGV2ZWxOb2Rlc1swXS5pbmRleCwgY3VycmVudExldmVsTm9kZXNbY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMV0uaW5kZXhdKTsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExldmVsTm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgIGN1cnJlbnRMZXZlbE5vZGVzW2ldLm5leHRTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaSArIDFdOwogICAgICBjdXJyZW50TGV2ZWxOb2Rlc1tpICsgMV0ucHJldmlvdXNTaWJsaW5nID0gY3VycmVudExldmVsTm9kZXNbaV07CiAgICB9CiAgICBsYXN0TGV2ZWxOb2RlcyA9IGN1cnJlbnRMZXZlbE5vZGVzOwogICAgY3VycmVudExldmVsTm9kZXMgPSBbXTsKICB9CiAgaWYgKGRpZkluZGV4ICE9PSBtaW52ZC5sZW5ndGgpIHsKICAgIGRlYnVnZ2VyOwogICAgdGhyb3cgbmV3IEVycm9yKCJkaWZmIG5vdCB1ZXNlZCIpOwogIH0KICBjb25zdCBsZXZlbERhdGFNYW5hZ2VyID0gbmV3IExldmVsRGF0YU1hbmFnZXIobGV2ZWxJbmRleCwgdGFibGVOYW1lID8gdGFibGVOYW1lIDogc3RvcmUuc3RhdGUuY29udHJvbFBhcmFtcy5jdXJyZW50VGFibGUpOwogIHJldHVybiB7CiAgICBkYXRhTWFuYWdlcjogbGV2ZWxEYXRhTWFuYWdlciwKICAgIHRyZW5kVHJlZTogcm9vdAogIH07Cn0KLy8gZXhwb3J0IHsgY29uc3RydWN0UmF3TWluTWF4VHJlbmRUcmVlLCBjb25zdHJ1Y3RNaW5NYXhNaXNzVHJlbmRUcmVlLCBjb25zdHJ1Y3RNaXNzVHJlbmRUcmVlLCBpbml0V2F2ZWxldERlY29kZSwgd2F2ZWxldERlY29kZSwgY29uc3RydWN0VHJlbmRUcmVlLCBjb25zdHJ1Y3RIYWFyVHJlZSwgY29uc3RydWN0TWluTWF4VHJlbmRUcmVlIH0KZXhwb3J0IHsgY29uc3RydWN0TWluTWF4TWlzc1RyZW5kVHJlZSwgaW5pdFdhdmVsZXREZWNvZGUsIHdhdmVsZXREZWNvZGUsIGNvbnN0cnVjdFRyZW5kVHJlZSwgY29uc3RydWN0SGFhclRyZWUsIGNvbnN0cnVjdE1pbk1heE1pc3NUcmVuZFRyZWVNdWx0aSwgY29uc3RydWN0TWluTWF4TWlzc1RyZW5kVHJlZUZvckdldENoaWxkVHJlZSB9Ow=="},{"version":3,"names":["HaarDataManager","HaarIndexObj","LevelDataManager","LevelIndexObj","store","HaarTree","TrendTree","initWaveletDecode","diffData","minT","mintd","minV","minvd","maxV","maxvd","maxT","maxtd","i","Math","log2","length","tempMaxV","tempMaxT","tempMinV","tempMinT","j","push","slice","m4Data","mint","minv","maxv","maxt","initHaarDecode","dif","a","b","waveletDecode","histroryData","range","historyMinT","historyMinV","historyMaxV","historyMaxT","difMinT","difMinV","difMaxV","difMaxT","nowMinT","nowMinV","nowMaxV","nowMaxT","constructHaarTree","data","tableName","levelIndex","Array","forEach","v","tempLast","pop","unshift","lastLevelNodes","currentLevelNodes","root","addLoadedDataRange","lastNode","value","difference","firstNode","index","undefined","secondNode","level","nextSibling","previousSibling","dataManager","state","controlParams","currentTable","trendTree","constructTrendTree","avevd","minid","maxid","nodeNum","yArray1","yArray2","yArray","levelDataManager","constructMinMaxMissTrendTree","width","initLevel","ceil","difIndex","nodeType","Error","curNodeType","gapFlag","constructMinMaxMissTrendTreeForGetChildTree","constructMinMaxMissTrendTreeMulti"],"sources":["/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/node_modules/eslint-loader/index.js??ref--14-0!/Users/huangshuo/Desktop/cxsj/om3-extend/om3-client/src/helper/wavlet-decoder.ts"],"sourcesContent":["import HaarDataManager from \"@/model/haar-data-manager\";\nimport HaarIndexObj from \"@/model/haar-index-obj\";\nimport LevelDataManager from \"@/model/level-data-manager\";\nimport LevelIndexObj from \"@/model/level-index-obj\";\nimport store from \"@/store\";\nimport HaarTree from \"./haar-tree\";\nimport TrendTree from \"./tend-query-tree\";\n\nfunction initWaveletDecode(diffData: { mintd: Array<any>, minvd: Array<any>, maxvd: Array<any>, maxtd: Array<any> }) {\n    let minT = diffData.mintd;\n    let minV = diffData.minvd;\n    let maxV = diffData.maxvd;\n    let maxT = diffData.maxtd;\n\n    for (let i = 0; i < Math.log2(maxV.length); i++) {\n        const tempMaxV = [];\n        const tempMaxT = [];\n        const tempMinV = [];\n        const tempMinT = [];\n        for (let j = 0; j < 2 ** i; j++) {\n            if (maxV[j + 2 ** i] >= 0) {\n                tempMaxV.push(maxV[j]);\n                tempMaxV.push(maxV[j] - maxV[j + 2 ** i]);\n            } else {\n                tempMaxV.push(maxV[j] + maxV[j + 2 ** i]);\n                tempMaxV.push(maxV[j]);\n            }\n            if (minV[j + 2 ** i] >= 0) {\n                tempMinV.push(minV[j] + minV[j + 2 ** i]);\n                tempMinV.push(minV[j]);\n            } else {\n                tempMinV.push(minV[j]);\n                tempMinV.push(minV[j] - minV[j + 2 ** i]);\n            }\n            tempMinT.push(minT[j]);\n            tempMinT.push(minT[j] - minT[j + 2 ** i]);\n            tempMaxT.push(maxT[j] + maxT[j + 2 ** i]);\n            tempMaxT.push(maxT[j]);\n        }\n        maxV = [...tempMaxV, ...maxV.slice(2 ** (i + 1))];\n        maxT = [...tempMaxT, ...maxT.slice(2 ** (i + 1))];\n        minV = [...tempMinV, ...minV.slice(2 ** (i + 1))];\n        minT = [...tempMinT, ...minT.slice(2 ** (i + 1))];\n    }\n    const m4Data = {\n        mint: minT,\n        minv: minV,\n        maxv: maxV,\n        maxt: maxT\n    }\n    return m4Data;\n}\n\nexport function initHaarDecode(dif: Array<number>) {\n    let minT = dif\n    for (let i = 0; i < Math.log2(minT.length); i++) {\n        const tempMinT = [];\n        for (let j = 0; j < 2 ** i; j++) {\n            const a = (2 * minT[j] + minT[j + 2 ** i]) / 2;\n            tempMinT.push(a);\n            const b = (2 * minT[j] - minT[j + 2 ** i]) / 2;\n            tempMinT.push(b);\n        }\n        minT = [...tempMinT, ...minT.slice(2 ** (i + 1))];\n    }\n    return minT;\n}\n\nfunction waveletDecode(histroryData: Array<any>, diffData: { mintd: Array<any>, minvd: Array<any>, maxvd: Array<any>, maxtd: Array<any> }, range: [number, number]) {\n    const historyMinT = histroryData[1].slice(range[0], range[1]);\n    const historyMinV = histroryData[2].slice(range[0], range[1]);\n    const historyMaxV = histroryData[3].slice(range[0], range[1]);\n    const historyMaxT = histroryData[4].slice(range[0], range[1]);\n    const difMinT = diffData.mintd;\n    const difMinV = diffData.minvd;\n    const difMaxV = diffData.maxvd;\n    const difMaxT = diffData.maxtd;\n    const nowMinT = [];\n    const nowMinV = [];\n    const nowMaxV = [];\n    const nowMaxT = [];\n    for (let i = 0; i < historyMinT.length; i++) {\n        nowMinT.push(historyMinT[i], historyMinT[i] - difMinT[i]);\n        if (difMinV[i] < 0) {\n            nowMinV.push(historyMinV[i], historyMinV[i] - difMinV[i])\n        } else {\n            nowMinV.push(historyMinV[i] + difMinV[i], historyMinV[i]);\n        }\n        if (difMaxV[i] < 0) {\n            nowMaxV.push(historyMaxV[i] + difMaxV[i], historyMaxV[i]);\n        } else {\n            nowMaxV.push(historyMaxV[i], historyMaxV[i] - difMaxV[i]);\n        }\n        nowMaxT.push(historyMaxT[i] + difMaxT[i], historyMaxT[i]);\n    }\n    return {\n        mint: nowMinT,\n        minv: nowMinV,\n        maxv: nowMaxV,\n        maxt: nowMaxT,\n    }\n\n}\n\nfunction constructHaarTree(data: Array<any>, tableName?: string) {\n    const levelIndex = new Array<HaarIndexObj>(Math.log2(data.length));\n    //const dataManager=new LevelDataManager()\n    const mintd: Array<number> = [];\n    data.forEach(v => {\n        mintd.push(v.dif);\n    });\n\n    let tempLast = mintd.pop();\n    mintd.unshift(tempLast!);\n\n    let lastLevelNodes = new Array<HaarTree>();\n    let currentLevelNodes = new Array<HaarTree>();\n    const root = new HaarTree(null, true, 0, mintd[0], mintd[1]);\n    lastLevelNodes.push(root);\n    levelIndex[0] = new HaarIndexObj(0, true);\n    levelIndex[0].addLoadedDataRange(root, [0, 0]);\n    for (let i = 1; i <= Math.log2(data.length); i++) {\n        for (let j = 0; j < 2 ** (i - 1); j++) {\n\n            const lastNode = lastLevelNodes[j];\n            const a = (2 * lastNode.value + lastNode.difference!) / 2\n            const b = (2 * lastNode.value - lastNode.difference!) / 2;\n            const firstNode = new HaarTree(lastNode, true, lastNode.index, a, i === Math.log2(data.length) ? undefined : mintd[j * 2 + 2 ** i]);\n            const secondNode = new HaarTree(lastNode, false, lastNode.index, b, i === Math.log2(data.length) ? undefined : mintd[j * 2 + 1 + 2 ** i]);\n            currentLevelNodes.push(firstNode);\n            currentLevelNodes.push(secondNode);\n        }\n        levelIndex[i] = new HaarIndexObj(currentLevelNodes[0].level, true);\n        levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n        for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n            currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n            currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n        }\n        lastLevelNodes = currentLevelNodes;\n        currentLevelNodes = [];\n    }\n    return {\n        dataManager: new HaarDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable),\n        trendTree: root\n    }\n}\n\nfunction constructTrendTree(data: Array<any>, tableName?: string) {\n    const levelIndex = new Array<LevelIndexObj>(Math.log2(data.length));\n    //const dataManager=new LevelDataManager()\n    const mintd: Array<number> = [];\n    const minvd: Array<number> = [];\n    const maxvd: Array<number> = [];\n    const maxtd: Array<number> = [];\n    const avevd: Array<number> = [];\n    data.forEach(v => {\n        mintd.push(v.minid);\n        minvd.push(v.minvd);\n        maxvd.push(v.maxvd);\n        maxtd.push(v.maxid);\n        avevd.push(v.avevd);\n    });\n\n    let tempLast = mintd.pop();\n    mintd.unshift(tempLast!);\n    tempLast = minvd.pop();\n    minvd.unshift(tempLast!);\n    tempLast = maxvd.pop();\n    maxvd.unshift(tempLast!);\n    tempLast = maxtd.pop();\n    maxtd.unshift(tempLast!);\n    tempLast = avevd.pop();\n    avevd.unshift(tempLast!);\n    let lastLevelNodes = new Array<TrendTree>();\n    let currentLevelNodes = new Array<TrendTree>();\n    let nodeNum = 1\n    const root = new TrendTree(null, true, 0, [mintd[0], minvd[0], maxvd[0], avevd[0], maxtd[0]], [mintd[1], minvd[1], maxvd[1], avevd[1], maxtd[1]]);\n    lastLevelNodes.push(root);\n    levelIndex[0] = new LevelIndexObj(0, true);\n    levelIndex[0].addLoadedDataRange(root, [0, 0]);\n    for (let i = 1; i <= Math.log2(data.length); i++) {\n        for (let j = 0; j < 2 ** (i - 1); j++) {\n\n            const lastNode = lastLevelNodes[j];\n            //@ts-ignore\n            // const yArray1: [number, number, number, number] = new Array(4);\n            //@ts-ignore\n            // const yArray2: [number, number, number, number] = new Array(4);\n            //@ts-ignore\n            const yArray1: [number, number, number, number, number] = new Array(5);\n            //@ts-ignore\n            const yArray2: [number, number, number, number, number] = new Array(5);\n            // yArray1[0] = lastNode.yArray[0];\n            // yArray2[0] = lastNode.yArray[0] - lastNode.difference![0];\n            // if (lastNode.difference![1] >= 0) {\n            //     yArray1[1] = lastNode.yArray[1] + lastNode.difference![1];\n            //     yArray2[1] = lastNode.yArray[1];\n            // } else {\n            //     yArray1[1] = lastNode.yArray[1];\n            //     yArray2[1] = lastNode.yArray[1] - lastNode.difference![1];\n            // }\n            // if (lastNode.difference![2] >= 0) {\n            //     yArray1[2] = lastNode.yArray[2];\n            //     yArray2[2] = lastNode.yArray[2] - lastNode.difference![2];\n            // } else {\n            //     yArray1[2] = lastNode.yArray[2] + lastNode.difference![2];\n            //     yArray2[2] = lastNode.yArray[2];\n            // }\n            // yArray1[3] = lastNode.yArray[3] + lastNode.difference![3];\n            // yArray2[3] = lastNode.yArray[3];\n            // //@ts-ignore\n            // const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, i === Math.log2(data.length) ? null : [mintd[j * 2 + 2 ** i], minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], maxtd[j * 2 + 2 ** i]]);\n            // //@ts-ignore\n            // const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, i === Math.log2(data.length) ? null : [mintd[j * 2 + 1 + 2 ** i], minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], maxtd[j * 2 + 1 + 2 ** i]]);\n            yArray1[0] = lastNode.yArray[0];\n            yArray2[0] = lastNode.yArray[0] - lastNode.difference![0];\n            if (lastNode.difference![1] >= 0) {\n                yArray1[1] = lastNode.yArray[1] + lastNode.difference![1];\n                yArray2[1] = lastNode.yArray[1];\n            } else {\n                yArray1[1] = lastNode.yArray[1];\n                yArray2[1] = lastNode.yArray[1] - lastNode.difference![1];\n            }\n            if (lastNode.difference![2] >= 0) {\n                yArray1[2] = lastNode.yArray[2];\n                yArray2[2] = lastNode.yArray[2] - lastNode.difference![2];\n            } else {\n                yArray1[2] = lastNode.yArray[2] + lastNode.difference![2];\n                yArray2[2] = lastNode.yArray[2];\n            }\n            if(lastNode.difference![3] >= 0 || lastNode.difference![3] <= 0){\n                yArray1[3] = (lastNode.yArray[3] * 2 + lastNode.difference![2]) / 2;\n                yArray2[3] = (lastNode.yArray[3] * 2 - lastNode.difference![2]) / 2;\n            }\n            yArray1[4] = lastNode.yArray[4] + lastNode.difference![4];\n            yArray2[4] = lastNode.yArray[4];\n            //@ts-ignore\n            const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, i === Math.log2(data.length) ? null : [mintd[j * 2 + 2 ** i], minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], avevd[j * 2 + 2 ** i], maxtd[j * 2 + 2 ** i]]);\n            //@ts-ignore\n            const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, i === Math.log2(data.length) ? null : [mintd[j * 2 + 1 + 2 ** i], minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], avevd[j * 2 + 1 + 2 ** i], maxtd[j * 2 + 1 + 2 ** i]]);\n            // if (j === 0) {\n            //     levelIndex[i]=new LevelIndexObj(firstNode.level,true);\n            //     levelIndex[i].addLoadedDataRange(firstNode,[0,])\n            // }\n            currentLevelNodes.push(firstNode);\n            currentLevelNodes.push(secondNode);\n            nodeNum += 2\n        }\n        levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n        levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n        for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n            currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n            currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n            // const k1 = currentLevelNodes[i + 1].yArray[2] - currentLevelNodes[i].yArray[1];\n            // const k2 = currentLevelNodes[i + 1].yArray[1] - currentLevelNodes[i].yArray[2];\n            // currentLevelNodes[i].trendRange = k1 < k2 ? [currentLevelNodes[i + 1].yArray[2], currentLevelNodes[i].yArray[1], currentLevelNodes[i + 1].yArray[1], currentLevelNodes[i].yArray[2]] : [currentLevelNodes[i + 1].yArray[1], currentLevelNodes[i].yArray[2], currentLevelNodes[i + 1].yArray[2], currentLevelNodes[i].yArray[1]];\n        }\n        lastLevelNodes = currentLevelNodes;\n        currentLevelNodes = [];\n    }\n    const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n    // levelDataManager.addNodeNum(nodeNum)\n    // console.log(levelDataManager.curNodeNum,levelDataManager.cacheMap.size)\n    return {\n        dataManager: levelDataManager,\n        trendTree: root\n    }\n}\n\n// function constructRawMinMaxTrendTree(data: Array<any>, tableName?: string) {\n//     const levelIndex = new Array<LevelIndexObj>(Math.ceil(Math.log2(data.length)));\n//     //const dataManager=new LevelDataManager()\n//     const mintd: Array<number> = [];\n//     const minvd: Array<number> = [];\n//     const maxvd: Array<number> = [];\n//     const maxtd: Array<number> = [];\n//     data.forEach(v => {\n//         mintd.push(v.mint);\n//         minvd.push(v.minv);\n//         maxvd.push(v.maxv);\n//         maxtd.push(v.maxt);\n//     });\n\n//     let tempLast = mintd.pop();\n//     mintd.unshift(tempLast!);\n//     tempLast = minvd.pop();\n//     minvd.unshift(tempLast!);\n//     tempLast = maxvd.pop();\n//     maxvd.unshift(tempLast!);\n//     tempLast = maxtd.pop();\n//     maxtd.unshift(tempLast!);\n//     let lastLevelNodes = new Array<TrendTree>();\n//     let currentLevelNodes = new Array<TrendTree>();\n//     let nodeNum = 1\n//     const root = new TrendTree(null, true, 0, [mintd[0], minvd[0], maxvd[0], maxtd[0]], [0, 0, 0, 0]);\n//     lastLevelNodes.push(root);\n//     levelIndex[0] = new LevelIndexObj(0, true);\n//     levelIndex[0].addLoadedDataRange(root, [0, 0]);\n//     for (let i = 1; i <= Math.log2(data.length); i++) {\n//         for (let j = 0; j < 2 ** (i - 1); j++) {\n\n//             const lastNode = lastLevelNodes[j];\n\n//             //@ts-ignore\n//             const firstNode = new TrendTree(lastNode, true, lastNode.index, [mintd[j * 2 + 2 ** i], minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], maxtd[j * 2 + 2 ** i]], [0, 0, 0, 0]);\n//             //@ts-ignore\n//             const secondNode = new TrendTree(lastNode, false, lastNode.index, [mintd[j * 2 + 1 + 2 ** i], minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], maxtd[j * 2 + 1 + 2 ** i]], [0, 0, 0, 0]);\n\n//             currentLevelNodes.push(firstNode);\n//             currentLevelNodes.push(secondNode);\n//             nodeNum += 2\n//         }\n//         levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n//         levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n//         for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n//             currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n//             currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n\n//         }\n//         lastLevelNodes = currentLevelNodes;\n//         currentLevelNodes = [];\n//     }\n//     const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n\n//     return {\n//         dataManager: levelDataManager,\n//         trendTree: root\n//     }\n// }\n// function constructMinMaxTrendTree(data: Array<any>, tableName?: string) {\n//     console.log(data.length);\n//     const levelIndex = new Array<LevelIndexObj>(Math.ceil(Math.log2(data.length)));\n//     //const dataManager=new LevelDataManager()\n\n//     const minvd: Array<number> = [];\n//     const maxvd: Array<number> = [];\n\n//     data.forEach(v => {\n\n//         minvd.push(v.minvd);\n//         maxvd.push(v.maxvd);\n//     });\n\n\n//     let tempLast = minvd.pop();\n//     minvd.unshift(tempLast!);\n//     tempLast = maxvd.pop();\n//     maxvd.unshift(tempLast!);\n//     let lastLevelNodes = new Array<TrendTree>();\n//     let currentLevelNodes = new Array<TrendTree>();\n//     let nodeNum = 1\n//     const root = new TrendTree(null, true, 0, [0, minvd[0], maxvd[0], 0], [0, minvd[1], maxvd[1], 0]);\n//     lastLevelNodes.push(root);\n//     levelIndex[0] = new LevelIndexObj(0, true);\n//     levelIndex[0].addLoadedDataRange(root, [0, 0]);\n//     for (let i = 1; i <= Math.log2(data.length); i++) {\n//         for (let j = 0; j < 2 ** (i - 1); j++) {\n\n//             const lastNode = lastLevelNodes[j];\n//             //@ts-ignore\n//             const yArray1: [number, number, number, number] = new Array(4);\n//             //@ts-ignore\n//             const yArray2: [number, number, number, number] = new Array(4);\n//             yArray1[0] = lastNode.yArray[0];\n//             yArray2[0] = lastNode.yArray[0] - lastNode.difference![0];\n//             if (lastNode.difference![1] >= 0) {\n//                 yArray1[1] = lastNode.yArray[1] + lastNode.difference![1];\n//                 yArray2[1] = lastNode.yArray[1];\n//             } else {\n//                 yArray1[1] = lastNode.yArray[1];\n//                 yArray2[1] = lastNode.yArray[1] - lastNode.difference![1];\n//             }\n//             if (lastNode.difference![2] >= 0) {\n//                 yArray1[2] = lastNode.yArray[2];\n//                 yArray2[2] = lastNode.yArray[2] - lastNode.difference![2];\n//             } else {\n//                 yArray1[2] = lastNode.yArray[2] + lastNode.difference![2];\n//                 yArray2[2] = lastNode.yArray[2];\n//             }\n//             yArray1[3] = lastNode.yArray[3] + lastNode.difference![3];\n//             yArray2[3] = lastNode.yArray[3];\n//             //@ts-ignore\n//             const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, i === Math.log2(data.length) ? null : [0, minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], 0]);\n//             //@ts-ignore\n//             const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, i === Math.log2(data.length) ? null : [0, minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], 0]);\n//             // if (j === 0) {\n//             //     levelIndex[i]=new LevelIndexObj(firstNode.level,true);\n//             //     levelIndex[i].addLoadedDataRange(firstNode,[0,])\n//             // }\n//             currentLevelNodes.push(firstNode);\n//             currentLevelNodes.push(secondNode);\n//             nodeNum += 2\n//         }\n//         levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n//         levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n//         for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n//             currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n//             currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n//             // const k1 = currentLevelNodes[i + 1].yArray[2] - currentLevelNodes[i].yArray[1];\n//             // const k2 = currentLevelNodes[i + 1].yArray[1] - currentLevelNodes[i].yArray[2];\n//             // currentLevelNodes[i].trendRange = k1 < k2 ? [currentLevelNodes[i + 1].yArray[2], currentLevelNodes[i].yArray[1], currentLevelNodes[i + 1].yArray[1], currentLevelNodes[i].yArray[2]] : [currentLevelNodes[i + 1].yArray[1], currentLevelNodes[i].yArray[2], currentLevelNodes[i + 1].yArray[2], currentLevelNodes[i].yArray[1]];\n//         }\n//         lastLevelNodes = currentLevelNodes;\n//         currentLevelNodes = [];\n//     }\n//     const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n//     // levelDataManager.addNodeNum(nodeNum)\n//     // console.log(levelDataManager.curNodeNum,levelDataManager.cacheMap.size)\n//     return {\n//         dataManager: levelDataManager,\n//         trendTree: root\n//     }\n// }\n\n// function constructMissTrendTree(data: Array<any>, tableName?: string) {\n//     const levelIndex = new Array<LevelIndexObj>(Math.ceil(Math.log2(data.length)));\n//     //const dataManager=new LevelDataManager()\n//     const mintd: Array<number> = [];\n//     const minvd: Array<number> = [];\n//     const maxvd: Array<number> = [];\n//     const maxtd: Array<number> = [];\n//     data.forEach(v => {\n//         mintd.push(v.minid);\n//         minvd.push(v.minvd);\n//         maxvd.push(v.maxvd);\n//         maxtd.push(v.maxid);\n//     });\n\n//     let tempLast = mintd.pop();\n//     mintd.unshift(tempLast!);\n//     tempLast = minvd.pop();\n//     minvd.unshift(tempLast!);\n//     tempLast = maxvd.pop();\n//     maxvd.unshift(tempLast!);\n//     tempLast = maxtd.pop();\n//     maxtd.unshift(tempLast!);\n//     let lastLevelNodes = new Array<TrendTree>();\n//     let currentLevelNodes = new Array<TrendTree>();\n//     let nodeNum = 1\n//     const root = new TrendTree(null, true, 0, [mintd[0], minvd[0], maxvd[0], maxtd[0]], [mintd[1], minvd[1], maxvd[1], maxtd[1]]);\n//     lastLevelNodes.push(root);\n//     levelIndex[0] = new LevelIndexObj(0, true);\n//     levelIndex[0].addLoadedDataRange(root, [0, 0]);\n//     for (let i = 1; i <= Math.log2(data.length); i++) {\n//         for (let j = 0; j < 2 ** (i - 1); j++) {\n\n//             const lastNode = lastLevelNodes[j];\n//             let dif = lastNode.difference!;\n//             let curNodeType: \"O\" | \"NULL\" | \"LEFTNULL\" | \"RIGHTNULL\" = 'O';\n//             if (dif[1] === null && dif[2] === null) {\n//                 curNodeType = \"NULL\";\n//             } else if (dif[0] === null && dif[1] === null) {\n//                 curNodeType = \"LEFTNULL\"\n//             } else if (dif[2] === null && dif[3] === null) {\n//                 curNodeType = \"RIGHTNULL\";\n//             }\n//             lastNode.nodeType = curNodeType;\n//             const yArray1: [any, any, any, any] = [undefined, undefined, undefined, undefined]\n//             const yArray2: [any, any, any, any] = [undefined, undefined, undefined, undefined]\n//             if (curNodeType === 'O') {\n//                 yArray1[0] = lastNode.yArray[0];\n//                 yArray2[0] = lastNode.yArray[0] - lastNode.difference![0];\n//                 yArray1[3] = lastNode.yArray[3] + lastNode.difference![3];\n//                 yArray2[3] = lastNode.yArray[3];\n//                 if (lastNode.difference![1] < 0) {\n//                     yArray1[1] = lastNode.yArray[1];\n//                     yArray2[1] = lastNode.yArray[1] - lastNode.difference![1];\n//                 } else {\n//                     yArray1[1] = lastNode.yArray[1] + lastNode.difference![1];\n//                     yArray2[1] = lastNode.yArray[1]\n//                 }\n//                 if (lastNode.difference![2] < 0) {\n//                     yArray1[2] = lastNode.yArray[2] + lastNode.difference![2];\n//                     yArray2[2] = lastNode.yArray[2];\n//                 } else {\n//                     yArray1[2] = lastNode.yArray[2];\n//                     yArray2[2] = lastNode.yArray[2] - lastNode.difference![2];\n//                 }\n//             } else if (curNodeType == \"LEFTNULL\") {\n//                 yArray2[0] = lastNode.yArray[0]\n//                 yArray2[1] = lastNode.yArray[1];\n//                 yArray2[2] = lastNode.yArray[2];\n//                 yArray2[3] = lastNode.yArray[3];\n//             } else if (curNodeType == \"RIGHTNULL\") {\n//                 yArray1[0] = lastNode.yArray[0]\n//                 yArray1[1] = lastNode.yArray[1];\n//                 yArray1[2] = lastNode.yArray[2];\n//                 yArray1[3] = lastNode.yArray[3];\n//             } else if (curNodeType === 'NULL') {\n//                 //console.log(\"null node\")\n//             }\n//             else {\n//                 throw new Error(\"type error\")\n\n//             }\n\n//             const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, i === Math.log2(data.length) ? null : [mintd[j * 2 + 2 ** i], minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], maxtd[j * 2 + 2 ** i]]);\n//             if (lastNode.nodeType === 'LEFTNULL' || lastNode.nodeType === 'NULL') {\n//                 firstNode.nodeType = 'NULL';\n//             }\n//             //@ts-ignore\n//             const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, i === Math.log2(data.length) ? null : [mintd[j * 2 + 1 + 2 ** i], minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], maxtd[j * 2 + 1 + 2 ** i]]);\n//             if (lastNode.nodeType === 'RIGHTNULL' || lastNode.nodeType == 'NULL') {\n//                 secondNode.nodeType = 'NULL';\n//             }\n//             // if (j === 0) {\n//             //     levelIndex[i]=new LevelIndexObj(firstNode.level,true);\n//             //     levelIndex[i].addLoadedDataRange(firstNode,[0,])\n//             // }\n//             currentLevelNodes.push(firstNode);\n//             currentLevelNodes.push(secondNode);\n//             nodeNum += 2\n//         }\n//         levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n//         levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n//         for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n//             currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n//             currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n//             // const k1 = currentLevelNodes[i + 1].yArray[2] - currentLevelNodes[i].yArray[1];\n//             // const k2 = currentLevelNodes[i + 1].yArray[1] - currentLevelNodes[i].yArray[2];\n//             // currentLevelNodes[i].trendRange = k1 < k2 ? [currentLevelNodes[i + 1].yArray[2], currentLevelNodes[i].yArray[1], currentLevelNodes[i + 1].yArray[1], currentLevelNodes[i].yArray[2]] : [currentLevelNodes[i + 1].yArray[1], currentLevelNodes[i].yArray[2], currentLevelNodes[i + 1].yArray[2], currentLevelNodes[i].yArray[1]];\n//         }\n//         lastLevelNodes = currentLevelNodes;\n//         currentLevelNodes = [];\n//     }\n//     const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n//     // levelDataManager.addNodeNum(nodeNum)\n//     // console.log(levelDataManager.curNodeNum,levelDataManager.cacheMap.size)\n//     return {\n//         dataManager: levelDataManager,\n//         trendTree: root\n//     }\n// }\n\nfunction constructMinMaxMissTrendTree(data: Array<any>, width: number, tableName?: string) {\n    const initLevel = Math.ceil(Math.log2(data.length));\n    // const initLevel = Math.ceil(Math.log2(width));\n    // const initLevel = 2;\n    //debugger\n    const levelIndex = new Array<LevelIndexObj>(Math.ceil(Math.log2(data.length)) + 1);\n\n    const minvd: Array<number> = [];\n    const maxvd: Array<number> = [];\n    const avevd: Array<number> = [];\n\n    data.forEach(v => {\n        minvd.push(v.minvd);\n        maxvd.push(v.maxvd);\n        avevd.push(v.avevd);\n    });\n\n    let tempLast = minvd.pop();\n    minvd.unshift(tempLast!);\n    tempLast = maxvd.pop();\n    maxvd.unshift(tempLast!);\n    tempLast = avevd.pop();\n    avevd.unshift(tempLast!);\n\n    let lastLevelNodes = new Array<TrendTree>();\n    let currentLevelNodes = new Array<TrendTree>();\n    let nodeNum = 1;\n    //@ts-ignore\n    const root = new TrendTree(null, true, 0, [undefined, minvd[0], maxvd[0], avevd[0], undefined], [undefined, minvd[1], maxvd[1], avevd[1], undefined]);\n    lastLevelNodes.push(root);\n    levelIndex[0] = new LevelIndexObj(0, true);\n    levelIndex[0].addLoadedDataRange(root, [0, 0]);\n\n    let difIndex = 1;\n    for (let i = 1; i <= initLevel; i++) {\n        for (let j = 0; j < lastLevelNodes.length; j++) {\n            const lastNode = lastLevelNodes[j];\n            if (lastNode.nodeType === \"NULL\") {\n                //debugger\n                continue\n            }\n            if(difIndex===minvd.length){\n                debugger\n                throw new Error(\"diff index error\")\n            }\n            let dif = [minvd[difIndex], maxvd[difIndex], avevd[difIndex]];\n            difIndex++;\n            let curNodeType: \"O\" | \"NULL\" | \"LEFTNULL\" | \"RIGHTNULL\" = 'O';\n            if (dif[0] === null && dif[1] === null) {\n                throw new Error(\"data error\")\n                // curNodeType = \"NULL\";\n            } else if (dif[0] === null) {\n                curNodeType = \"LEFTNULL\"\n                lastNode.gapFlag='L'\n            } else if (dif[1] === null) {\n                \n                curNodeType = \"RIGHTNULL\";\n                lastNode.gapFlag='R'\n            }\n            if (curNodeType !== \"O\") {\n                lastNode.nodeType = curNodeType\n            }\n            const yArray1: [any, any, any, any, any] = [undefined, undefined, undefined, undefined, undefined]\n            const yArray2: [any, any, any, any, any] = [undefined, undefined, undefined, undefined, undefined]\n            if (curNodeType === 'O') {\n                if (dif[0] < 0) {\n                    yArray1[1] = lastNode.yArray[1];\n                    yArray2[1] = lastNode.yArray[1] - dif[0];\n                } else {\n                    yArray1[1] = lastNode.yArray[1] + dif[0];\n                    yArray2[1] = lastNode.yArray[1];\n                }\n                if (dif[1] < 0) {\n                    yArray1[2] = lastNode.yArray[2] + dif[1];\n                    yArray2[2] = lastNode.yArray[2];\n                } else {\n                    yArray1[2] = lastNode.yArray[2];\n                    yArray2[2] = lastNode.yArray[2] - dif[1];\n                }\n                if(dif[2] <= 0 || dif[2] >= 0){\n                    yArray1[3] = (lastNode.yArray[3] * 2 + dif[2]) / 2;\n                    yArray2[3] = (lastNode.yArray[3] * 2 - dif[2]) / 2;\n                }\n            } else if (curNodeType == \"LEFTNULL\") {\n                yArray2[1] = lastNode.yArray[1];\n                yArray2[2] = lastNode.yArray[2];\n                yArray2[3] = lastNode.yArray[3] / 2;\n            } else if (curNodeType == \"RIGHTNULL\") {\n                yArray1[1] = lastNode.yArray[1];\n                yArray1[2] = lastNode.yArray[2];\n                yArray1[3] = lastNode.yArray[3];\n            } else if (curNodeType === 'NULL') {\n                debugger\n                //console.log(\"null node\")\n            }\n            else {\n                throw new Error(\"type error\")\n\n            }\n\n            //@ts-ignore\n            const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, null, \"O\");\n            if (curNodeType === \"LEFTNULL\") {\n                firstNode.nodeType = 'NULL';\n            }\n\n            //@ts-ignore\n            const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, null,\"O\");\n            if (curNodeType === \"RIGHTNULL\") {\n                secondNode.nodeType = 'NULL';\n            }\n            currentLevelNodes.push(firstNode);\n            currentLevelNodes.push(secondNode);\n            nodeNum += 2\n\n\n        }\n        levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n        levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [currentLevelNodes[0].index, currentLevelNodes[currentLevelNodes.length-1].index]);\n        for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n            currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n            currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n\n        }\n        lastLevelNodes = currentLevelNodes;\n        currentLevelNodes = [];\n    }\n    if(difIndex!==minvd.length){\n        debugger\n        throw new Error(\"diff not uesed\")\n    }\n\n\n    // debugger\n    // for (let i = 1; i <= Math.ceil(Math.log2(data.length)); i++) {\n    //     for (let j = 0; j < 2 ** (i - 1); j++) {\n\n    //         const lastNode = lastLevelNodes[j];\n    //         let dif = lastNode.difference!;\n    //         let curNodeType: \"O\" | \"NULL\" | \"LEFTNULL\" | \"RIGHTNULL\" = 'O';\n    //         if (dif[1] === null && dif[2] === null) {\n    //             throw new Error(\"data error\")\n    //             // curNodeType = \"NULL\";\n    //         } else if (dif[1] === null) {\n    //             curNodeType = \"LEFTNULL\"\n    //         } else if (dif[2] === null) {\n    //             debugger\n    //             curNodeType = \"RIGHTNULL\";\n    //         }\n    //         if (curNodeType !== \"O\") {\n    //             lastNode.nodeType = curNodeType\n    //         }\n    //         const yArray1: [any, any, any, any] = [undefined, undefined, undefined, undefined]\n    //         const yArray2: [any, any, any, any] = [undefined, undefined, undefined, undefined]\n    //         if (curNodeType === 'O') {\n    //             if (lastNode.difference![1] < 0) {\n    //                 yArray1[1] = lastNode.yArray[1];\n    //                 yArray2[1] = lastNode.yArray[1] - lastNode.difference![1];\n    //             } else {\n    //                 yArray1[1] = lastNode.yArray[1] + lastNode.difference![1];\n    //                 yArray2[1] = lastNode.yArray[1];\n    //             }\n    //             if (lastNode.difference![2] < 0) {\n    //                 yArray1[2] = lastNode.yArray[2] + lastNode.difference![2];\n    //                 yArray2[2] = lastNode.yArray[2];\n    //             } else {\n    //                 yArray1[2] = lastNode.yArray[2];\n    //                 yArray2[2] = lastNode.yArray[2] - lastNode.difference![2];\n    //             }\n    //         } else if (curNodeType == \"LEFTNULL\") {\n    //             yArray2[1] = lastNode.yArray[1];\n    //             yArray2[2] = lastNode.yArray[2];\n    //         } else if (curNodeType == \"RIGHTNULL\") {\n    //             yArray1[1] = lastNode.yArray[1];\n    //             yArray1[2] = lastNode.yArray[2];\n    //         } else if (curNodeType === 'NULL') {\n    //             debugger\n    //             //console.log(\"null node\")\n    //         }\n    //         else {\n    //             throw new Error(\"type error\")\n\n    //         }\n\n    //         //@ts-ignore\n    //         const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, i === Math.log2(data.length) ? null : [undefined, minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], undefined]);\n    //         if (lastNode.nodeType === \"LEFTNULL\") {\n    //             debugger\n    //             firstNode.nodeType = 'NULL';\n    //         }\n    //         //@ts-ignore\n    //         const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, i === Math.log2(data.length) ? null : [undefined, minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], undefined]);\n    //         if (lastNode.nodeType === \"RIGHTNULL\") {\n    //             debugger\n    //             secondNode.nodeType = 'NULL';\n    //         }\n    //         currentLevelNodes.push(firstNode);\n    //         currentLevelNodes.push(secondNode);\n    //         nodeNum += 2\n    //     }\n    //     levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n    //     levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n    //     for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n    //         currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n    //         currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n\n    //     }\n    //     lastLevelNodes = currentLevelNodes;\n    //     currentLevelNodes = [];\n    // }\n    //debugger\n    const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n    return {\n        dataManager: levelDataManager,\n        trendTree: root\n    }\n}\n\nfunction constructMinMaxMissTrendTreeForGetChildTree(data: Array<any>, width: number, tableName?: string) {\n    // const initLevel = Math.ceil(Math.log2(65536))-1;\n    const initLevel = Math.ceil(Math.log2(data.length));\n    // const initLevel = 2;\n    //debugger\n    const levelIndex = new Array<LevelIndexObj>(Math.ceil(Math.log2(data.length)) + 1);\n\n    const minvd: Array<number> = [];\n    const maxvd: Array<number> = [];\n    const avevd: Array<number> = [];\n\n    data.forEach(v => {\n        minvd.push(v.minvd);\n        maxvd.push(v.maxvd);\n        avevd.push(v.avevd);\n    });\n\n    let tempLast = minvd.pop();\n    minvd.unshift(tempLast!);\n    tempLast = maxvd.pop();\n    maxvd.unshift(tempLast!);\n    tempLast = avevd.pop();\n    avevd.unshift(tempLast!);\n\n    let lastLevelNodes = new Array<TrendTree>();\n    let currentLevelNodes = new Array<TrendTree>();\n    let nodeNum = 1;\n    //@ts-ignore\n    const root = new TrendTree(null, true, 0, [undefined, minvd[0], maxvd[0], avevd[0], undefined], [undefined, minvd[1], maxvd[1], avevd[1], undefined]);\n    lastLevelNodes.push(root);\n    levelIndex[0] = new LevelIndexObj(0, true);\n    levelIndex[0].addLoadedDataRange(root, [0, 0]);\n\n    let difIndex = 1;\n    for (let i = 1; i <= initLevel; i++) {\n        for (let j = 0; j < lastLevelNodes.length; j++) {\n            const lastNode = lastLevelNodes[j];\n            if (lastNode.nodeType === \"NULL\") {\n                //debugger\n                continue\n            }\n            if(difIndex===minvd.length){\n                debugger\n                throw new Error(\"diff index error\")\n            }\n            let dif = [minvd[difIndex], maxvd[difIndex], avevd[difIndex]];\n            difIndex++;\n            let curNodeType: \"O\" | \"NULL\" | \"LEFTNULL\" | \"RIGHTNULL\" = 'O';\n            if (dif[0] === null && dif[1] === null) {\n                throw new Error(\"data error\")\n                // curNodeType = \"NULL\";\n            } else if (dif[0] === null) {\n                curNodeType = \"LEFTNULL\"\n                lastNode.gapFlag='L'\n            } else if (dif[1] === null) {\n                \n                curNodeType = \"RIGHTNULL\";\n                lastNode.gapFlag='R'\n            }\n            if (curNodeType !== \"O\") {\n                lastNode.nodeType = curNodeType\n            }\n            const yArray1: [any, any, any, any, any] = [undefined, undefined, undefined, undefined, undefined]\n            const yArray2: [any, any, any, any, any] = [undefined, undefined, undefined, undefined, undefined]\n            if (curNodeType === 'O') {\n                if (dif[0] < 0) {\n                    yArray1[1] = lastNode.yArray[1];\n                    yArray2[1] = lastNode.yArray[1] - dif[0];\n                } else {\n                    yArray1[1] = lastNode.yArray[1] + dif[0];\n                    yArray2[1] = lastNode.yArray[1];\n                }\n                if (dif[1] < 0) {\n                    yArray1[2] = lastNode.yArray[2] + dif[1];\n                    yArray2[2] = lastNode.yArray[2];\n                } else {\n                    yArray1[2] = lastNode.yArray[2];\n                    yArray2[2] = lastNode.yArray[2] - dif[1];\n                }\n                if(dif[2] <= 0 || dif[2] >= 0){\n                    yArray1[3] = (lastNode.yArray[3] * 2 + dif[2]) / 2;\n                    yArray2[3] = (lastNode.yArray[3] * 2 - dif[2]) / 2;\n                }\n            } else if (curNodeType == \"LEFTNULL\") {\n                yArray2[1] = lastNode.yArray[1];\n                yArray2[2] = lastNode.yArray[2];\n                yArray2[3] = lastNode.yArray[3] / 2;\n            } else if (curNodeType == \"RIGHTNULL\") {\n                yArray1[1] = lastNode.yArray[1];\n                yArray1[2] = lastNode.yArray[2];\n                yArray1[3] = lastNode.yArray[3];\n            } else if (curNodeType === 'NULL') {\n                debugger\n                //console.log(\"null node\")\n            }\n            else {\n                throw new Error(\"type error\")\n\n            }\n\n            //@ts-ignore\n            const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, null, \"O\");\n            if (curNodeType === \"LEFTNULL\") {\n                firstNode.nodeType = 'NULL';\n            }\n\n            //@ts-ignore\n            const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, null,\"O\");\n            if (curNodeType === \"RIGHTNULL\") {\n                secondNode.nodeType = 'NULL';\n            }\n            currentLevelNodes.push(firstNode);\n            currentLevelNodes.push(secondNode);\n            nodeNum += 2\n\n\n        }\n        levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n        levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [currentLevelNodes[0].index, currentLevelNodes[currentLevelNodes.length-1].index]);\n        for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n            currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n            currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n\n        }\n        lastLevelNodes = currentLevelNodes;\n        currentLevelNodes = [];\n    }\n    if(difIndex!==minvd.length){\n        debugger\n        throw new Error(\"diff not uesed\")\n    }\n\n\n    // debugger\n    // for (let i = 1; i <= Math.ceil(Math.log2(data.length)); i++) {\n    //     for (let j = 0; j < 2 ** (i - 1); j++) {\n\n    //         const lastNode = lastLevelNodes[j];\n    //         let dif = lastNode.difference!;\n    //         let curNodeType: \"O\" | \"NULL\" | \"LEFTNULL\" | \"RIGHTNULL\" = 'O';\n    //         if (dif[1] === null && dif[2] === null) {\n    //             throw new Error(\"data error\")\n    //             // curNodeType = \"NULL\";\n    //         } else if (dif[1] === null) {\n    //             curNodeType = \"LEFTNULL\"\n    //         } else if (dif[2] === null) {\n    //             debugger\n    //             curNodeType = \"RIGHTNULL\";\n    //         }\n    //         if (curNodeType !== \"O\") {\n    //             lastNode.nodeType = curNodeType\n    //         }\n    //         const yArray1: [any, any, any, any] = [undefined, undefined, undefined, undefined]\n    //         const yArray2: [any, any, any, any] = [undefined, undefined, undefined, undefined]\n    //         if (curNodeType === 'O') {\n    //             if (lastNode.difference![1] < 0) {\n    //                 yArray1[1] = lastNode.yArray[1];\n    //                 yArray2[1] = lastNode.yArray[1] - lastNode.difference![1];\n    //             } else {\n    //                 yArray1[1] = lastNode.yArray[1] + lastNode.difference![1];\n    //                 yArray2[1] = lastNode.yArray[1];\n    //             }\n    //             if (lastNode.difference![2] < 0) {\n    //                 yArray1[2] = lastNode.yArray[2] + lastNode.difference![2];\n    //                 yArray2[2] = lastNode.yArray[2];\n    //             } else {\n    //                 yArray1[2] = lastNode.yArray[2];\n    //                 yArray2[2] = lastNode.yArray[2] - lastNode.difference![2];\n    //             }\n    //         } else if (curNodeType == \"LEFTNULL\") {\n    //             yArray2[1] = lastNode.yArray[1];\n    //             yArray2[2] = lastNode.yArray[2];\n    //         } else if (curNodeType == \"RIGHTNULL\") {\n    //             yArray1[1] = lastNode.yArray[1];\n    //             yArray1[2] = lastNode.yArray[2];\n    //         } else if (curNodeType === 'NULL') {\n    //             debugger\n    //             //console.log(\"null node\")\n    //         }\n    //         else {\n    //             throw new Error(\"type error\")\n\n    //         }\n\n    //         //@ts-ignore\n    //         const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, i === Math.log2(data.length) ? null : [undefined, minvd[j * 2 + 2 ** i], maxvd[j * 2 + 2 ** i], undefined]);\n    //         if (lastNode.nodeType === \"LEFTNULL\") {\n    //             debugger\n    //             firstNode.nodeType = 'NULL';\n    //         }\n    //         //@ts-ignore\n    //         const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, i === Math.log2(data.length) ? null : [undefined, minvd[j * 2 + 1 + 2 ** i], maxvd[j * 2 + 1 + 2 ** i], undefined]);\n    //         if (lastNode.nodeType === \"RIGHTNULL\") {\n    //             debugger\n    //             secondNode.nodeType = 'NULL';\n    //         }\n    //         currentLevelNodes.push(firstNode);\n    //         currentLevelNodes.push(secondNode);\n    //         nodeNum += 2\n    //     }\n    //     levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n    //     levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [0, currentLevelNodes.length - 1]);\n    //     for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n    //         currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n    //         currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n\n    //     }\n    //     lastLevelNodes = currentLevelNodes;\n    //     currentLevelNodes = [];\n    // }\n    //debugger\n    const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n    return {\n        dataManager: levelDataManager,\n        trendTree: root\n    }\n}\n\nfunction constructMinMaxMissTrendTreeMulti(data: Array<any>, width: number, tableName?: string) {\n    const initLevel = Math.ceil(Math.log2(width));\n    // const initLevel = 2;\n    //debugger\n    const levelIndex = new Array<LevelIndexObj>(Math.ceil(Math.log2(data.length)) + 1);\n\n    const minvd: Array<number> = [];\n    const maxvd: Array<number> = [];\n    const avevd: Array<number> = [];\n\n    data.forEach(v => {\n        minvd.push(v.minvd);\n        maxvd.push(v.maxvd);\n        avevd.push(v.avevd);\n    });\n\n    let tempLast = minvd.pop();\n    minvd.unshift(tempLast!);\n    tempLast = maxvd.pop();\n    maxvd.unshift(tempLast!);\n    tempLast = avevd.pop();\n    avevd.unshift(tempLast!);\n\n    let lastLevelNodes = new Array<TrendTree>();\n    let currentLevelNodes = new Array<TrendTree>();\n    let nodeNum = 1;\n    //@ts-ignore\n    const root = new TrendTree(null, true, 0, [undefined, minvd[0], maxvd[0], avevd[0], undefined], [undefined, minvd[1], maxvd[1], avevd[1], undefined]);\n    lastLevelNodes.push(root);\n    levelIndex[0] = new LevelIndexObj(0, true);\n    levelIndex[0].addLoadedDataRange(root, [0, 0]);\n\n    let difIndex = 1;\n    for (let i = 1; i <= initLevel; i++) {\n        for (let j = 0; j < lastLevelNodes.length; j++) {\n            const lastNode = lastLevelNodes[j];\n            if (lastNode.nodeType === \"NULL\") {\n                //debugger\n                continue\n            }\n            if(difIndex===minvd.length){\n                debugger\n                throw new Error(\"diff index error\")\n            }\n            let dif = [minvd[difIndex], maxvd[difIndex], avevd[difIndex]];\n            difIndex++;\n            let curNodeType: \"O\" | \"NULL\" | \"LEFTNULL\" | \"RIGHTNULL\" = 'O';\n            if (dif[0] === null && dif[1] === null) {\n                throw new Error(\"data error\")\n                // curNodeType = \"NULL\";\n            } else if (dif[0] === null) {\n                curNodeType = \"LEFTNULL\"\n                lastNode.gapFlag='L'\n            } else if (dif[1] === null) {\n                \n                curNodeType = \"RIGHTNULL\";\n                lastNode.gapFlag='R'\n            }\n            if (curNodeType !== \"O\") {\n                lastNode.nodeType = curNodeType\n            }\n            const yArray1: [any, any, any, any, any] = [undefined, undefined, undefined, undefined, undefined]\n            const yArray2: [any, any, any, any, any] = [undefined, undefined, undefined, undefined, undefined]\n            if (curNodeType === 'O') {\n                if (dif[0] < 0) {\n                    yArray1[1] = lastNode.yArray[1];\n                    yArray2[1] = lastNode.yArray[1] - dif[0];\n                } else {\n                    yArray1[1] = lastNode.yArray[1] + dif[0];\n                    yArray2[1] = lastNode.yArray[1];\n                }\n                if (dif[1] < 0) {\n                    yArray1[2] = lastNode.yArray[2] + dif[1];\n                    yArray2[2] = lastNode.yArray[2];\n                } else {\n                    yArray1[2] = lastNode.yArray[2];\n                    yArray2[2] = lastNode.yArray[2] - dif[1];\n                }\n                if(dif[2] <= 0 || dif[2] >= 0){\n                    yArray1[3] = (lastNode.yArray[3] * 2 + dif[2]) / 2;\n                    yArray2[3] = (lastNode.yArray[3] * 2 - dif[2]) / 2;\n                }\n            } else if (curNodeType == \"LEFTNULL\") {\n                yArray2[1] = lastNode.yArray[1];\n                yArray2[2] = lastNode.yArray[2];\n                yArray2[3] = lastNode.yArray[3] / 2;\n            } else if (curNodeType == \"RIGHTNULL\") {\n                yArray1[1] = lastNode.yArray[1];\n                yArray1[2] = lastNode.yArray[2];\n                yArray1[3] = lastNode.yArray[3];\n            } else if (curNodeType === 'NULL') {\n                debugger\n                //console.log(\"null node\")\n            }\n            else {\n                throw new Error(\"type error\")\n\n            }\n\n            //@ts-ignore\n            const firstNode = new TrendTree(lastNode, true, lastNode.index, yArray1, null, \"O\");\n            if (curNodeType === \"LEFTNULL\") {\n                firstNode.nodeType = 'NULL';\n            }\n\n            //@ts-ignore\n            const secondNode = new TrendTree(lastNode, false, lastNode.index, yArray2, null,\"O\");\n            if (curNodeType === \"RIGHTNULL\") {\n                secondNode.nodeType = 'NULL';\n            }\n            currentLevelNodes.push(firstNode);\n            currentLevelNodes.push(secondNode);\n            nodeNum += 2\n\n\n        }\n        levelIndex[i] = new LevelIndexObj(currentLevelNodes[0].level, true);\n        levelIndex[i].addLoadedDataRange(currentLevelNodes[0], [currentLevelNodes[0].index, currentLevelNodes[currentLevelNodes.length-1].index]);\n        for (let i = 0; i < currentLevelNodes.length - 1; i++) {\n            currentLevelNodes[i].nextSibling = currentLevelNodes[i + 1];\n            currentLevelNodes[i + 1].previousSibling = currentLevelNodes[i];\n\n        }\n        lastLevelNodes = currentLevelNodes;\n        currentLevelNodes = [];\n    }\n    if(difIndex!==minvd.length){\n        debugger\n        throw new Error(\"diff not uesed\")\n    }\n\n    const levelDataManager = new LevelDataManager(levelIndex, tableName ? tableName : store.state.controlParams.currentTable);\n    return {\n        dataManager: levelDataManager,\n        trendTree: root\n    }\n}\n// export { constructRawMinMaxTrendTree, constructMinMaxMissTrendTree, constructMissTrendTree, initWaveletDecode, waveletDecode, constructTrendTree, constructHaarTree, constructMinMaxTrendTree }\nexport { constructMinMaxMissTrendTree, initWaveletDecode, waveletDecode, constructTrendTree, constructHaarTree, constructMinMaxMissTrendTreeMulti, constructMinMaxMissTrendTreeForGetChildTree }"],"mappings":"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A;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAS0B,4BAA4BA,CAACrC,IAAgB,EAAEsC,KAAa,EAAErC,SAAkB;EACrF,MAAMsC,SAAS,GAAG1E,IAAI,CAAC2E,IAAI,CAAC3E,IAAI,CAACC,IAAI,CAACkC,IAAI,CAACjC,MAAM,CAAC,CAAC;EACnD;EACA;EACA;EACA,MAAMm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","ignoreList":[]}]}